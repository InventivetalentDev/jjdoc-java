{"name":"BigDecimal","comment":"Immutable, arbitrary-precision signed decimal numbers.  A\n {@code BigDecimal} consists of an arbitrary precision integer\n \u003ci\u003eunscaled value\u003c/i\u003e and a 32-bit integer \u003ci\u003escale\u003c/i\u003e.  If zero\n or positive, the scale is the number of digits to the right of the\n decimal point.  If negative, the unscaled value of the number is\n multiplied by ten to the power of the negation of the scale.  The\n value of the number represented by the {@code BigDecimal} is\n therefore \u003ctt\u003e(unscaledValue \u0026times; 10\u003csup\u003e-scale\u003c/sup\u003e)\u003c/tt\u003e.\n\n \u003cp\u003eThe {@code BigDecimal} class provides operations for\n arithmetic, scale manipulation, rounding, comparison, hashing, and\n format conversion.  The {@link #toString} method provides a\n canonical representation of a {@code BigDecimal}.\n\n \u003cp\u003eThe {@code BigDecimal} class gives its user complete control\n over rounding behavior.  If no rounding mode is specified and the\n exact result cannot be represented, an exception is thrown;\n otherwise, calculations can be carried out to a chosen precision\n and rounding mode by supplying an appropriate {@link MathContext}\n object to the operation.  In either case, eight \u003cem\u003erounding\n modes\u003c/em\u003e are provided for the control of rounding.  Using the\n integer fields in this class (such as {@link #ROUND_HALF_UP}) to\n represent rounding mode is largely obsolete; the enumeration values\n of the {@code RoundingMode} {@code enum}, (such as {@link\n RoundingMode#HALF_UP}) should be used instead.\n\n \u003cp\u003eWhen a {@code MathContext} object is supplied with a precision\n setting of 0 (for example, {@link MathContext#UNLIMITED}),\n arithmetic operations are exact, as are the arithmetic methods\n which take no {@code MathContext} object.  (This is the only\n behavior that was supported in releases prior to 5.)  As a\n corollary of computing the exact result, the rounding mode setting\n of a {@code MathContext} object with a precision setting of 0 is\n not used and thus irrelevant.  In the case of divide, the exact\n quotient could have an infinitely long decimal expansion; for\n example, 1 divided by 3.  If the quotient has a nonterminating\n decimal expansion and the operation is specified to return an exact\n result, an {@code ArithmeticException} is thrown.  Otherwise, the\n exact result of the division is returned, as done for other\n operations.\n\n \u003cp\u003eWhen the precision setting is not 0, the rules of\n {@code BigDecimal} arithmetic are broadly compatible with selected\n modes of operation of the arithmetic defined in ANSI X3.274-1996\n and ANSI X3.274-1996/AM 1-2000 (section 7.4).  Unlike those\n standards, {@code BigDecimal} includes many rounding modes, which\n were mandatory for division in {@code BigDecimal} releases prior\n to 5.  Any conflicts between these ANSI standards and the\n {@code BigDecimal} specification are resolved in favor of\n {@code BigDecimal}.\n\n \u003cp\u003eSince the same numerical value can have different\n representations (with different scales), the rules of arithmetic\n and rounding must specify both the numerical result and the scale\n used in the result\u0027s representation.\n\n\n \u003cp\u003eIn general the rounding modes and precision setting determine\n how operations return results with a limited number of digits when\n the exact result has more digits (perhaps infinitely many in the\n case of division) than the number of digits returned.\n\n First, the\n total number of digits to return is specified by the\n {@code MathContext}\u0027s {@code precision} setting; this determines\n the result\u0027s \u003ci\u003eprecision\u003c/i\u003e.  The digit count starts from the\n leftmost nonzero digit of the exact result.  The rounding mode\n determines how any discarded trailing digits affect the returned\n result.\n\n \u003cp\u003eFor all arithmetic operators , the operation is carried out as\n though an exact intermediate result were first calculated and then\n rounded to the number of digits specified by the precision setting\n (if necessary), using the selected rounding mode.  If the exact\n result is not returned, some digit positions of the exact result\n are discarded.  When rounding increases the magnitude of the\n returned result, it is possible for a new digit position to be\n created by a carry propagating to a leading {@literal \"9\"} digit.\n For example, rounding the value 999.9 to three digits rounding up\n would be numerically equal to one thousand, represented as\n 100\u0026times;10\u003csup\u003e1\u003c/sup\u003e.  In such cases, the new {@literal \"1\"} is\n the leading digit position of the returned result.\n\n \u003cp\u003eBesides a logical exact result, each arithmetic operation has a\n preferred scale for representing a result.  The preferred\n scale for each operation is listed in the table below.\n\n \u003ctable border\u003e\n \u003ccaption\u003e\u003cb\u003ePreferred Scales for Results of Arithmetic Operations\n \u003c/b\u003e\u003c/caption\u003e\n \u003ctr\u003e\u003cth\u003eOperation\u003c/th\u003e\u003cth\u003ePreferred Scale of Result\u003c/th\u003e\u003c/tr\u003e\n \u003ctr\u003e\u003ctd\u003eAdd\u003c/td\u003e\u003ctd\u003emax(addend.scale(), augend.scale())\u003c/td\u003e\n \u003ctr\u003e\u003ctd\u003eSubtract\u003c/td\u003e\u003ctd\u003emax(minuend.scale(), subtrahend.scale())\u003c/td\u003e\n \u003ctr\u003e\u003ctd\u003eMultiply\u003c/td\u003e\u003ctd\u003emultiplier.scale() + multiplicand.scale()\u003c/td\u003e\n \u003ctr\u003e\u003ctd\u003eDivide\u003c/td\u003e\u003ctd\u003edividend.scale() - divisor.scale()\u003c/td\u003e\n \u003c/table\u003e\n\n These scales are the ones used by the methods which return exact\n arithmetic results; except that an exact divide may have to use a\n larger scale since the exact result may have more digits.  For\n example, {@code 1/32} is {@code 0.03125}.\n\n \u003cp\u003eBefore rounding, the scale of the logical exact intermediate\n result is the preferred scale for that operation.  If the exact\n numerical result cannot be represented in {@code precision}\n digits, rounding selects the set of digits to return and the scale\n of the result is reduced from the scale of the intermediate result\n to the least scale which can represent the {@code precision}\n digits actually returned.  If the exact result can be represented\n with at most {@code precision} digits, the representation\n of the result with the scale closest to the preferred scale is\n returned.  In particular, an exactly representable quotient may be\n represented in fewer than {@code precision} digits by removing\n trailing zeros and decreasing the scale.  For example, rounding to\n three digits using the {@linkplain RoundingMode#FLOOR floor}\n rounding mode, \u003cbr\u003e\n\n {@code 19/100 \u003d 0.19   // integer\u003d19,  scale\u003d2} \u003cbr\u003e\n\n but\u003cbr\u003e\n\n {@code 21/110 \u003d 0.190  // integer\u003d190, scale\u003d3} \u003cbr\u003e\n\n \u003cp\u003eNote that for add, subtract, and multiply, the reduction in\n scale will equal the number of digit positions of the exact result\n which are discarded. If the rounding causes a carry propagation to\n create a new high-order digit position, an additional digit of the\n result is discarded than when no new digit position is created.\n\n \u003cp\u003eOther methods may have slightly different rounding semantics.\n For example, the result of the {@code pow} method using the\n {@linkplain #pow(int, MathContext) specified algorithm} can\n occasionally differ from the rounded mathematical result by more\n than one unit in the last place, one \u003ci\u003e{@linkplain #ulp() ulp}\u003c/i\u003e.\n\n \u003cp\u003eTwo types of operations are provided for manipulating the scale\n of a {@code BigDecimal}: scaling/rounding operations and decimal\n point motion operations.  Scaling/rounding operations ({@link\n #setScale setScale} and {@link #round round}) return a\n {@code BigDecimal} whose value is approximately (or exactly) equal\n to that of the operand, but whose scale or precision is the\n specified value; that is, they increase or decrease the precision\n of the stored number with minimal effect on its value.  Decimal\n point motion operations ({@link #movePointLeft movePointLeft} and\n {@link #movePointRight movePointRight}) return a\n {@code BigDecimal} created from the operand by moving the decimal\n point a specified distance in the specified direction.\n\n \u003cp\u003eFor the sake of brevity and clarity, pseudo-code is used\n throughout the descriptions of {@code BigDecimal} methods.  The\n pseudo-code expression {@code (i + j)} is shorthand for \"a\n {@code BigDecimal} whose value is that of the {@code BigDecimal}\n {@code i} added to that of the {@code BigDecimal}\n {@code j}.\" The pseudo-code expression {@code (i \u003d\u003d j)} is\n shorthand for \"{@code true} if and only if the\n {@code BigDecimal} {@code i} represents the same value as the\n {@code BigDecimal} {@code j}.\" Other pseudo-code expressions\n are interpreted similarly.  Square brackets are used to represent\n the particular {@code BigInteger} and scale pair defining a\n {@code BigDecimal} value; for example [19, 2] is the\n {@code BigDecimal} numerically equal to 0.19 having a scale of 2.\n\n \u003cp\u003eNote: care should be exercised if {@code BigDecimal} objects\n are used as keys in a {@link java.util.SortedMap SortedMap} or\n elements in a {@link java.util.SortedSet SortedSet} since\n {@code BigDecimal}\u0027s \u003ci\u003enatural ordering\u003c/i\u003e is \u003ci\u003einconsistent\n with equals\u003c/i\u003e.  See {@link Comparable}, {@link\n java.util.SortedMap} or {@link java.util.SortedSet} for more\n information.\n\n \u003cp\u003eAll methods and constructors for this class throw\n {@code NullPointerException} when passed a {@code null} object\n reference for any input parameter.","isClass":true,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":false,"isOrdinaryClass":true,"isPrimitive":false,"simpleName":"BigDecimal","qualifiedName":"java.math.BigDecimal","dimension":"","elementType":{},"package":"java.math","superclass":"java.lang.Number","interfaces":["java.lang.Comparable"],"isAbstract":false,"isStatic":false,"innerClasses":[],"isInnerClass":false,"constructors":[{"name":"BigDecimal","comment":"Translates a character array representation of a\n {@code BigDecimal} into a {@code BigDecimal}, accepting the\n same sequence of characters as the {@link #BigDecimal(String)}\n constructor, while allowing a sub-array to be specified.\n\n \u003cp\u003eNote that if the sequence of characters is already available\n within a character array, using this constructor is faster than\n converting the {@code char} array to string and using the\n {@code BigDecimal(String)} constructor .","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":true,"isField":false,"isMethod":false,"isOrdinaryClass":false,"signature":"(char[], int, int)","flatSignature":"(char[], int, int)","parameters":[{"name":"in","type":{"isPrimitive":true,"simpleName":"char","qualifiedName":"char","dimension":"[]","elementType":{"isPrimitive":true,"simpleName":"char","qualifiedName":"char","dimension":"","elementType":{}}}},{"name":"offset","type":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}}},{"name":"len","type":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"BigDecimal","comment":"Translates a character array representation of a\n {@code BigDecimal} into a {@code BigDecimal}, accepting the\n same sequence of characters as the {@link #BigDecimal(String)}\n constructor, while allowing a sub-array to be specified and\n with rounding according to the context settings.\n\n \u003cp\u003eNote that if the sequence of characters is already available\n within a character array, using this constructor is faster than\n converting the {@code char} array to string and using the\n {@code BigDecimal(String)} constructor .","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":true,"isField":false,"isMethod":false,"isOrdinaryClass":false,"signature":"(char[], int, int, java.math.MathContext)","flatSignature":"(char[], int, int, MathContext)","parameters":[{"name":"in","type":{"isPrimitive":true,"simpleName":"char","qualifiedName":"char","dimension":"[]","elementType":{"isPrimitive":true,"simpleName":"char","qualifiedName":"char","dimension":"","elementType":{}}}},{"name":"offset","type":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}}},{"name":"len","type":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}}},{"name":"mc","type":{"isPrimitive":false,"simpleName":"MathContext","qualifiedName":"java.math.MathContext","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"BigDecimal","comment":"Translates a character array representation of a\n {@code BigDecimal} into a {@code BigDecimal}, accepting the\n same sequence of characters as the {@link #BigDecimal(String)}\n constructor.\n\n \u003cp\u003eNote that if the sequence of characters is already available\n as a character array, using this constructor is faster than\n converting the {@code char} array to string and using the\n {@code BigDecimal(String)} constructor .","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":true,"isField":false,"isMethod":false,"isOrdinaryClass":false,"signature":"(char[])","flatSignature":"(char[])","parameters":[{"name":"in","type":{"isPrimitive":true,"simpleName":"char","qualifiedName":"char","dimension":"[]","elementType":{"isPrimitive":true,"simpleName":"char","qualifiedName":"char","dimension":"","elementType":{}}}}],"typeParameters":[]},{"name":"BigDecimal","comment":"Translates a character array representation of a\n {@code BigDecimal} into a {@code BigDecimal}, accepting the\n same sequence of characters as the {@link #BigDecimal(String)}\n constructor and with rounding according to the context\n settings.\n\n \u003cp\u003eNote that if the sequence of characters is already available\n as a character array, using this constructor is faster than\n converting the {@code char} array to string and using the\n {@code BigDecimal(String)} constructor .","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":true,"isField":false,"isMethod":false,"isOrdinaryClass":false,"signature":"(char[], java.math.MathContext)","flatSignature":"(char[], MathContext)","parameters":[{"name":"in","type":{"isPrimitive":true,"simpleName":"char","qualifiedName":"char","dimension":"[]","elementType":{"isPrimitive":true,"simpleName":"char","qualifiedName":"char","dimension":"","elementType":{}}}},{"name":"mc","type":{"isPrimitive":false,"simpleName":"MathContext","qualifiedName":"java.math.MathContext","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"BigDecimal","comment":"Translates the string representation of a {@code BigDecimal}\n into a {@code BigDecimal}.  The string representation consists\n of an optional sign, {@code \u0027+\u0027} (\u003ctt\u003e \u0027\u0026#92;u002B\u0027\u003c/tt\u003e) or\n {@code \u0027-\u0027} (\u003ctt\u003e\u0027\u0026#92;u002D\u0027\u003c/tt\u003e), followed by a sequence of\n zero or more decimal digits (\"the integer\"), optionally\n followed by a fraction, optionally followed by an exponent.\n\n \u003cp\u003eThe fraction consists of a decimal point followed by zero\n or more decimal digits.  The string must contain at least one\n digit in either the integer or the fraction.  The number formed\n by the sign, the integer and the fraction is referred to as the\n \u003ci\u003esignificand\u003c/i\u003e.\n\n \u003cp\u003eThe exponent consists of the character {@code \u0027e\u0027}\n (\u003ctt\u003e\u0027\u0026#92;u0065\u0027\u003c/tt\u003e) or {@code \u0027E\u0027} (\u003ctt\u003e\u0027\u0026#92;u0045\u0027\u003c/tt\u003e)\n followed by one or more decimal digits.  The value of the\n exponent must lie between -{@link Integer#MAX_VALUE} ({@link\n Integer#MIN_VALUE}+1) and {@link Integer#MAX_VALUE}, inclusive.\n\n \u003cp\u003eMore formally, the strings this constructor accepts are\n described by the following grammar:\n \u003cblockquote\u003e\n \u003cdl\u003e\n \u003cdt\u003e\u003ci\u003eBigDecimalString:\u003c/i\u003e\n \u003cdd\u003e\u003ci\u003eSign\u003csub\u003eopt\u003c/sub\u003e Significand Exponent\u003csub\u003eopt\u003c/sub\u003e\u003c/i\u003e\n \u003cdt\u003e\u003ci\u003eSign:\u003c/i\u003e\n \u003cdd\u003e{@code +}\n \u003cdd\u003e{@code -}\n \u003cdt\u003e\u003ci\u003eSignificand:\u003c/i\u003e\n \u003cdd\u003e\u003ci\u003eIntegerPart\u003c/i\u003e {@code .} \u003ci\u003eFractionPart\u003csub\u003eopt\u003c/sub\u003e\u003c/i\u003e\n \u003cdd\u003e{@code .} \u003ci\u003eFractionPart\u003c/i\u003e\n \u003cdd\u003e\u003ci\u003eIntegerPart\u003c/i\u003e\n \u003cdt\u003e\u003ci\u003eIntegerPart:\u003c/i\u003e\n \u003cdd\u003e\u003ci\u003eDigits\u003c/i\u003e\n \u003cdt\u003e\u003ci\u003eFractionPart:\u003c/i\u003e\n \u003cdd\u003e\u003ci\u003eDigits\u003c/i\u003e\n \u003cdt\u003e\u003ci\u003eExponent:\u003c/i\u003e\n \u003cdd\u003e\u003ci\u003eExponentIndicator SignedInteger\u003c/i\u003e\n \u003cdt\u003e\u003ci\u003eExponentIndicator:\u003c/i\u003e\n \u003cdd\u003e{@code e}\n \u003cdd\u003e{@code E}\n \u003cdt\u003e\u003ci\u003eSignedInteger:\u003c/i\u003e\n \u003cdd\u003e\u003ci\u003eSign\u003csub\u003eopt\u003c/sub\u003e Digits\u003c/i\u003e\n \u003cdt\u003e\u003ci\u003eDigits:\u003c/i\u003e\n \u003cdd\u003e\u003ci\u003eDigit\u003c/i\u003e\n \u003cdd\u003e\u003ci\u003eDigits Digit\u003c/i\u003e\n \u003cdt\u003e\u003ci\u003eDigit:\u003c/i\u003e\n \u003cdd\u003eany character for which {@link Character#isDigit}\n returns {@code true}, including 0, 1, 2 ...\n \u003c/dl\u003e\n \u003c/blockquote\u003e\n\n \u003cp\u003eThe scale of the returned {@code BigDecimal} will be the\n number of digits in the fraction, or zero if the string\n contains no decimal point, subject to adjustment for any\n exponent; if the string contains an exponent, the exponent is\n subtracted from the scale.  The value of the resulting scale\n must lie between {@code Integer.MIN_VALUE} and\n {@code Integer.MAX_VALUE}, inclusive.\n\n \u003cp\u003eThe character-to-digit mapping is provided by {@link\n java.lang.Character#digit} set to convert to radix 10.  The\n String may not contain any extraneous characters (whitespace,\n for example).\n\n \u003cp\u003e\u003cb\u003eExamples:\u003c/b\u003e\u003cbr\u003e\n The value of the returned {@code BigDecimal} is equal to\n \u003ci\u003esignificand\u003c/i\u003e \u0026times; 10\u003csup\u003e\u0026nbsp;\u003ci\u003eexponent\u003c/i\u003e\u003c/sup\u003e.\n For each string on the left, the resulting representation\n [{@code BigInteger}, {@code scale}] is shown on the right.\n \u003cpre\u003e\n \"0\"            [0,0]\n \"0.00\"         [0,2]\n \"123\"          [123,0]\n \"-123\"         [-123,0]\n \"1.23E3\"       [123,-1]\n \"1.23E+3\"      [123,-1]\n \"12.3E+7\"      [123,-6]\n \"12.0\"         [120,1]\n \"12.3\"         [123,1]\n \"0.00123\"      [123,5]\n \"-1.23E-12\"    [-123,14]\n \"1234.5E-4\"    [12345,5]\n \"0E+7\"         [0,-7]\n \"-0\"           [0,0]\n \u003c/pre\u003e\n\n \u003cp\u003eNote: For values other than {@code float} and\n {@code double} NaN and \u0026plusmn;Infinity, this constructor is\n compatible with the values returned by {@link Float#toString}\n and {@link Double#toString}.  This is generally the preferred\n way to convert a {@code float} or {@code double} into a\n BigDecimal, as it doesn\u0027t suffer from the unpredictability of\n the {@link #BigDecimal(double)} constructor.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":true,"isField":false,"isMethod":false,"isOrdinaryClass":false,"signature":"(java.lang.String)","flatSignature":"(String)","parameters":[{"name":"val","type":{"isPrimitive":false,"simpleName":"String","qualifiedName":"java.lang.String","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"BigDecimal","comment":"Translates the string representation of a {@code BigDecimal}\n into a {@code BigDecimal}, accepting the same strings as the\n {@link #BigDecimal(String)} constructor, with rounding\n according to the context settings.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":true,"isField":false,"isMethod":false,"isOrdinaryClass":false,"signature":"(java.lang.String, java.math.MathContext)","flatSignature":"(String, MathContext)","parameters":[{"name":"val","type":{"isPrimitive":false,"simpleName":"String","qualifiedName":"java.lang.String","dimension":"","elementType":{}}},{"name":"mc","type":{"isPrimitive":false,"simpleName":"MathContext","qualifiedName":"java.math.MathContext","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"BigDecimal","comment":"Translates a {@code double} into a {@code BigDecimal} which\n is the exact decimal representation of the {@code double}\u0027s\n binary floating-point value.  The scale of the returned\n {@code BigDecimal} is the smallest value such that\n \u003ctt\u003e(10\u003csup\u003escale\u003c/sup\u003e \u0026times; val)\u003c/tt\u003e is an integer.\n \u003cp\u003e\n \u003cb\u003eNotes:\u003c/b\u003e\n \u003col\u003e\n \u003cli\u003e\n The results of this constructor can be somewhat unpredictable.\n One might assume that writing {@code new BigDecimal(0.1)} in\n Java creates a {@code BigDecimal} which is exactly equal to\n 0.1 (an unscaled value of 1, with a scale of 1), but it is\n actually equal to\n 0.1000000000000000055511151231257827021181583404541015625.\n This is because 0.1 cannot be represented exactly as a\n {@code double} (or, for that matter, as a binary fraction of\n any finite length).  Thus, the value that is being passed\n \u003ci\u003ein\u003c/i\u003e to the constructor is not exactly equal to 0.1,\n appearances notwithstanding.\n\n \u003cli\u003e\n The {@code String} constructor, on the other hand, is\n perfectly predictable: writing {@code new BigDecimal(\"0.1\")}\n creates a {@code BigDecimal} which is \u003ci\u003eexactly\u003c/i\u003e equal to\n 0.1, as one would expect.  Therefore, it is generally\n recommended that the {@linkplain #BigDecimal(String)\n \u003ctt\u003eString\u003c/tt\u003e constructor} be used in preference to this one.\n\n \u003cli\u003e\n When a {@code double} must be used as a source for a\n {@code BigDecimal}, note that this constructor provides an\n exact conversion; it does not give the same result as\n converting the {@code double} to a {@code String} using the\n {@link Double#toString(double)} method and then using the\n {@link #BigDecimal(String)} constructor.  To get that result,\n use the {@code static} {@link #valueOf(double)} method.\n \u003c/ol\u003e","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":true,"isField":false,"isMethod":false,"isOrdinaryClass":false,"signature":"(double)","flatSignature":"(double)","parameters":[{"name":"val","type":{"isPrimitive":true,"simpleName":"double","qualifiedName":"double","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"BigDecimal","comment":"Translates a {@code double} into a {@code BigDecimal}, with\n rounding according to the context settings.  The scale of the\n {@code BigDecimal} is the smallest value such that\n \u003ctt\u003e(10\u003csup\u003escale\u003c/sup\u003e \u0026times; val)\u003c/tt\u003e is an integer.\n\n \u003cp\u003eThe results of this constructor can be somewhat unpredictable\n and its use is generally not recommended; see the notes under\n the {@link #BigDecimal(double)} constructor.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":true,"isField":false,"isMethod":false,"isOrdinaryClass":false,"signature":"(double, java.math.MathContext)","flatSignature":"(double, MathContext)","parameters":[{"name":"val","type":{"isPrimitive":true,"simpleName":"double","qualifiedName":"double","dimension":"","elementType":{}}},{"name":"mc","type":{"isPrimitive":false,"simpleName":"MathContext","qualifiedName":"java.math.MathContext","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"BigDecimal","comment":"Translates a {@code BigInteger} into a {@code BigDecimal}.\n The scale of the {@code BigDecimal} is zero.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":true,"isField":false,"isMethod":false,"isOrdinaryClass":false,"signature":"(java.math.BigInteger)","flatSignature":"(BigInteger)","parameters":[{"name":"val","type":{"isPrimitive":false,"simpleName":"BigInteger","qualifiedName":"java.math.BigInteger","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"BigDecimal","comment":"Translates a {@code BigInteger} into a {@code BigDecimal}\n rounding according to the context settings.  The scale of the\n {@code BigDecimal} is zero.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":true,"isField":false,"isMethod":false,"isOrdinaryClass":false,"signature":"(java.math.BigInteger, java.math.MathContext)","flatSignature":"(BigInteger, MathContext)","parameters":[{"name":"val","type":{"isPrimitive":false,"simpleName":"BigInteger","qualifiedName":"java.math.BigInteger","dimension":"","elementType":{}}},{"name":"mc","type":{"isPrimitive":false,"simpleName":"MathContext","qualifiedName":"java.math.MathContext","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"BigDecimal","comment":"Translates a {@code BigInteger} unscaled value and an\n {@code int} scale into a {@code BigDecimal}.  The value of\n the {@code BigDecimal} is\n \u003ctt\u003e(unscaledVal \u0026times; 10\u003csup\u003e-scale\u003c/sup\u003e)\u003c/tt\u003e.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":true,"isField":false,"isMethod":false,"isOrdinaryClass":false,"signature":"(java.math.BigInteger, int)","flatSignature":"(BigInteger, int)","parameters":[{"name":"unscaledVal","type":{"isPrimitive":false,"simpleName":"BigInteger","qualifiedName":"java.math.BigInteger","dimension":"","elementType":{}}},{"name":"scale","type":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"BigDecimal","comment":"Translates a {@code BigInteger} unscaled value and an\n {@code int} scale into a {@code BigDecimal}, with rounding\n according to the context settings.  The value of the\n {@code BigDecimal} is \u003ctt\u003e(unscaledVal \u0026times;\n 10\u003csup\u003e-scale\u003c/sup\u003e)\u003c/tt\u003e, rounded according to the\n {@code precision} and rounding mode settings.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":true,"isField":false,"isMethod":false,"isOrdinaryClass":false,"signature":"(java.math.BigInteger, int, java.math.MathContext)","flatSignature":"(BigInteger, int, MathContext)","parameters":[{"name":"unscaledVal","type":{"isPrimitive":false,"simpleName":"BigInteger","qualifiedName":"java.math.BigInteger","dimension":"","elementType":{}}},{"name":"scale","type":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}}},{"name":"mc","type":{"isPrimitive":false,"simpleName":"MathContext","qualifiedName":"java.math.MathContext","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"BigDecimal","comment":"Translates an {@code int} into a {@code BigDecimal}.  The\n scale of the {@code BigDecimal} is zero.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":true,"isField":false,"isMethod":false,"isOrdinaryClass":false,"signature":"(int)","flatSignature":"(int)","parameters":[{"name":"val","type":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"BigDecimal","comment":"Translates an {@code int} into a {@code BigDecimal}, with\n rounding according to the context settings.  The scale of the\n {@code BigDecimal}, before any rounding, is zero.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":true,"isField":false,"isMethod":false,"isOrdinaryClass":false,"signature":"(int, java.math.MathContext)","flatSignature":"(int, MathContext)","parameters":[{"name":"val","type":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}}},{"name":"mc","type":{"isPrimitive":false,"simpleName":"MathContext","qualifiedName":"java.math.MathContext","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"BigDecimal","comment":"Translates a {@code long} into a {@code BigDecimal}.  The\n scale of the {@code BigDecimal} is zero.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":true,"isField":false,"isMethod":false,"isOrdinaryClass":false,"signature":"(long)","flatSignature":"(long)","parameters":[{"name":"val","type":{"isPrimitive":true,"simpleName":"long","qualifiedName":"long","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"BigDecimal","comment":"Translates a {@code long} into a {@code BigDecimal}, with\n rounding according to the context settings.  The scale of the\n {@code BigDecimal}, before any rounding, is zero.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":true,"isField":false,"isMethod":false,"isOrdinaryClass":false,"signature":"(long, java.math.MathContext)","flatSignature":"(long, MathContext)","parameters":[{"name":"val","type":{"isPrimitive":true,"simpleName":"long","qualifiedName":"long","dimension":"","elementType":{}}},{"name":"mc","type":{"isPrimitive":false,"simpleName":"MathContext","qualifiedName":"java.math.MathContext","dimension":"","elementType":{}}}],"typeParameters":[]}],"fields":[{"name":"ZERO","comment":"The value 0, with a scale of 0.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":true,"isMethod":false,"isOrdinaryClass":false,"type":{"isPrimitive":false,"simpleName":"BigDecimal","qualifiedName":"java.math.BigDecimal","dimension":"","elementType":{}},"isStatic":true},{"name":"ONE","comment":"The value 1, with a scale of 0.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":true,"isMethod":false,"isOrdinaryClass":false,"type":{"isPrimitive":false,"simpleName":"BigDecimal","qualifiedName":"java.math.BigDecimal","dimension":"","elementType":{}},"isStatic":true},{"name":"TEN","comment":"The value 10, with a scale of 0.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":true,"isMethod":false,"isOrdinaryClass":false,"type":{"isPrimitive":false,"simpleName":"BigDecimal","qualifiedName":"java.math.BigDecimal","dimension":"","elementType":{}},"isStatic":true},{"name":"ROUND_UP","comment":"Rounding mode to round away from zero.  Always increments the\n digit prior to a nonzero discarded fraction.  Note that this rounding\n mode never decreases the magnitude of the calculated value.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":true,"isMethod":false,"isOrdinaryClass":false,"type":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}},"isStatic":true,"constantValue":"0"},{"name":"ROUND_DOWN","comment":"Rounding mode to round towards zero.  Never increments the digit\n prior to a discarded fraction (i.e., truncates).  Note that this\n rounding mode never increases the magnitude of the calculated value.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":true,"isMethod":false,"isOrdinaryClass":false,"type":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}},"isStatic":true,"constantValue":"1"},{"name":"ROUND_CEILING","comment":"Rounding mode to round towards positive infinity.  If the\n {@code BigDecimal} is positive, behaves as for\n {@code ROUND_UP}; if negative, behaves as for\n {@code ROUND_DOWN}.  Note that this rounding mode never\n decreases the calculated value.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":true,"isMethod":false,"isOrdinaryClass":false,"type":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}},"isStatic":true,"constantValue":"2"},{"name":"ROUND_FLOOR","comment":"Rounding mode to round towards negative infinity.  If the\n {@code BigDecimal} is positive, behave as for\n {@code ROUND_DOWN}; if negative, behave as for\n {@code ROUND_UP}.  Note that this rounding mode never\n increases the calculated value.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":true,"isMethod":false,"isOrdinaryClass":false,"type":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}},"isStatic":true,"constantValue":"3"},{"name":"ROUND_HALF_UP","comment":"Rounding mode to round towards {@literal \"nearest neighbor\"}\n unless both neighbors are equidistant, in which case round up.\n Behaves as for {@code ROUND_UP} if the discarded fraction is\n \u0026ge; 0.5; otherwise, behaves as for {@code ROUND_DOWN}.  Note\n that this is the rounding mode that most of us were taught in\n grade school.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":true,"isMethod":false,"isOrdinaryClass":false,"type":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}},"isStatic":true,"constantValue":"4"},{"name":"ROUND_HALF_DOWN","comment":"Rounding mode to round towards {@literal \"nearest neighbor\"}\n unless both neighbors are equidistant, in which case round\n down.  Behaves as for {@code ROUND_UP} if the discarded\n fraction is {@literal \u003e} 0.5; otherwise, behaves as for\n {@code ROUND_DOWN}.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":true,"isMethod":false,"isOrdinaryClass":false,"type":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}},"isStatic":true,"constantValue":"5"},{"name":"ROUND_HALF_EVEN","comment":"Rounding mode to round towards the {@literal \"nearest neighbor\"}\n unless both neighbors are equidistant, in which case, round\n towards the even neighbor.  Behaves as for\n {@code ROUND_HALF_UP} if the digit to the left of the\n discarded fraction is odd; behaves as for\n {@code ROUND_HALF_DOWN} if it\u0027s even.  Note that this is the\n rounding mode that minimizes cumulative error when applied\n repeatedly over a sequence of calculations.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":true,"isMethod":false,"isOrdinaryClass":false,"type":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}},"isStatic":true,"constantValue":"6"},{"name":"ROUND_UNNECESSARY","comment":"Rounding mode to assert that the requested operation has an exact\n result, hence no rounding is necessary.  If this rounding mode is\n specified on an operation that yields an inexact result, an\n {@code ArithmeticException} is thrown.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":true,"isMethod":false,"isOrdinaryClass":false,"type":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}},"isStatic":true,"constantValue":"7"}],"methods":[{"name":"valueOf","comment":"Translates a {@code long} unscaled value and an\n {@code int} scale into a {@code BigDecimal}.  This\n {@literal \"static factory method\"} is provided in preference to\n a ({@code long}, {@code int}) constructor because it\n allows for reuse of frequently used {@code BigDecimal} values..","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(long, int)","flatSignature":"(long, int)","returnType":{"isPrimitive":false,"simpleName":"BigDecimal","qualifiedName":"java.math.BigDecimal","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"unscaledVal","type":{"isPrimitive":true,"simpleName":"long","qualifiedName":"long","dimension":"","elementType":{}}},{"name":"scale","type":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"valueOf","comment":"Translates a {@code long} value into a {@code BigDecimal}\n with a scale of zero.  This {@literal \"static factory method\"}\n is provided in preference to a ({@code long}) constructor\n because it allows for reuse of frequently used\n {@code BigDecimal} values.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(long)","flatSignature":"(long)","returnType":{"isPrimitive":false,"simpleName":"BigDecimal","qualifiedName":"java.math.BigDecimal","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"val","type":{"isPrimitive":true,"simpleName":"long","qualifiedName":"long","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"valueOf","comment":"Translates a {@code double} into a {@code BigDecimal}, using\n the {@code double}\u0027s canonical string representation provided\n by the {@link Double#toString(double)} method.\n\n \u003cp\u003e\u003cb\u003eNote:\u003c/b\u003e This is generally the preferred way to convert\n a {@code double} (or {@code float}) into a\n {@code BigDecimal}, as the value returned is equal to that\n resulting from constructing a {@code BigDecimal} from the\n result of using {@link Double#toString(double)}.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(double)","flatSignature":"(double)","returnType":{"isPrimitive":false,"simpleName":"BigDecimal","qualifiedName":"java.math.BigDecimal","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"val","type":{"isPrimitive":true,"simpleName":"double","qualifiedName":"double","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"add","comment":"Returns a {@code BigDecimal} whose value is {@code (this +\n augend)}, and whose scale is {@code max(this.scale(),\n augend.scale())}.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.math.BigDecimal)","flatSignature":"(BigDecimal)","returnType":{"isPrimitive":false,"simpleName":"BigDecimal","qualifiedName":"java.math.BigDecimal","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[{"name":"augend","type":{"isPrimitive":false,"simpleName":"BigDecimal","qualifiedName":"java.math.BigDecimal","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"add","comment":"Returns a {@code BigDecimal} whose value is {@code (this + augend)},\n with rounding according to the context settings.\n\n If either number is zero and the precision setting is nonzero then\n the other number, rounded if necessary, is used as the result.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.math.BigDecimal, java.math.MathContext)","flatSignature":"(BigDecimal, MathContext)","returnType":{"isPrimitive":false,"simpleName":"BigDecimal","qualifiedName":"java.math.BigDecimal","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[{"name":"augend","type":{"isPrimitive":false,"simpleName":"BigDecimal","qualifiedName":"java.math.BigDecimal","dimension":"","elementType":{}}},{"name":"mc","type":{"isPrimitive":false,"simpleName":"MathContext","qualifiedName":"java.math.MathContext","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"subtract","comment":"Returns a {@code BigDecimal} whose value is {@code (this -\n subtrahend)}, and whose scale is {@code max(this.scale(),\n subtrahend.scale())}.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.math.BigDecimal)","flatSignature":"(BigDecimal)","returnType":{"isPrimitive":false,"simpleName":"BigDecimal","qualifiedName":"java.math.BigDecimal","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[{"name":"subtrahend","type":{"isPrimitive":false,"simpleName":"BigDecimal","qualifiedName":"java.math.BigDecimal","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"subtract","comment":"Returns a {@code BigDecimal} whose value is {@code (this - subtrahend)},\n with rounding according to the context settings.\n\n If {@code subtrahend} is zero then this, rounded if necessary, is used as the\n result.  If this is zero then the result is {@code subtrahend.negate(mc)}.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.math.BigDecimal, java.math.MathContext)","flatSignature":"(BigDecimal, MathContext)","returnType":{"isPrimitive":false,"simpleName":"BigDecimal","qualifiedName":"java.math.BigDecimal","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[{"name":"subtrahend","type":{"isPrimitive":false,"simpleName":"BigDecimal","qualifiedName":"java.math.BigDecimal","dimension":"","elementType":{}}},{"name":"mc","type":{"isPrimitive":false,"simpleName":"MathContext","qualifiedName":"java.math.MathContext","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"multiply","comment":"Returns a {@code BigDecimal} whose value is \u003ctt\u003e(this \u0026times;\n multiplicand)\u003c/tt\u003e, and whose scale is {@code (this.scale() +\n multiplicand.scale())}.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.math.BigDecimal)","flatSignature":"(BigDecimal)","returnType":{"isPrimitive":false,"simpleName":"BigDecimal","qualifiedName":"java.math.BigDecimal","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[{"name":"multiplicand","type":{"isPrimitive":false,"simpleName":"BigDecimal","qualifiedName":"java.math.BigDecimal","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"multiply","comment":"Returns a {@code BigDecimal} whose value is \u003ctt\u003e(this \u0026times;\n multiplicand)\u003c/tt\u003e, with rounding according to the context settings.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.math.BigDecimal, java.math.MathContext)","flatSignature":"(BigDecimal, MathContext)","returnType":{"isPrimitive":false,"simpleName":"BigDecimal","qualifiedName":"java.math.BigDecimal","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[{"name":"multiplicand","type":{"isPrimitive":false,"simpleName":"BigDecimal","qualifiedName":"java.math.BigDecimal","dimension":"","elementType":{}}},{"name":"mc","type":{"isPrimitive":false,"simpleName":"MathContext","qualifiedName":"java.math.MathContext","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"divide","comment":"Returns a {@code BigDecimal} whose value is {@code (this /\n divisor)}, and whose scale is as specified.  If rounding must\n be performed to generate a result with the specified scale, the\n specified rounding mode is applied.\n\n \u003cp\u003eThe new {@link #divide(BigDecimal, int, RoundingMode)} method\n should be used in preference to this legacy method.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.math.BigDecimal, int, int)","flatSignature":"(BigDecimal, int, int)","returnType":{"isPrimitive":false,"simpleName":"BigDecimal","qualifiedName":"java.math.BigDecimal","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[{"name":"divisor","type":{"isPrimitive":false,"simpleName":"BigDecimal","qualifiedName":"java.math.BigDecimal","dimension":"","elementType":{}}},{"name":"scale","type":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}}},{"name":"roundingMode","type":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"divide","comment":"Returns a {@code BigDecimal} whose value is {@code (this /\n divisor)}, and whose scale is as specified.  If rounding must\n be performed to generate a result with the specified scale, the\n specified rounding mode is applied.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.math.BigDecimal, int, java.math.RoundingMode)","flatSignature":"(BigDecimal, int, RoundingMode)","returnType":{"isPrimitive":false,"simpleName":"BigDecimal","qualifiedName":"java.math.BigDecimal","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[{"name":"divisor","type":{"isPrimitive":false,"simpleName":"BigDecimal","qualifiedName":"java.math.BigDecimal","dimension":"","elementType":{}}},{"name":"scale","type":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}}},{"name":"roundingMode","type":{"isPrimitive":false,"simpleName":"RoundingMode","qualifiedName":"java.math.RoundingMode","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"divide","comment":"Returns a {@code BigDecimal} whose value is {@code (this /\n divisor)}, and whose scale is {@code this.scale()}.  If\n rounding must be performed to generate a result with the given\n scale, the specified rounding mode is applied.\n\n \u003cp\u003eThe new {@link #divide(BigDecimal, RoundingMode)} method\n should be used in preference to this legacy method.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.math.BigDecimal, int)","flatSignature":"(BigDecimal, int)","returnType":{"isPrimitive":false,"simpleName":"BigDecimal","qualifiedName":"java.math.BigDecimal","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[{"name":"divisor","type":{"isPrimitive":false,"simpleName":"BigDecimal","qualifiedName":"java.math.BigDecimal","dimension":"","elementType":{}}},{"name":"roundingMode","type":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"divide","comment":"Returns a {@code BigDecimal} whose value is {@code (this /\n divisor)}, and whose scale is {@code this.scale()}.  If\n rounding must be performed to generate a result with the given\n scale, the specified rounding mode is applied.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.math.BigDecimal, java.math.RoundingMode)","flatSignature":"(BigDecimal, RoundingMode)","returnType":{"isPrimitive":false,"simpleName":"BigDecimal","qualifiedName":"java.math.BigDecimal","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[{"name":"divisor","type":{"isPrimitive":false,"simpleName":"BigDecimal","qualifiedName":"java.math.BigDecimal","dimension":"","elementType":{}}},{"name":"roundingMode","type":{"isPrimitive":false,"simpleName":"RoundingMode","qualifiedName":"java.math.RoundingMode","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"divide","comment":"Returns a {@code BigDecimal} whose value is {@code (this /\n divisor)}, and whose preferred scale is {@code (this.scale() -\n divisor.scale())}; if the exact quotient cannot be\n represented (because it has a non-terminating decimal\n expansion) an {@code ArithmeticException} is thrown.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.math.BigDecimal)","flatSignature":"(BigDecimal)","returnType":{"isPrimitive":false,"simpleName":"BigDecimal","qualifiedName":"java.math.BigDecimal","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[{"name":"divisor","type":{"isPrimitive":false,"simpleName":"BigDecimal","qualifiedName":"java.math.BigDecimal","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"divide","comment":"Returns a {@code BigDecimal} whose value is {@code (this /\n divisor)}, with rounding according to the context settings.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.math.BigDecimal, java.math.MathContext)","flatSignature":"(BigDecimal, MathContext)","returnType":{"isPrimitive":false,"simpleName":"BigDecimal","qualifiedName":"java.math.BigDecimal","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[{"name":"divisor","type":{"isPrimitive":false,"simpleName":"BigDecimal","qualifiedName":"java.math.BigDecimal","dimension":"","elementType":{}}},{"name":"mc","type":{"isPrimitive":false,"simpleName":"MathContext","qualifiedName":"java.math.MathContext","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"divideToIntegralValue","comment":"Returns a {@code BigDecimal} whose value is the integer part\n of the quotient {@code (this / divisor)} rounded down.  The\n preferred scale of the result is {@code (this.scale() -\n divisor.scale())}.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.math.BigDecimal)","flatSignature":"(BigDecimal)","returnType":{"isPrimitive":false,"simpleName":"BigDecimal","qualifiedName":"java.math.BigDecimal","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[{"name":"divisor","type":{"isPrimitive":false,"simpleName":"BigDecimal","qualifiedName":"java.math.BigDecimal","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"divideToIntegralValue","comment":"Returns a {@code BigDecimal} whose value is the integer part\n of {@code (this / divisor)}.  Since the integer part of the\n exact quotient does not depend on the rounding mode, the\n rounding mode does not affect the values returned by this\n method.  The preferred scale of the result is\n {@code (this.scale() - divisor.scale())}.  An\n {@code ArithmeticException} is thrown if the integer part of\n the exact quotient needs more than {@code mc.precision}\n digits.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.math.BigDecimal, java.math.MathContext)","flatSignature":"(BigDecimal, MathContext)","returnType":{"isPrimitive":false,"simpleName":"BigDecimal","qualifiedName":"java.math.BigDecimal","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[{"name":"divisor","type":{"isPrimitive":false,"simpleName":"BigDecimal","qualifiedName":"java.math.BigDecimal","dimension":"","elementType":{}}},{"name":"mc","type":{"isPrimitive":false,"simpleName":"MathContext","qualifiedName":"java.math.MathContext","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"remainder","comment":"Returns a {@code BigDecimal} whose value is {@code (this % divisor)}.\n\n \u003cp\u003eThe remainder is given by\n {@code this.subtract(this.divideToIntegralValue(divisor).multiply(divisor))}.\n Note that this is not the modulo operation (the result can be\n negative).","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.math.BigDecimal)","flatSignature":"(BigDecimal)","returnType":{"isPrimitive":false,"simpleName":"BigDecimal","qualifiedName":"java.math.BigDecimal","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[{"name":"divisor","type":{"isPrimitive":false,"simpleName":"BigDecimal","qualifiedName":"java.math.BigDecimal","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"remainder","comment":"Returns a {@code BigDecimal} whose value is {@code (this %\n divisor)}, with rounding according to the context settings.\n The {@code MathContext} settings affect the implicit divide\n used to compute the remainder.  The remainder computation\n itself is by definition exact.  Therefore, the remainder may\n contain more than {@code mc.getPrecision()} digits.\n\n \u003cp\u003eThe remainder is given by\n {@code this.subtract(this.divideToIntegralValue(divisor,\n mc).multiply(divisor))}.  Note that this is not the modulo\n operation (the result can be negative).","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.math.BigDecimal, java.math.MathContext)","flatSignature":"(BigDecimal, MathContext)","returnType":{"isPrimitive":false,"simpleName":"BigDecimal","qualifiedName":"java.math.BigDecimal","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[{"name":"divisor","type":{"isPrimitive":false,"simpleName":"BigDecimal","qualifiedName":"java.math.BigDecimal","dimension":"","elementType":{}}},{"name":"mc","type":{"isPrimitive":false,"simpleName":"MathContext","qualifiedName":"java.math.MathContext","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"divideAndRemainder","comment":"Returns a two-element {@code BigDecimal} array containing the\n result of {@code divideToIntegralValue} followed by the result of\n {@code remainder} on the two operands.\n\n \u003cp\u003eNote that if both the integer quotient and remainder are\n needed, this method is faster than using the\n {@code divideToIntegralValue} and {@code remainder} methods\n separately because the division need only be carried out once.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.math.BigDecimal)","flatSignature":"(BigDecimal)","returnType":{"isPrimitive":false,"simpleName":"BigDecimal","qualifiedName":"java.math.BigDecimal","dimension":"[]","elementType":{"isPrimitive":false,"simpleName":"BigDecimal","qualifiedName":"java.math.BigDecimal","dimension":"","elementType":{}}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[{"name":"divisor","type":{"isPrimitive":false,"simpleName":"BigDecimal","qualifiedName":"java.math.BigDecimal","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"divideAndRemainder","comment":"Returns a two-element {@code BigDecimal} array containing the\n result of {@code divideToIntegralValue} followed by the result of\n {@code remainder} on the two operands calculated with rounding\n according to the context settings.\n\n \u003cp\u003eNote that if both the integer quotient and remainder are\n needed, this method is faster than using the\n {@code divideToIntegralValue} and {@code remainder} methods\n separately because the division need only be carried out once.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.math.BigDecimal, java.math.MathContext)","flatSignature":"(BigDecimal, MathContext)","returnType":{"isPrimitive":false,"simpleName":"BigDecimal","qualifiedName":"java.math.BigDecimal","dimension":"[]","elementType":{"isPrimitive":false,"simpleName":"BigDecimal","qualifiedName":"java.math.BigDecimal","dimension":"","elementType":{}}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[{"name":"divisor","type":{"isPrimitive":false,"simpleName":"BigDecimal","qualifiedName":"java.math.BigDecimal","dimension":"","elementType":{}}},{"name":"mc","type":{"isPrimitive":false,"simpleName":"MathContext","qualifiedName":"java.math.MathContext","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"pow","comment":"Returns a {@code BigDecimal} whose value is\n \u003ctt\u003e(this\u003csup\u003en\u003c/sup\u003e)\u003c/tt\u003e, The power is computed exactly, to\n unlimited precision.\n\n \u003cp\u003eThe parameter {@code n} must be in the range 0 through\n 999999999, inclusive.  {@code ZERO.pow(0)} returns {@link\n #ONE}.\n\n Note that future releases may expand the allowable exponent\n range of this method.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(int)","flatSignature":"(int)","returnType":{"isPrimitive":false,"simpleName":"BigDecimal","qualifiedName":"java.math.BigDecimal","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[{"name":"n","type":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"pow","comment":"Returns a {@code BigDecimal} whose value is\n \u003ctt\u003e(this\u003csup\u003en\u003c/sup\u003e)\u003c/tt\u003e.  The current implementation uses\n the core algorithm defined in ANSI standard X3.274-1996 with\n rounding according to the context settings.  In general, the\n returned numerical value is within two ulps of the exact\n numerical value for the chosen precision.  Note that future\n releases may use a different algorithm with a decreased\n allowable error bound and increased allowable exponent range.\n\n \u003cp\u003eThe X3.274-1996 algorithm is:\n\n \u003cul\u003e\n \u003cli\u003e An {@code ArithmeticException} exception is thrown if\n  \u003cul\u003e\n    \u003cli\u003e{@code abs(n) \u003e 999999999}\n    \u003cli\u003e{@code mc.precision \u003d\u003d 0} and {@code n \u003c 0}\n    \u003cli\u003e{@code mc.precision \u003e 0} and {@code n} has more than\n    {@code mc.precision} decimal digits\n  \u003c/ul\u003e\n\n \u003cli\u003e if {@code n} is zero, {@link #ONE} is returned even if\n {@code this} is zero, otherwise\n \u003cul\u003e\n   \u003cli\u003e if {@code n} is positive, the result is calculated via\n   the repeated squaring technique into a single accumulator.\n   The individual multiplications with the accumulator use the\n   same math context settings as in {@code mc} except for a\n   precision increased to {@code mc.precision + elength + 1}\n   where {@code elength} is the number of decimal digits in\n   {@code n}.\n\n   \u003cli\u003e if {@code n} is negative, the result is calculated as if\n   {@code n} were positive; this value is then divided into one\n   using the working precision specified above.\n\n   \u003cli\u003e The final value from either the positive or negative case\n   is then rounded to the destination precision.\n   \u003c/ul\u003e\n \u003c/ul\u003e","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(int, java.math.MathContext)","flatSignature":"(int, MathContext)","returnType":{"isPrimitive":false,"simpleName":"BigDecimal","qualifiedName":"java.math.BigDecimal","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[{"name":"n","type":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}}},{"name":"mc","type":{"isPrimitive":false,"simpleName":"MathContext","qualifiedName":"java.math.MathContext","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"abs","comment":"Returns a {@code BigDecimal} whose value is the absolute value\n of this {@code BigDecimal}, and whose scale is\n {@code this.scale()}.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":false,"simpleName":"BigDecimal","qualifiedName":"java.math.BigDecimal","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[],"typeParameters":[]},{"name":"abs","comment":"Returns a {@code BigDecimal} whose value is the absolute value\n of this {@code BigDecimal}, with rounding according to the\n context settings.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.math.MathContext)","flatSignature":"(MathContext)","returnType":{"isPrimitive":false,"simpleName":"BigDecimal","qualifiedName":"java.math.BigDecimal","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[{"name":"mc","type":{"isPrimitive":false,"simpleName":"MathContext","qualifiedName":"java.math.MathContext","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"negate","comment":"Returns a {@code BigDecimal} whose value is {@code (-this)},\n and whose scale is {@code this.scale()}.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":false,"simpleName":"BigDecimal","qualifiedName":"java.math.BigDecimal","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[],"typeParameters":[]},{"name":"negate","comment":"Returns a {@code BigDecimal} whose value is {@code (-this)},\n with rounding according to the context settings.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.math.MathContext)","flatSignature":"(MathContext)","returnType":{"isPrimitive":false,"simpleName":"BigDecimal","qualifiedName":"java.math.BigDecimal","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[{"name":"mc","type":{"isPrimitive":false,"simpleName":"MathContext","qualifiedName":"java.math.MathContext","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"plus","comment":"Returns a {@code BigDecimal} whose value is {@code (+this)}, and whose\n scale is {@code this.scale()}.\n\n \u003cp\u003eThis method, which simply returns this {@code BigDecimal}\n is included for symmetry with the unary minus method {@link\n #negate()}.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":false,"simpleName":"BigDecimal","qualifiedName":"java.math.BigDecimal","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[],"typeParameters":[]},{"name":"plus","comment":"Returns a {@code BigDecimal} whose value is {@code (+this)},\n with rounding according to the context settings.\n\n \u003cp\u003eThe effect of this method is identical to that of the {@link\n #round(MathContext)} method.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.math.MathContext)","flatSignature":"(MathContext)","returnType":{"isPrimitive":false,"simpleName":"BigDecimal","qualifiedName":"java.math.BigDecimal","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[{"name":"mc","type":{"isPrimitive":false,"simpleName":"MathContext","qualifiedName":"java.math.MathContext","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"signum","comment":"Returns the signum function of this {@code BigDecimal}.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[],"typeParameters":[]},{"name":"scale","comment":"Returns the \u003ci\u003escale\u003c/i\u003e of this {@code BigDecimal}.  If zero\n or positive, the scale is the number of digits to the right of\n the decimal point.  If negative, the unscaled value of the\n number is multiplied by ten to the power of the negation of the\n scale.  For example, a scale of {@code -3} means the unscaled\n value is multiplied by 1000.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[],"typeParameters":[]},{"name":"precision","comment":"Returns the \u003ci\u003eprecision\u003c/i\u003e of this {@code BigDecimal}.  (The\n precision is the number of digits in the unscaled value.)\n\n \u003cp\u003eThe precision of a zero value is 1.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[],"typeParameters":[]},{"name":"unscaledValue","comment":"Returns a {@code BigInteger} whose value is the \u003ci\u003eunscaled\n value\u003c/i\u003e of this {@code BigDecimal}.  (Computes \u003ctt\u003e(this *\n 10\u003csup\u003ethis.scale()\u003c/sup\u003e)\u003c/tt\u003e.)","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":false,"simpleName":"BigInteger","qualifiedName":"java.math.BigInteger","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[],"typeParameters":[]},{"name":"round","comment":"Returns a {@code BigDecimal} rounded according to the\n {@code MathContext} settings.  If the precision setting is 0 then\n no rounding takes place.\n\n \u003cp\u003eThe effect of this method is identical to that of the\n {@link #plus(MathContext)} method.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.math.MathContext)","flatSignature":"(MathContext)","returnType":{"isPrimitive":false,"simpleName":"BigDecimal","qualifiedName":"java.math.BigDecimal","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[{"name":"mc","type":{"isPrimitive":false,"simpleName":"MathContext","qualifiedName":"java.math.MathContext","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"setScale","comment":"Returns a {@code BigDecimal} whose scale is the specified\n value, and whose unscaled value is determined by multiplying or\n dividing this {@code BigDecimal}\u0027s unscaled value by the\n appropriate power of ten to maintain its overall value.  If the\n scale is reduced by the operation, the unscaled value must be\n divided (rather than multiplied), and the value may be changed;\n in this case, the specified rounding mode is applied to the\n division.\n\n \u003cp\u003eNote that since BigDecimal objects are immutable, calls of\n this method do \u003ci\u003enot\u003c/i\u003e result in the original object being\n modified, contrary to the usual convention of having methods\n named \u003ctt\u003eset\u003ci\u003eX\u003c/i\u003e\u003c/tt\u003e mutate field \u003ci\u003e{@code X}\u003c/i\u003e.\n Instead, {@code setScale} returns an object with the proper\n scale; the returned object may or may not be newly allocated.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(int, java.math.RoundingMode)","flatSignature":"(int, RoundingMode)","returnType":{"isPrimitive":false,"simpleName":"BigDecimal","qualifiedName":"java.math.BigDecimal","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[{"name":"newScale","type":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}}},{"name":"roundingMode","type":{"isPrimitive":false,"simpleName":"RoundingMode","qualifiedName":"java.math.RoundingMode","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"setScale","comment":"Returns a {@code BigDecimal} whose scale is the specified\n value, and whose unscaled value is determined by multiplying or\n dividing this {@code BigDecimal}\u0027s unscaled value by the\n appropriate power of ten to maintain its overall value.  If the\n scale is reduced by the operation, the unscaled value must be\n divided (rather than multiplied), and the value may be changed;\n in this case, the specified rounding mode is applied to the\n division.\n\n \u003cp\u003eNote that since BigDecimal objects are immutable, calls of\n this method do \u003ci\u003enot\u003c/i\u003e result in the original object being\n modified, contrary to the usual convention of having methods\n named \u003ctt\u003eset\u003ci\u003eX\u003c/i\u003e\u003c/tt\u003e mutate field \u003ci\u003e{@code X}\u003c/i\u003e.\n Instead, {@code setScale} returns an object with the proper\n scale; the returned object may or may not be newly allocated.\n\n \u003cp\u003eThe new {@link #setScale(int, RoundingMode)} method should\n be used in preference to this legacy method.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(int, int)","flatSignature":"(int, int)","returnType":{"isPrimitive":false,"simpleName":"BigDecimal","qualifiedName":"java.math.BigDecimal","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[{"name":"newScale","type":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}}},{"name":"roundingMode","type":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"setScale","comment":"Returns a {@code BigDecimal} whose scale is the specified\n value, and whose value is numerically equal to this\n {@code BigDecimal}\u0027s.  Throws an {@code ArithmeticException}\n if this is not possible.\n\n \u003cp\u003eThis call is typically used to increase the scale, in which\n case it is guaranteed that there exists a {@code BigDecimal}\n of the specified scale and the correct value.  The call can\n also be used to reduce the scale if the caller knows that the\n {@code BigDecimal} has sufficiently many zeros at the end of\n its fractional part (i.e., factors of ten in its integer value)\n to allow for the rescaling without changing its value.\n\n \u003cp\u003eThis method returns the same result as the two-argument\n versions of {@code setScale}, but saves the caller the trouble\n of specifying a rounding mode in cases where it is irrelevant.\n\n \u003cp\u003eNote that since {@code BigDecimal} objects are immutable,\n calls of this method do \u003ci\u003enot\u003c/i\u003e result in the original\n object being modified, contrary to the usual convention of\n having methods named \u003ctt\u003eset\u003ci\u003eX\u003c/i\u003e\u003c/tt\u003e mutate field\n \u003ci\u003e{@code X}\u003c/i\u003e.  Instead, {@code setScale} returns an\n object with the proper scale; the returned object may or may\n not be newly allocated.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(int)","flatSignature":"(int)","returnType":{"isPrimitive":false,"simpleName":"BigDecimal","qualifiedName":"java.math.BigDecimal","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[{"name":"newScale","type":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"movePointLeft","comment":"Returns a {@code BigDecimal} which is equivalent to this one\n with the decimal point moved {@code n} places to the left.  If\n {@code n} is non-negative, the call merely adds {@code n} to\n the scale.  If {@code n} is negative, the call is equivalent\n to {@code movePointRight(-n)}.  The {@code BigDecimal}\n returned by this call has value \u003ctt\u003e(this \u0026times;\n 10\u003csup\u003e-n\u003c/sup\u003e)\u003c/tt\u003e and scale {@code max(this.scale()+n,\n 0)}.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(int)","flatSignature":"(int)","returnType":{"isPrimitive":false,"simpleName":"BigDecimal","qualifiedName":"java.math.BigDecimal","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[{"name":"n","type":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"movePointRight","comment":"Returns a {@code BigDecimal} which is equivalent to this one\n with the decimal point moved {@code n} places to the right.\n If {@code n} is non-negative, the call merely subtracts\n {@code n} from the scale.  If {@code n} is negative, the call\n is equivalent to {@code movePointLeft(-n)}.  The\n {@code BigDecimal} returned by this call has value \u003ctt\u003e(this\n \u0026times; 10\u003csup\u003en\u003c/sup\u003e)\u003c/tt\u003e and scale {@code max(this.scale()-n,\n 0)}.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(int)","flatSignature":"(int)","returnType":{"isPrimitive":false,"simpleName":"BigDecimal","qualifiedName":"java.math.BigDecimal","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[{"name":"n","type":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"scaleByPowerOfTen","comment":"Returns a BigDecimal whose numerical value is equal to\n ({@code this} * 10\u003csup\u003en\u003c/sup\u003e).  The scale of\n the result is {@code (this.scale() - n)}.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(int)","flatSignature":"(int)","returnType":{"isPrimitive":false,"simpleName":"BigDecimal","qualifiedName":"java.math.BigDecimal","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[{"name":"n","type":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"stripTrailingZeros","comment":"Returns a {@code BigDecimal} which is numerically equal to\n this one but with any trailing zeros removed from the\n representation.  For example, stripping the trailing zeros from\n the {@code BigDecimal} value {@code 600.0}, which has\n [{@code BigInteger}, {@code scale}] components equals to\n [6000, 1], yields {@code 6E2} with [{@code BigInteger},\n {@code scale}] components equals to [6, -2].  If\n this BigDecimal is numerically equal to zero, then\n {@code BigDecimal.ZERO} is returned.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":false,"simpleName":"BigDecimal","qualifiedName":"java.math.BigDecimal","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[],"typeParameters":[]},{"name":"compareTo","comment":"Compares this {@code BigDecimal} with the specified\n {@code BigDecimal}.  Two {@code BigDecimal} objects that are\n equal in value but have a different scale (like 2.0 and 2.00)\n are considered equal by this method.  This method is provided\n in preference to individual methods for each of the six boolean\n comparison operators ({@literal \u003c}, \u003d\u003d,\n {@literal \u003e}, {@literal \u003e\u003d}, !\u003d, {@literal \u003c\u003d}).  The\n suggested idiom for performing these comparisons is:\n {@code (x.compareTo(y)} \u0026lt;\u003ci\u003eop\u003c/i\u003e\u0026gt; {@code 0)}, where\n \u0026lt;\u003ci\u003eop\u003c/i\u003e\u0026gt; is one of the six comparison operators.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.math.BigDecimal)","flatSignature":"(BigDecimal)","returnType":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[{"name":"val","type":{"isPrimitive":false,"simpleName":"BigDecimal","qualifiedName":"java.math.BigDecimal","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"equals","comment":"Compares this {@code BigDecimal} with the specified\n {@code Object} for equality.  Unlike {@link\n #compareTo(BigDecimal) compareTo}, this method considers two\n {@code BigDecimal} objects equal only if they are equal in\n value and scale (thus 2.0 is not equal to 2.00 when compared by\n this method).","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.lang.Object)","flatSignature":"(Object)","returnType":{"isPrimitive":true,"simpleName":"boolean","qualifiedName":"boolean","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[{"name":"x","type":{"isPrimitive":false,"simpleName":"Object","qualifiedName":"java.lang.Object","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"min","comment":"Returns the minimum of this {@code BigDecimal} and\n {@code val}.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.math.BigDecimal)","flatSignature":"(BigDecimal)","returnType":{"isPrimitive":false,"simpleName":"BigDecimal","qualifiedName":"java.math.BigDecimal","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[{"name":"val","type":{"isPrimitive":false,"simpleName":"BigDecimal","qualifiedName":"java.math.BigDecimal","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"max","comment":"Returns the maximum of this {@code BigDecimal} and {@code val}.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.math.BigDecimal)","flatSignature":"(BigDecimal)","returnType":{"isPrimitive":false,"simpleName":"BigDecimal","qualifiedName":"java.math.BigDecimal","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[{"name":"val","type":{"isPrimitive":false,"simpleName":"BigDecimal","qualifiedName":"java.math.BigDecimal","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"hashCode","comment":"Returns the hash code for this {@code BigDecimal}.  Note that\n two {@code BigDecimal} objects that are numerically equal but\n differ in scale (like 2.0 and 2.00) will generally \u003ci\u003enot\u003c/i\u003e\n have the same hash code.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[],"typeParameters":[]},{"name":"toString","comment":"Returns the string representation of this {@code BigDecimal},\n using scientific notation if an exponent is needed.\n\n \u003cp\u003eA standard canonical string form of the {@code BigDecimal}\n is created as though by the following steps: first, the\n absolute value of the unscaled value of the {@code BigDecimal}\n is converted to a string in base ten using the characters\n {@code \u00270\u0027} through {@code \u00279\u0027} with no leading zeros (except\n if its value is zero, in which case a single {@code \u00270\u0027}\n character is used).\n\n \u003cp\u003eNext, an \u003ci\u003eadjusted exponent\u003c/i\u003e is calculated; this is the\n negated scale, plus the number of characters in the converted\n unscaled value, less one.  That is,\n {@code -scale+(ulength-1)}, where {@code ulength} is the\n length of the absolute value of the unscaled value in decimal\n digits (its \u003ci\u003eprecision\u003c/i\u003e).\n\n \u003cp\u003eIf the scale is greater than or equal to zero and the\n adjusted exponent is greater than or equal to {@code -6}, the\n number will be converted to a character form without using\n exponential notation.  In this case, if the scale is zero then\n no decimal point is added and if the scale is positive a\n decimal point will be inserted with the scale specifying the\n number of characters to the right of the decimal point.\n {@code \u00270\u0027} characters are added to the left of the converted\n unscaled value as necessary.  If no character precedes the\n decimal point after this insertion then a conventional\n {@code \u00270\u0027} character is prefixed.\n\n \u003cp\u003eOtherwise (that is, if the scale is negative, or the\n adjusted exponent is less than {@code -6}), the number will be\n converted to a character form using exponential notation.  In\n this case, if the converted {@code BigInteger} has more than\n one digit a decimal point is inserted after the first digit.\n An exponent in character form is then suffixed to the converted\n unscaled value (perhaps with inserted decimal point); this\n comprises the letter {@code \u0027E\u0027} followed immediately by the\n adjusted exponent converted to a character form.  The latter is\n in base ten, using the characters {@code \u00270\u0027} through\n {@code \u00279\u0027} with no leading zeros, and is always prefixed by a\n sign character {@code \u0027-\u0027} (\u003ctt\u003e\u0027\u0026#92;u002D\u0027\u003c/tt\u003e) if the\n adjusted exponent is negative, {@code \u0027+\u0027}\n (\u003ctt\u003e\u0027\u0026#92;u002B\u0027\u003c/tt\u003e) otherwise).\n\n \u003cp\u003eFinally, the entire string is prefixed by a minus sign\n character {@code \u0027-\u0027} (\u003ctt\u003e\u0027\u0026#92;u002D\u0027\u003c/tt\u003e) if the unscaled\n value is less than zero.  No sign character is prefixed if the\n unscaled value is zero or positive.\n\n \u003cp\u003e\u003cb\u003eExamples:\u003c/b\u003e\n \u003cp\u003eFor each representation [\u003ci\u003eunscaled value\u003c/i\u003e, \u003ci\u003escale\u003c/i\u003e]\n on the left, the resulting string is shown on the right.\n \u003cpre\u003e\n [123,0]      \"123\"\n [-123,0]     \"-123\"\n [123,-1]     \"1.23E+3\"\n [123,-3]     \"1.23E+5\"\n [123,1]      \"12.3\"\n [123,5]      \"0.00123\"\n [123,10]     \"1.23E-8\"\n [-123,12]    \"-1.23E-10\"\n \u003c/pre\u003e\n\n \u003cb\u003eNotes:\u003c/b\u003e\n \u003col\u003e\n\n \u003cli\u003eThere is a one-to-one mapping between the distinguishable\n {@code BigDecimal} values and the result of this conversion.\n That is, every distinguishable {@code BigDecimal} value\n (unscaled value and scale) has a unique string representation\n as a result of using {@code toString}.  If that string\n representation is converted back to a {@code BigDecimal} using\n the {@link #BigDecimal(String)} constructor, then the original\n value will be recovered.\n\n \u003cli\u003eThe string produced for a given number is always the same;\n it is not affected by locale.  This means that it can be used\n as a canonical string representation for exchanging decimal\n data, or as a key for a Hashtable, etc.  Locale-sensitive\n number formatting and parsing is handled by the {@link\n java.text.NumberFormat} class and its subclasses.\n\n \u003cli\u003eThe {@link #toEngineeringString} method may be used for\n presenting numbers with exponents in engineering notation, and the\n {@link #setScale(int,RoundingMode) setScale} method may be used for\n rounding a {@code BigDecimal} so it has a known number of digits after\n the decimal point.\n\n \u003cli\u003eThe digit-to-character mapping provided by\n {@code Character.forDigit} is used.\n\n \u003c/ol\u003e","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":false,"simpleName":"String","qualifiedName":"java.lang.String","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[],"typeParameters":[]},{"name":"toEngineeringString","comment":"Returns a string representation of this {@code BigDecimal},\n using engineering notation if an exponent is needed.\n\n \u003cp\u003eReturns a string that represents the {@code BigDecimal} as\n described in the {@link #toString()} method, except that if\n exponential notation is used, the power of ten is adjusted to\n be a multiple of three (engineering notation) such that the\n integer part of nonzero values will be in the range 1 through\n 999.  If exponential notation is used for zero values, a\n decimal point and one or two fractional zero digits are used so\n that the scale of the zero value is preserved.  Note that\n unlike the output of {@link #toString()}, the output of this\n method is \u003cem\u003enot\u003c/em\u003e guaranteed to recover the same [integer,\n scale] pair of this {@code BigDecimal} if the output string is\n converting back to a {@code BigDecimal} using the {@linkplain\n #BigDecimal(String) string constructor}.  The result of this method meets\n the weaker constraint of always producing a numerically equal\n result from applying the string constructor to the method\u0027s output.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":false,"simpleName":"String","qualifiedName":"java.lang.String","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[],"typeParameters":[]},{"name":"toPlainString","comment":"Returns a string representation of this {@code BigDecimal}\n without an exponent field.  For values with a positive scale,\n the number of digits to the right of the decimal point is used\n to indicate scale.  For values with a zero or negative scale,\n the resulting string is generated as if the value were\n converted to a numerically equal value with zero scale and as\n if all the trailing zeros of the zero scale value were present\n in the result.\n\n The entire string is prefixed by a minus sign character \u0027-\u0027\n (\u003ctt\u003e\u0027\u0026#92;u002D\u0027\u003c/tt\u003e) if the unscaled value is less than\n zero. No sign character is prefixed if the unscaled value is\n zero or positive.\n\n Note that if the result of this method is passed to the\n {@linkplain #BigDecimal(String) string constructor}, only the\n numerical value of this {@code BigDecimal} will necessarily be\n recovered; the representation of the new {@code BigDecimal}\n may have a different scale.  In particular, if this\n {@code BigDecimal} has a negative scale, the string resulting\n from this method will have a scale of zero when processed by\n the string constructor.\n\n (This method behaves analogously to the {@code toString}\n method in 1.4 and earlier releases.)","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":false,"simpleName":"String","qualifiedName":"java.lang.String","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[],"typeParameters":[]},{"name":"toBigInteger","comment":"Converts this {@code BigDecimal} to a {@code BigInteger}.\n This conversion is analogous to the\n \u003ci\u003enarrowing primitive conversion\u003c/i\u003e from {@code double} to\n {@code long} as defined in section 5.1.3 of\n \u003ccite\u003eThe Java\u0026trade; Language Specification\u003c/cite\u003e:\n any fractional part of this\n {@code BigDecimal} will be discarded.  Note that this\n conversion can lose information about the precision of the\n {@code BigDecimal} value.\n \u003cp\u003e\n To have an exception thrown if the conversion is inexact (in\n other words if a nonzero fractional part is discarded), use the\n {@link #toBigIntegerExact()} method.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":false,"simpleName":"BigInteger","qualifiedName":"java.math.BigInteger","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[],"typeParameters":[]},{"name":"toBigIntegerExact","comment":"Converts this {@code BigDecimal} to a {@code BigInteger},\n checking for lost information.  An exception is thrown if this\n {@code BigDecimal} has a nonzero fractional part.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":false,"simpleName":"BigInteger","qualifiedName":"java.math.BigInteger","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[],"typeParameters":[]},{"name":"longValue","comment":"Converts this {@code BigDecimal} to a {@code long}.\n This conversion is analogous to the\n \u003ci\u003enarrowing primitive conversion\u003c/i\u003e from {@code double} to\n {@code short} as defined in section 5.1.3 of\n \u003ccite\u003eThe Java\u0026trade; Language Specification\u003c/cite\u003e:\n any fractional part of this\n {@code BigDecimal} will be discarded, and if the resulting\n \"{@code BigInteger}\" is too big to fit in a\n {@code long}, only the low-order 64 bits are returned.\n Note that this conversion can lose information about the\n overall magnitude and precision of this {@code BigDecimal} value as well\n as return a result with the opposite sign.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":true,"simpleName":"long","qualifiedName":"long","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[],"typeParameters":[]},{"name":"longValueExact","comment":"Converts this {@code BigDecimal} to a {@code long}, checking\n for lost information.  If this {@code BigDecimal} has a\n nonzero fractional part or is out of the possible range for a\n {@code long} result then an {@code ArithmeticException} is\n thrown.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":true,"simpleName":"long","qualifiedName":"long","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[],"typeParameters":[]},{"name":"intValue","comment":"Converts this {@code BigDecimal} to an {@code int}.\n This conversion is analogous to the\n \u003ci\u003enarrowing primitive conversion\u003c/i\u003e from {@code double} to\n {@code short} as defined in section 5.1.3 of\n \u003ccite\u003eThe Java\u0026trade; Language Specification\u003c/cite\u003e:\n any fractional part of this\n {@code BigDecimal} will be discarded, and if the resulting\n \"{@code BigInteger}\" is too big to fit in an\n {@code int}, only the low-order 32 bits are returned.\n Note that this conversion can lose information about the\n overall magnitude and precision of this {@code BigDecimal}\n value as well as return a result with the opposite sign.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[],"typeParameters":[]},{"name":"intValueExact","comment":"Converts this {@code BigDecimal} to an {@code int}, checking\n for lost information.  If this {@code BigDecimal} has a\n nonzero fractional part or is out of the possible range for an\n {@code int} result then an {@code ArithmeticException} is\n thrown.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[],"typeParameters":[]},{"name":"shortValueExact","comment":"Converts this {@code BigDecimal} to a {@code short}, checking\n for lost information.  If this {@code BigDecimal} has a\n nonzero fractional part or is out of the possible range for a\n {@code short} result then an {@code ArithmeticException} is\n thrown.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":true,"simpleName":"short","qualifiedName":"short","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[],"typeParameters":[]},{"name":"byteValueExact","comment":"Converts this {@code BigDecimal} to a {@code byte}, checking\n for lost information.  If this {@code BigDecimal} has a\n nonzero fractional part or is out of the possible range for a\n {@code byte} result then an {@code ArithmeticException} is\n thrown.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":true,"simpleName":"byte","qualifiedName":"byte","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[],"typeParameters":[]},{"name":"floatValue","comment":"Converts this {@code BigDecimal} to a {@code float}.\n This conversion is similar to the\n \u003ci\u003enarrowing primitive conversion\u003c/i\u003e from {@code double} to\n {@code float} as defined in section 5.1.3 of\n \u003ccite\u003eThe Java\u0026trade; Language Specification\u003c/cite\u003e:\n if this {@code BigDecimal} has too great a\n magnitude to represent as a {@code float}, it will be\n converted to {@link Float#NEGATIVE_INFINITY} or {@link\n Float#POSITIVE_INFINITY} as appropriate.  Note that even when\n the return value is finite, this conversion can lose\n information about the precision of the {@code BigDecimal}\n value.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":true,"simpleName":"float","qualifiedName":"float","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[],"typeParameters":[]},{"name":"doubleValue","comment":"Converts this {@code BigDecimal} to a {@code double}.\n This conversion is similar to the\n \u003ci\u003enarrowing primitive conversion\u003c/i\u003e from {@code double} to\n {@code float} as defined in section 5.1.3 of\n \u003ccite\u003eThe Java\u0026trade; Language Specification\u003c/cite\u003e:\n if this {@code BigDecimal} has too great a\n magnitude represent as a {@code double}, it will be\n converted to {@link Double#NEGATIVE_INFINITY} or {@link\n Double#POSITIVE_INFINITY} as appropriate.  Note that even when\n the return value is finite, this conversion can lose\n information about the precision of the {@code BigDecimal}\n value.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":true,"simpleName":"double","qualifiedName":"double","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[],"typeParameters":[]},{"name":"ulp","comment":"Returns the size of an ulp, a unit in the last place, of this\n {@code BigDecimal}.  An ulp of a nonzero {@code BigDecimal}\n value is the positive distance between this value and the\n {@code BigDecimal} value next larger in magnitude with the\n same number of digits.  An ulp of a zero value is numerically\n equal to 1 with the scale of {@code this}.  The result is\n stored with the same scale as {@code this} so the result\n for zero and nonzero values is equal to {@code [1,\n this.scale()]}.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":false,"simpleName":"BigDecimal","qualifiedName":"java.math.BigDecimal","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[],"typeParameters":[]}],"typeParameters":[],"enumConstants":[]}