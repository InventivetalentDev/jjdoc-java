{"name":"Float","comment":"The {@code Float} class wraps a value of primitive type\n {@code float} in an object. An object of type\n {@code Float} contains a single field whose type is\n {@code float}.\n\n \u003cp\u003eIn addition, this class provides several methods for converting a\n {@code float} to a {@code String} and a\n {@code String} to a {@code float}, as well as other\n constants and methods useful when dealing with a\n {@code float}.","isClass":true,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":false,"isOrdinaryClass":true,"isPrimitive":false,"simpleName":"Float","qualifiedName":"java.lang.Float","dimension":"","elementType":{},"package":"java.lang","superclass":"java.lang.Number","interfaces":["java.lang.Comparable"],"isAbstract":false,"isStatic":false,"since":"JDK1.0","innerClasses":[],"isInnerClass":false,"constructors":[{"name":"Float","comment":"Constructs a newly allocated {@code Float} object that\n represents the primitive {@code float} argument.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":true,"isField":false,"isMethod":false,"isOrdinaryClass":false,"signature":"(float)","flatSignature":"(float)","parameters":[{"name":"value","type":{"isPrimitive":true,"simpleName":"float","qualifiedName":"float","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"Float","comment":"Constructs a newly allocated {@code Float} object that\n represents the argument converted to type {@code float}.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":true,"isField":false,"isMethod":false,"isOrdinaryClass":false,"signature":"(double)","flatSignature":"(double)","parameters":[{"name":"value","type":{"isPrimitive":true,"simpleName":"double","qualifiedName":"double","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"Float","comment":"Constructs a newly allocated {@code Float} object that\n represents the floating-point value of type {@code float}\n represented by the string. The string is converted to a\n {@code float} value as if by the {@code valueOf} method.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":true,"isField":false,"isMethod":false,"isOrdinaryClass":false,"signature":"(java.lang.String)","flatSignature":"(String)","parameters":[{"name":"s","type":{"isPrimitive":false,"simpleName":"String","qualifiedName":"java.lang.String","dimension":"","elementType":{}}}],"typeParameters":[]}],"fields":[{"name":"POSITIVE_INFINITY","comment":"A constant holding the positive infinity of type\n {@code float}. It is equal to the value returned by\n {@code Float.intBitsToFloat(0x7f800000)}.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":true,"isMethod":false,"isOrdinaryClass":false,"type":{"isPrimitive":true,"simpleName":"float","qualifiedName":"float","dimension":"","elementType":{}},"isStatic":true,"constantValue":"1f/0f"},{"name":"NEGATIVE_INFINITY","comment":"A constant holding the negative infinity of type\n {@code float}. It is equal to the value returned by\n {@code Float.intBitsToFloat(0xff800000)}.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":true,"isMethod":false,"isOrdinaryClass":false,"type":{"isPrimitive":true,"simpleName":"float","qualifiedName":"float","dimension":"","elementType":{}},"isStatic":true,"constantValue":"-1f/0f"},{"name":"NaN","comment":"A constant holding a Not-a-Number (NaN) value of type\n {@code float}.  It is equivalent to the value returned by\n {@code Float.intBitsToFloat(0x7fc00000)}.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":true,"isMethod":false,"isOrdinaryClass":false,"type":{"isPrimitive":true,"simpleName":"float","qualifiedName":"float","dimension":"","elementType":{}},"isStatic":true,"constantValue":"0f/0f"},{"name":"MAX_VALUE","comment":"A constant holding the largest positive finite value of type\n {@code float}, (2-2\u003csup\u003e-23\u003c/sup\u003e)\u0026middot;2\u003csup\u003e127\u003c/sup\u003e.\n It is equal to the hexadecimal floating-point literal\n {@code 0x1.fffffeP+127f} and also equal to\n {@code Float.intBitsToFloat(0x7f7fffff)}.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":true,"isMethod":false,"isOrdinaryClass":false,"type":{"isPrimitive":true,"simpleName":"float","qualifiedName":"float","dimension":"","elementType":{}},"isStatic":true,"constantValue":"3.4028234663852886E38f"},{"name":"MIN_NORMAL","comment":"A constant holding the smallest positive normal value of type\n {@code float}, 2\u003csup\u003e-126\u003c/sup\u003e.  It is equal to the\n hexadecimal floating-point literal {@code 0x1.0p-126f} and also\n equal to {@code Float.intBitsToFloat(0x00800000)}.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":true,"isMethod":false,"isOrdinaryClass":false,"type":{"isPrimitive":true,"simpleName":"float","qualifiedName":"float","dimension":"","elementType":{}},"isStatic":true,"constantValue":"1.1754943508222875E-38f"},{"name":"MIN_VALUE","comment":"A constant holding the smallest positive nonzero value of type\n {@code float}, 2\u003csup\u003e-149\u003c/sup\u003e. It is equal to the\n hexadecimal floating-point literal {@code 0x0.000002P-126f}\n and also equal to {@code Float.intBitsToFloat(0x1)}.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":true,"isMethod":false,"isOrdinaryClass":false,"type":{"isPrimitive":true,"simpleName":"float","qualifiedName":"float","dimension":"","elementType":{}},"isStatic":true,"constantValue":"1.401298464324817E-45f"},{"name":"MAX_EXPONENT","comment":"Maximum exponent a finite {@code float} variable may have.  It\n is equal to the value returned by {@code\n Math.getExponent(Float.MAX_VALUE)}.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":true,"isMethod":false,"isOrdinaryClass":false,"type":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}},"isStatic":true,"constantValue":"127"},{"name":"MIN_EXPONENT","comment":"Minimum exponent a normalized {@code float} variable may have.\n It is equal to the value returned by {@code\n Math.getExponent(Float.MIN_NORMAL)}.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":true,"isMethod":false,"isOrdinaryClass":false,"type":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}},"isStatic":true,"constantValue":"-126"},{"name":"SIZE","comment":"The number of bits used to represent a {@code float} value.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":true,"isMethod":false,"isOrdinaryClass":false,"type":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}},"isStatic":true,"constantValue":"32"},{"name":"BYTES","comment":"The number of bytes used to represent a {@code float} value.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":true,"isMethod":false,"isOrdinaryClass":false,"type":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}},"isStatic":true,"constantValue":"4"},{"name":"TYPE","comment":"The {@code Class} instance representing the primitive type\n {@code float}.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":true,"isMethod":false,"isOrdinaryClass":false,"type":{"isPrimitive":false,"simpleName":"Class","qualifiedName":"java.lang.Class","dimension":"","elementType":{}},"isStatic":true}],"methods":[{"name":"toString","comment":"Returns a string representation of the {@code float}\n argument. All characters mentioned below are ASCII characters.\n \u003cul\u003e\n \u003cli\u003eIf the argument is NaN, the result is the string\n \"{@code NaN}\".\n \u003cli\u003eOtherwise, the result is a string that represents the sign and\n     magnitude (absolute value) of the argument. If the sign is\n     negative, the first character of the result is\n     \u0027{@code -}\u0027 ({@code \u0027\\u002D\u0027}); if the sign is\n     positive, no sign character appears in the result. As for\n     the magnitude \u003ci\u003em\u003c/i\u003e:\n \u003cul\u003e\n \u003cli\u003eIf \u003ci\u003em\u003c/i\u003e is infinity, it is represented by the characters\n     {@code \"Infinity\"}; thus, positive infinity produces\n     the result {@code \"Infinity\"} and negative infinity\n     produces the result {@code \"-Infinity\"}.\n \u003cli\u003eIf \u003ci\u003em\u003c/i\u003e is zero, it is represented by the characters\n     {@code \"0.0\"}; thus, negative zero produces the result\n     {@code \"-0.0\"} and positive zero produces the result\n     {@code \"0.0\"}.\n \u003cli\u003e If \u003ci\u003em\u003c/i\u003e is greater than or equal to 10\u003csup\u003e-3\u003c/sup\u003e but\n      less than 10\u003csup\u003e7\u003c/sup\u003e, then it is represented as the\n      integer part of \u003ci\u003em\u003c/i\u003e, in decimal form with no leading\n      zeroes, followed by \u0027{@code .}\u0027\n      ({@code \u0027\\u002E\u0027}), followed by one or more\n      decimal digits representing the fractional part of\n      \u003ci\u003em\u003c/i\u003e.\n \u003cli\u003e If \u003ci\u003em\u003c/i\u003e is less than 10\u003csup\u003e-3\u003c/sup\u003e or greater than or\n      equal to 10\u003csup\u003e7\u003c/sup\u003e, then it is represented in\n      so-called \"computerized scientific notation.\" Let \u003ci\u003en\u003c/i\u003e\n      be the unique integer such that 10\u003csup\u003e\u003ci\u003en\u003c/i\u003e \u003c/sup\u003e\u0026le;\n      \u003ci\u003em\u003c/i\u003e {@literal \u003c} 10\u003csup\u003e\u003ci\u003en\u003c/i\u003e+1\u003c/sup\u003e; then let \u003ci\u003ea\u003c/i\u003e\n      be the mathematically exact quotient of \u003ci\u003em\u003c/i\u003e and\n      10\u003csup\u003e\u003ci\u003en\u003c/i\u003e\u003c/sup\u003e so that 1 \u0026le; \u003ci\u003ea\u003c/i\u003e {@literal \u003c} 10.\n      The magnitude is then represented as the integer part of\n      \u003ci\u003ea\u003c/i\u003e, as a single decimal digit, followed by\n      \u0027{@code .}\u0027 ({@code \u0027\\u002E\u0027}), followed by\n      decimal digits representing the fractional part of\n      \u003ci\u003ea\u003c/i\u003e, followed by the letter \u0027{@code E}\u0027\n      ({@code \u0027\\u0045\u0027}), followed by a representation\n      of \u003ci\u003en\u003c/i\u003e as a decimal integer, as produced by the\n      method {@link java.lang.Integer#toString(int)}.\n\n \u003c/ul\u003e\n \u003c/ul\u003e\n How many digits must be printed for the fractional part of\n \u003ci\u003em\u003c/i\u003e or \u003ci\u003ea\u003c/i\u003e? There must be at least one digit\n to represent the fractional part, and beyond that as many, but\n only as many, more digits as are needed to uniquely distinguish\n the argument value from adjacent values of type\n {@code float}. That is, suppose that \u003ci\u003ex\u003c/i\u003e is the\n exact mathematical value represented by the decimal\n representation produced by this method for a finite nonzero\n argument \u003ci\u003ef\u003c/i\u003e. Then \u003ci\u003ef\u003c/i\u003e must be the {@code float}\n value nearest to \u003ci\u003ex\u003c/i\u003e; or, if two {@code float} values are\n equally close to \u003ci\u003ex\u003c/i\u003e, then \u003ci\u003ef\u003c/i\u003e must be one of\n them and the least significant bit of the significand of\n \u003ci\u003ef\u003c/i\u003e must be {@code 0}.\n\n \u003cp\u003eTo create localized string representations of a floating-point\n value, use subclasses of {@link java.text.NumberFormat}.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(float)","flatSignature":"(float)","returnType":{"isPrimitive":false,"simpleName":"String","qualifiedName":"java.lang.String","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"f","type":{"isPrimitive":true,"simpleName":"float","qualifiedName":"float","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"toHexString","comment":"Returns a hexadecimal string representation of the\n {@code float} argument. All characters mentioned below are\n ASCII characters.\n\n \u003cul\u003e\n \u003cli\u003eIf the argument is NaN, the result is the string\n     \"{@code NaN}\".\n \u003cli\u003eOtherwise, the result is a string that represents the sign and\n magnitude (absolute value) of the argument. If the sign is negative,\n the first character of the result is \u0027{@code -}\u0027\n ({@code \u0027\\u002D\u0027}); if the sign is positive, no sign character\n appears in the result. As for the magnitude \u003ci\u003em\u003c/i\u003e:\n\n \u003cul\u003e\n \u003cli\u003eIf \u003ci\u003em\u003c/i\u003e is infinity, it is represented by the string\n {@code \"Infinity\"}; thus, positive infinity produces the\n result {@code \"Infinity\"} and negative infinity produces\n the result {@code \"-Infinity\"}.\n\n \u003cli\u003eIf \u003ci\u003em\u003c/i\u003e is zero, it is represented by the string\n {@code \"0x0.0p0\"}; thus, negative zero produces the result\n {@code \"-0x0.0p0\"} and positive zero produces the result\n {@code \"0x0.0p0\"}.\n\n \u003cli\u003eIf \u003ci\u003em\u003c/i\u003e is a {@code float} value with a\n normalized representation, substrings are used to represent the\n significand and exponent fields.  The significand is\n represented by the characters {@code \"0x1.\"}\n followed by a lowercase hexadecimal representation of the rest\n of the significand as a fraction.  Trailing zeros in the\n hexadecimal representation are removed unless all the digits\n are zero, in which case a single zero is used. Next, the\n exponent is represented by {@code \"p\"} followed\n by a decimal string of the unbiased exponent as if produced by\n a call to {@link Integer#toString(int) Integer.toString} on the\n exponent value.\n\n \u003cli\u003eIf \u003ci\u003em\u003c/i\u003e is a {@code float} value with a subnormal\n representation, the significand is represented by the\n characters {@code \"0x0.\"} followed by a\n hexadecimal representation of the rest of the significand as a\n fraction.  Trailing zeros in the hexadecimal representation are\n removed. Next, the exponent is represented by\n {@code \"p-126\"}.  Note that there must be at\n least one nonzero digit in a subnormal significand.\n\n \u003c/ul\u003e\n\n \u003c/ul\u003e\n\n \u003ctable border\u003e\n \u003ccaption\u003eExamples\u003c/caption\u003e\n \u003ctr\u003e\u003cth\u003eFloating-point Value\u003c/th\u003e\u003cth\u003eHexadecimal String\u003c/th\u003e\n \u003ctr\u003e\u003ctd\u003e{@code 1.0}\u003c/td\u003e \u003ctd\u003e{@code 0x1.0p0}\u003c/td\u003e\n \u003ctr\u003e\u003ctd\u003e{@code -1.0}\u003c/td\u003e        \u003ctd\u003e{@code -0x1.0p0}\u003c/td\u003e\n \u003ctr\u003e\u003ctd\u003e{@code 2.0}\u003c/td\u003e \u003ctd\u003e{@code 0x1.0p1}\u003c/td\u003e\n \u003ctr\u003e\u003ctd\u003e{@code 3.0}\u003c/td\u003e \u003ctd\u003e{@code 0x1.8p1}\u003c/td\u003e\n \u003ctr\u003e\u003ctd\u003e{@code 0.5}\u003c/td\u003e \u003ctd\u003e{@code 0x1.0p-1}\u003c/td\u003e\n \u003ctr\u003e\u003ctd\u003e{@code 0.25}\u003c/td\u003e        \u003ctd\u003e{@code 0x1.0p-2}\u003c/td\u003e\n \u003ctr\u003e\u003ctd\u003e{@code Float.MAX_VALUE}\u003c/td\u003e\n     \u003ctd\u003e{@code 0x1.fffffep127}\u003c/td\u003e\n \u003ctr\u003e\u003ctd\u003e{@code Minimum Normal Value}\u003c/td\u003e\n     \u003ctd\u003e{@code 0x1.0p-126}\u003c/td\u003e\n \u003ctr\u003e\u003ctd\u003e{@code Maximum Subnormal Value}\u003c/td\u003e\n     \u003ctd\u003e{@code 0x0.fffffep-126}\u003c/td\u003e\n \u003ctr\u003e\u003ctd\u003e{@code Float.MIN_VALUE}\u003c/td\u003e\n     \u003ctd\u003e{@code 0x0.000002p-126}\u003c/td\u003e\n \u003c/table\u003e","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(float)","flatSignature":"(float)","returnType":{"isPrimitive":false,"simpleName":"String","qualifiedName":"java.lang.String","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"f","type":{"isPrimitive":true,"simpleName":"float","qualifiedName":"float","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"valueOf","comment":"Returns a {@code Float} object holding the\n {@code float} value represented by the argument string\n {@code s}.\n\n \u003cp\u003eIf {@code s} is {@code null}, then a\n {@code NullPointerException} is thrown.\n\n \u003cp\u003eLeading and trailing whitespace characters in {@code s}\n are ignored.  Whitespace is removed as if by the {@link\n String#trim} method; that is, both ASCII space and control\n characters are removed. The rest of {@code s} should\n constitute a \u003ci\u003eFloatValue\u003c/i\u003e as described by the lexical\n syntax rules:\n\n \u003cblockquote\u003e\n \u003cdl\u003e\n \u003cdt\u003e\u003ci\u003eFloatValue:\u003c/i\u003e\n \u003cdd\u003e\u003ci\u003eSign\u003csub\u003eopt\u003c/sub\u003e\u003c/i\u003e {@code NaN}\n \u003cdd\u003e\u003ci\u003eSign\u003csub\u003eopt\u003c/sub\u003e\u003c/i\u003e {@code Infinity}\n \u003cdd\u003e\u003ci\u003eSign\u003csub\u003eopt\u003c/sub\u003e FloatingPointLiteral\u003c/i\u003e\n \u003cdd\u003e\u003ci\u003eSign\u003csub\u003eopt\u003c/sub\u003e HexFloatingPointLiteral\u003c/i\u003e\n \u003cdd\u003e\u003ci\u003eSignedInteger\u003c/i\u003e\n \u003c/dl\u003e\n\n \u003cdl\u003e\n \u003cdt\u003e\u003ci\u003eHexFloatingPointLiteral\u003c/i\u003e:\n \u003cdd\u003e \u003ci\u003eHexSignificand BinaryExponent FloatTypeSuffix\u003csub\u003eopt\u003c/sub\u003e\u003c/i\u003e\n \u003c/dl\u003e\n\n \u003cdl\u003e\n \u003cdt\u003e\u003ci\u003eHexSignificand:\u003c/i\u003e\n \u003cdd\u003e\u003ci\u003eHexNumeral\u003c/i\u003e\n \u003cdd\u003e\u003ci\u003eHexNumeral\u003c/i\u003e {@code .}\n \u003cdd\u003e{@code 0x} \u003ci\u003eHexDigits\u003csub\u003eopt\u003c/sub\u003e\n     \u003c/i\u003e{@code .}\u003ci\u003e HexDigits\u003c/i\u003e\n \u003cdd\u003e{@code 0X}\u003ci\u003e HexDigits\u003csub\u003eopt\u003c/sub\u003e\n     \u003c/i\u003e{@code .} \u003ci\u003eHexDigits\u003c/i\u003e\n \u003c/dl\u003e\n\n \u003cdl\u003e\n \u003cdt\u003e\u003ci\u003eBinaryExponent:\u003c/i\u003e\n \u003cdd\u003e\u003ci\u003eBinaryExponentIndicator SignedInteger\u003c/i\u003e\n \u003c/dl\u003e\n\n \u003cdl\u003e\n \u003cdt\u003e\u003ci\u003eBinaryExponentIndicator:\u003c/i\u003e\n \u003cdd\u003e{@code p}\n \u003cdd\u003e{@code P}\n \u003c/dl\u003e\n\n \u003c/blockquote\u003e\n\n where \u003ci\u003eSign\u003c/i\u003e, \u003ci\u003eFloatingPointLiteral\u003c/i\u003e,\n \u003ci\u003eHexNumeral\u003c/i\u003e, \u003ci\u003eHexDigits\u003c/i\u003e, \u003ci\u003eSignedInteger\u003c/i\u003e and\n \u003ci\u003eFloatTypeSuffix\u003c/i\u003e are as defined in the lexical structure\n sections of\n \u003ccite\u003eThe Java\u0026trade; Language Specification\u003c/cite\u003e,\n except that underscores are not accepted between digits.\n If {@code s} does not have the form of\n a \u003ci\u003eFloatValue\u003c/i\u003e, then a {@code NumberFormatException}\n is thrown. Otherwise, {@code s} is regarded as\n representing an exact decimal value in the usual\n \"computerized scientific notation\" or as an exact\n hexadecimal value; this exact numerical value is then\n conceptually converted to an \"infinitely precise\"\n binary value that is then rounded to type {@code float}\n by the usual round-to-nearest rule of IEEE 754 floating-point\n arithmetic, which includes preserving the sign of a zero\n value.\n\n Note that the round-to-nearest rule also implies overflow and\n underflow behaviour; if the exact value of {@code s} is large\n enough in magnitude (greater than or equal to ({@link\n #MAX_VALUE} + {@link Math#ulp(float) ulp(MAX_VALUE)}/2),\n rounding to {@code float} will result in an infinity and if the\n exact value of {@code s} is small enough in magnitude (less\n than or equal to {@link #MIN_VALUE}/2), rounding to float will\n result in a zero.\n\n Finally, after rounding a {@code Float} object representing\n this {@code float} value is returned.\n\n \u003cp\u003eTo interpret localized string representations of a\n floating-point value, use subclasses of {@link\n java.text.NumberFormat}.\n\n \u003cp\u003eNote that trailing format specifiers, specifiers that\n determine the type of a floating-point literal\n ({@code 1.0f} is a {@code float} value;\n {@code 1.0d} is a {@code double} value), do\n \u003cem\u003enot\u003c/em\u003e influence the results of this method.  In other\n words, the numerical value of the input string is converted\n directly to the target floating-point type.  In general, the\n two-step sequence of conversions, string to {@code double}\n followed by {@code double} to {@code float}, is\n \u003cem\u003enot\u003c/em\u003e equivalent to converting a string directly to\n {@code float}.  For example, if first converted to an\n intermediate {@code double} and then to\n {@code float}, the string\u003cbr\u003e\n {@code \"1.00000017881393421514957253748434595763683319091796875001d\"}\u003cbr\u003e\n results in the {@code float} value\n {@code 1.0000002f}; if the string is converted directly to\n {@code float}, \u003ccode\u003e1.000000\u003cb\u003e1\u003c/b\u003ef\u003c/code\u003e results.\n\n \u003cp\u003eTo avoid calling this method on an invalid string and having\n a {@code NumberFormatException} be thrown, the documentation\n for {@link Double#valueOf Double.valueOf} lists a regular\n expression which can be used to screen the input.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.lang.String)","flatSignature":"(String)","returnType":{"isPrimitive":false,"simpleName":"Float","qualifiedName":"java.lang.Float","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"s","type":{"isPrimitive":false,"simpleName":"String","qualifiedName":"java.lang.String","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"valueOf","comment":"Returns a {@code Float} instance representing the specified\n {@code float} value.\n If a new {@code Float} instance is not required, this method\n should generally be used in preference to the constructor\n {@link #Float(float)}, as this method is likely to yield\n significantly better space and time performance by caching\n frequently requested values.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(float)","flatSignature":"(float)","returnType":{"isPrimitive":false,"simpleName":"Float","qualifiedName":"java.lang.Float","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"f","type":{"isPrimitive":true,"simpleName":"float","qualifiedName":"float","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"parseFloat","comment":"Returns a new {@code float} initialized to the value\n represented by the specified {@code String}, as performed\n by the {@code valueOf} method of class {@code Float}.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.lang.String)","flatSignature":"(String)","returnType":{"isPrimitive":true,"simpleName":"float","qualifiedName":"float","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"s","type":{"isPrimitive":false,"simpleName":"String","qualifiedName":"java.lang.String","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"isNaN","comment":"Returns {@code true} if the specified number is a\n Not-a-Number (NaN) value, {@code false} otherwise.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(float)","flatSignature":"(float)","returnType":{"isPrimitive":true,"simpleName":"boolean","qualifiedName":"boolean","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"v","type":{"isPrimitive":true,"simpleName":"float","qualifiedName":"float","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"isInfinite","comment":"Returns {@code true} if the specified number is infinitely\n large in magnitude, {@code false} otherwise.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(float)","flatSignature":"(float)","returnType":{"isPrimitive":true,"simpleName":"boolean","qualifiedName":"boolean","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"v","type":{"isPrimitive":true,"simpleName":"float","qualifiedName":"float","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"isFinite","comment":"Returns {@code true} if the argument is a finite floating-point\n value; returns {@code false} otherwise (for NaN and infinity\n arguments).","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(float)","flatSignature":"(float)","returnType":{"isPrimitive":true,"simpleName":"boolean","qualifiedName":"boolean","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"f","type":{"isPrimitive":true,"simpleName":"float","qualifiedName":"float","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"isNaN","comment":"Returns {@code true} if this {@code Float} value is a\n Not-a-Number (NaN), {@code false} otherwise.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":true,"simpleName":"boolean","qualifiedName":"boolean","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[],"typeParameters":[]},{"name":"isInfinite","comment":"Returns {@code true} if this {@code Float} value is\n infinitely large in magnitude, {@code false} otherwise.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":true,"simpleName":"boolean","qualifiedName":"boolean","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[],"typeParameters":[]},{"name":"toString","comment":"Returns a string representation of this {@code Float} object.\n The primitive {@code float} value represented by this object\n is converted to a {@code String} exactly as if by the method\n {@code toString} of one argument.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":false,"simpleName":"String","qualifiedName":"java.lang.String","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[],"typeParameters":[]},{"name":"byteValue","comment":"Returns the value of this {@code Float} as a {@code byte} after\n a narrowing primitive conversion.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":true,"simpleName":"byte","qualifiedName":"byte","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[],"typeParameters":[]},{"name":"shortValue","comment":"Returns the value of this {@code Float} as a {@code short}\n after a narrowing primitive conversion.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":true,"simpleName":"short","qualifiedName":"short","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[],"typeParameters":[]},{"name":"intValue","comment":"Returns the value of this {@code Float} as an {@code int} after\n a narrowing primitive conversion.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[],"typeParameters":[]},{"name":"longValue","comment":"Returns value of this {@code Float} as a {@code long} after a\n narrowing primitive conversion.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":true,"simpleName":"long","qualifiedName":"long","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[],"typeParameters":[]},{"name":"floatValue","comment":"Returns the {@code float} value of this {@code Float} object.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":true,"simpleName":"float","qualifiedName":"float","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[],"typeParameters":[]},{"name":"doubleValue","comment":"Returns the value of this {@code Float} as a {@code double}\n after a widening primitive conversion.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":true,"simpleName":"double","qualifiedName":"double","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[],"typeParameters":[]},{"name":"hashCode","comment":"Returns a hash code for this {@code Float} object. The\n result is the integer bit representation, exactly as produced\n by the method {@link #floatToIntBits(float)}, of the primitive\n {@code float} value represented by this {@code Float}\n object.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[],"typeParameters":[]},{"name":"hashCode","comment":"Returns a hash code for a {@code float} value; compatible with\n {@code Float.hashCode()}.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(float)","flatSignature":"(float)","returnType":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"value","type":{"isPrimitive":true,"simpleName":"float","qualifiedName":"float","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"equals","comment":"Compares this object against the specified object.  The result\n is {@code true} if and only if the argument is not\n {@code null} and is a {@code Float} object that\n represents a {@code float} with the same value as the\n {@code float} represented by this object. For this\n purpose, two {@code float} values are considered to be the\n same if and only if the method {@link #floatToIntBits(float)}\n returns the identical {@code int} value when applied to\n each.\n\n \u003cp\u003eNote that in most cases, for two instances of class\n {@code Float}, {@code f1} and {@code f2}, the value\n of {@code f1.equals(f2)} is {@code true} if and only if\n\n \u003cblockquote\u003e\u003cpre\u003e\n   f1.floatValue() \u003d\u003d f2.floatValue()\n \u003c/pre\u003e\u003c/blockquote\u003e\n\n \u003cp\u003ealso has the value {@code true}. However, there are two exceptions:\n \u003cul\u003e\n \u003cli\u003eIf {@code f1} and {@code f2} both represent\n     {@code Float.NaN}, then the {@code equals} method returns\n     {@code true}, even though {@code Float.NaN\u003d\u003dFloat.NaN}\n     has the value {@code false}.\n \u003cli\u003eIf {@code f1} represents {@code +0.0f} while\n     {@code f2} represents {@code -0.0f}, or vice\n     versa, the {@code equal} test has the value\n     {@code false}, even though {@code 0.0f\u003d\u003d-0.0f}\n     has the value {@code true}.\n \u003c/ul\u003e\n\n This definition allows hash tables to operate properly.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.lang.Object)","flatSignature":"(Object)","returnType":{"isPrimitive":true,"simpleName":"boolean","qualifiedName":"boolean","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[{"name":"obj","type":{"isPrimitive":false,"simpleName":"Object","qualifiedName":"java.lang.Object","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"floatToIntBits","comment":"Returns a representation of the specified floating-point value\n according to the IEEE 754 floating-point \"single format\" bit\n layout.\n\n \u003cp\u003eBit 31 (the bit that is selected by the mask\n {@code 0x80000000}) represents the sign of the floating-point\n number.\n Bits 30-23 (the bits that are selected by the mask\n {@code 0x7f800000}) represent the exponent.\n Bits 22-0 (the bits that are selected by the mask\n {@code 0x007fffff}) represent the significand (sometimes called\n the mantissa) of the floating-point number.\n\n \u003cp\u003eIf the argument is positive infinity, the result is\n {@code 0x7f800000}.\n\n \u003cp\u003eIf the argument is negative infinity, the result is\n {@code 0xff800000}.\n\n \u003cp\u003eIf the argument is NaN, the result is {@code 0x7fc00000}.\n\n \u003cp\u003eIn all cases, the result is an integer that, when given to the\n {@link #intBitsToFloat(int)} method, will produce a floating-point\n value the same as the argument to {@code floatToIntBits}\n (except all NaN values are collapsed to a single\n \"canonical\" NaN value).","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(float)","flatSignature":"(float)","returnType":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"value","type":{"isPrimitive":true,"simpleName":"float","qualifiedName":"float","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"floatToRawIntBits","comment":"Returns a representation of the specified floating-point value\n according to the IEEE 754 floating-point \"single format\" bit\n layout, preserving Not-a-Number (NaN) values.\n\n \u003cp\u003eBit 31 (the bit that is selected by the mask\n {@code 0x80000000}) represents the sign of the floating-point\n number.\n Bits 30-23 (the bits that are selected by the mask\n {@code 0x7f800000}) represent the exponent.\n Bits 22-0 (the bits that are selected by the mask\n {@code 0x007fffff}) represent the significand (sometimes called\n the mantissa) of the floating-point number.\n\n \u003cp\u003eIf the argument is positive infinity, the result is\n {@code 0x7f800000}.\n\n \u003cp\u003eIf the argument is negative infinity, the result is\n {@code 0xff800000}.\n\n \u003cp\u003eIf the argument is NaN, the result is the integer representing\n the actual NaN value.  Unlike the {@code floatToIntBits}\n method, {@code floatToRawIntBits} does not collapse all the\n bit patterns encoding a NaN to a single \"canonical\"\n NaN value.\n\n \u003cp\u003eIn all cases, the result is an integer that, when given to the\n {@link #intBitsToFloat(int)} method, will produce a\n floating-point value the same as the argument to\n {@code floatToRawIntBits}.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(float)","flatSignature":"(float)","returnType":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"value","type":{"isPrimitive":true,"simpleName":"float","qualifiedName":"float","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"intBitsToFloat","comment":"Returns the {@code float} value corresponding to a given\n bit representation.\n The argument is considered to be a representation of a\n floating-point value according to the IEEE 754 floating-point\n \"single format\" bit layout.\n\n \u003cp\u003eIf the argument is {@code 0x7f800000}, the result is positive\n infinity.\n\n \u003cp\u003eIf the argument is {@code 0xff800000}, the result is negative\n infinity.\n\n \u003cp\u003eIf the argument is any value in the range\n {@code 0x7f800001} through {@code 0x7fffffff} or in\n the range {@code 0xff800001} through\n {@code 0xffffffff}, the result is a NaN.  No IEEE 754\n floating-point operation provided by Java can distinguish\n between two NaN values of the same type with different bit\n patterns.  Distinct values of NaN are only distinguishable by\n use of the {@code Float.floatToRawIntBits} method.\n\n \u003cp\u003eIn all other cases, let \u003ci\u003es\u003c/i\u003e, \u003ci\u003ee\u003c/i\u003e, and \u003ci\u003em\u003c/i\u003e be three\n values that can be computed from the argument:\n\n \u003cblockquote\u003e\u003cpre\u003e{@code\n int s \u003d ((bits \u003e\u003e 31) \u003d\u003d 0) ? 1 : -1;\n int e \u003d ((bits \u003e\u003e 23) \u0026 0xff);\n int m \u003d (e \u003d\u003d 0) ?\n                 (bits \u0026 0x7fffff) \u003c\u003c 1 :\n                 (bits \u0026 0x7fffff) | 0x800000;\n }\u003c/pre\u003e\u003c/blockquote\u003e\n\n Then the floating-point result equals the value of the mathematical\n expression \u003ci\u003es\u003c/i\u003e\u0026middot;\u003ci\u003em\u003c/i\u003e\u0026middot;2\u003csup\u003e\u003ci\u003ee\u003c/i\u003e-150\u003c/sup\u003e.\n\n \u003cp\u003eNote that this method may not be able to return a\n {@code float} NaN with exactly same bit pattern as the\n {@code int} argument.  IEEE 754 distinguishes between two\n kinds of NaNs, quiet NaNs and \u003ci\u003esignaling NaNs\u003c/i\u003e.  The\n differences between the two kinds of NaN are generally not\n visible in Java.  Arithmetic operations on signaling NaNs turn\n them into quiet NaNs with a different, but often similar, bit\n pattern.  However, on some processors merely copying a\n signaling NaN also performs that conversion.  In particular,\n copying a signaling NaN to return it to the calling method may\n perform this conversion.  So {@code intBitsToFloat} may\n not be able to return a {@code float} with a signaling NaN\n bit pattern.  Consequently, for some {@code int} values,\n {@code floatToRawIntBits(intBitsToFloat(start))} may\n \u003ci\u003enot\u003c/i\u003e equal {@code start}.  Moreover, which\n particular bit patterns represent signaling NaNs is platform\n dependent; although all NaN bit patterns, quiet or signaling,\n must be in the NaN range identified above.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(int)","flatSignature":"(int)","returnType":{"isPrimitive":true,"simpleName":"float","qualifiedName":"float","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"bits","type":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"compareTo","comment":"Compares two {@code Float} objects numerically.  There are\n two ways in which comparisons performed by this method differ\n from those performed by the Java language numerical comparison\n operators ({@code \u003c, \u003c\u003d, \u003d\u003d, \u003e\u003d, \u003e}) when\n applied to primitive {@code float} values:\n\n \u003cul\u003e\u003cli\u003e\n          {@code Float.NaN} is considered by this method to\n          be equal to itself and greater than all other\n          {@code float} values\n          (including {@code Float.POSITIVE_INFINITY}).\n \u003cli\u003e\n          {@code 0.0f} is considered by this method to be greater\n          than {@code -0.0f}.\n \u003c/ul\u003e\n\n This ensures that the \u003ci\u003enatural ordering\u003c/i\u003e of {@code Float}\n objects imposed by this method is \u003ci\u003econsistent with equals\u003c/i\u003e.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.lang.Float)","flatSignature":"(Float)","returnType":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[{"name":"anotherFloat","type":{"isPrimitive":false,"simpleName":"Float","qualifiedName":"java.lang.Float","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"compare","comment":"Compares the two specified {@code float} values. The sign\n of the integer value returned is the same as that of the\n integer that would be returned by the call:\n \u003cpre\u003e\n    new Float(f1).compareTo(new Float(f2))\n \u003c/pre\u003e","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(float, float)","flatSignature":"(float, float)","returnType":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"f1","type":{"isPrimitive":true,"simpleName":"float","qualifiedName":"float","dimension":"","elementType":{}}},{"name":"f2","type":{"isPrimitive":true,"simpleName":"float","qualifiedName":"float","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"sum","comment":"Adds two {@code float} values together as per the + operator.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(float, float)","flatSignature":"(float, float)","returnType":{"isPrimitive":true,"simpleName":"float","qualifiedName":"float","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"a","type":{"isPrimitive":true,"simpleName":"float","qualifiedName":"float","dimension":"","elementType":{}}},{"name":"b","type":{"isPrimitive":true,"simpleName":"float","qualifiedName":"float","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"max","comment":"Returns the greater of two {@code float} values\n as if by calling {@link Math#max(float, float) Math.max}.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(float, float)","flatSignature":"(float, float)","returnType":{"isPrimitive":true,"simpleName":"float","qualifiedName":"float","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"a","type":{"isPrimitive":true,"simpleName":"float","qualifiedName":"float","dimension":"","elementType":{}}},{"name":"b","type":{"isPrimitive":true,"simpleName":"float","qualifiedName":"float","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"min","comment":"Returns the smaller of two {@code float} values\n as if by calling {@link Math#min(float, float) Math.min}.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(float, float)","flatSignature":"(float, float)","returnType":{"isPrimitive":true,"simpleName":"float","qualifiedName":"float","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"a","type":{"isPrimitive":true,"simpleName":"float","qualifiedName":"float","dimension":"","elementType":{}}},{"name":"b","type":{"isPrimitive":true,"simpleName":"float","qualifiedName":"float","dimension":"","elementType":{}}}],"typeParameters":[]}],"typeParameters":[],"enumConstants":[]}