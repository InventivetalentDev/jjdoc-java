{"name":"AnnotatedElement","comment":"Represents an annotated element of the program currently running in this\n VM.  This interface allows annotations to be read reflectively.  All\n annotations returned by methods in this interface are immutable and\n serializable. The arrays returned by methods of this interface may be modified\n by callers without affecting the arrays returned to other callers.\n\n \u003cp\u003eThe {@link #getAnnotationsByType(Class)} and {@link\n #getDeclaredAnnotationsByType(Class)} methods support multiple\n annotations of the same type on an element. If the argument to\n either method is a repeatable annotation type (JLS 9.6), then the\n method will \"look through\" a container annotation (JLS 9.7), if\n present, and return any annotations inside the container. Container\n annotations may be generated at compile-time to wrap multiple\n annotations of the argument type.\n\n \u003cp\u003eThe terms \u003cem\u003edirectly present\u003c/em\u003e, \u003cem\u003eindirectly present\u003c/em\u003e,\n \u003cem\u003epresent\u003c/em\u003e, and \u003cem\u003eassociated\u003c/em\u003e are used throughout this\n interface to describe precisely which annotations are returned by\n methods:\n\n \u003cul\u003e\n\n \u003cli\u003e An annotation \u003ci\u003eA\u003c/i\u003e is \u003cem\u003edirectly present\u003c/em\u003e on an\n element \u003ci\u003eE\u003c/i\u003e if \u003ci\u003eE\u003c/i\u003e has a {@code\n RuntimeVisibleAnnotations} or {@code\n RuntimeVisibleParameterAnnotations} or {@code\n RuntimeVisibleTypeAnnotations} attribute, and the attribute\n contains \u003ci\u003eA\u003c/i\u003e.\n\n \u003cli\u003eAn annotation \u003ci\u003eA\u003c/i\u003e is \u003cem\u003eindirectly present\u003c/em\u003e on an\n element \u003ci\u003eE\u003c/i\u003e if \u003ci\u003eE\u003c/i\u003e has a {@code RuntimeVisibleAnnotations} or\n {@code RuntimeVisibleParameterAnnotations} or {@code RuntimeVisibleTypeAnnotations}\n attribute, and \u003ci\u003eA\u003c/i\u003e \u0027s type is repeatable, and the attribute contains\n exactly one annotation whose value element contains \u003ci\u003eA\u003c/i\u003e and whose\n type is the containing annotation type of \u003ci\u003eA\u003c/i\u003e \u0027s type.\n\n \u003cli\u003eAn annotation \u003ci\u003eA\u003c/i\u003e is present on an element \u003ci\u003eE\u003c/i\u003e if either:\n\n \u003cul\u003e\n\n \u003cli\u003e\u003ci\u003eA\u003c/i\u003e is directly present on \u003ci\u003eE\u003c/i\u003e; or\n\n \u003cli\u003eNo annotation of \u003ci\u003eA\u003c/i\u003e \u0027s type is directly present on\n \u003ci\u003eE\u003c/i\u003e, and \u003ci\u003eE\u003c/i\u003e is a class, and \u003ci\u003eA\u003c/i\u003e \u0027s type is\n inheritable, and \u003ci\u003eA\u003c/i\u003e is present on the superclass of \u003ci\u003eE\u003c/i\u003e.\n\n \u003c/ul\u003e\n\n \u003cli\u003eAn annotation \u003ci\u003eA\u003c/i\u003e is \u003cem\u003eassociated\u003c/em\u003e with an element \u003ci\u003eE\u003c/i\u003e\n if either:\n\n \u003cul\u003e\n\n \u003cli\u003e\u003ci\u003eA\u003c/i\u003e is directly or indirectly present on \u003ci\u003eE\u003c/i\u003e; or\n\n \u003cli\u003eNo annotation of \u003ci\u003eA\u003c/i\u003e \u0027s type is directly or indirectly\n present on \u003ci\u003eE\u003c/i\u003e, and \u003ci\u003eE\u003c/i\u003e is a class, and \u003ci\u003eA\u003c/i\u003e\u0027s type\n is inheritable, and \u003ci\u003eA\u003c/i\u003e is associated with the superclass of\n \u003ci\u003eE\u003c/i\u003e.\n\n \u003c/ul\u003e\n\n \u003c/ul\u003e\n\n \u003cp\u003eThe table below summarizes which kind of annotation presence\n different methods in this interface examine.\n\n \u003ctable border\u003e\n \u003ccaption\u003eOverview of kind of presence detected by different AnnotatedElement methods\u003c/caption\u003e\n \u003ctr\u003e\u003cth colspan\u003d2\u003e\u003c/th\u003e\u003cth colspan\u003d4\u003eKind of Presence\u003c/th\u003e\n \u003ctr\u003e\u003cth colspan\u003d2\u003eMethod\u003c/th\u003e\u003cth\u003eDirectly Present\u003c/th\u003e\u003cth\u003eIndirectly Present\u003c/th\u003e\u003cth\u003ePresent\u003c/th\u003e\u003cth\u003eAssociated\u003c/th\u003e\n \u003ctr\u003e\u003ctd align\u003dright\u003e{@code T}\u003c/td\u003e\u003ctd\u003e{@link #getAnnotation(Class) getAnnotation(Class\u0026lt;T\u0026gt;)}\n \u003ctd\u003e\u003c/td\u003e\u003ctd\u003e\u003c/td\u003e\u003ctd\u003eX\u003c/td\u003e\u003ctd\u003e\u003c/td\u003e\n \u003c/tr\u003e\n \u003ctr\u003e\u003ctd align\u003dright\u003e{@code Annotation[]}\u003c/td\u003e\u003ctd\u003e{@link #getAnnotations getAnnotations()}\n \u003ctd\u003e\u003c/td\u003e\u003ctd\u003e\u003c/td\u003e\u003ctd\u003eX\u003c/td\u003e\u003ctd\u003e\u003c/td\u003e\n \u003c/tr\u003e\n \u003ctr\u003e\u003ctd align\u003dright\u003e{@code T[]}\u003c/td\u003e\u003ctd\u003e{@link #getAnnotationsByType(Class) getAnnotationsByType(Class\u0026lt;T\u0026gt;)}\n \u003ctd\u003e\u003c/td\u003e\u003ctd\u003e\u003c/td\u003e\u003ctd\u003e\u003c/td\u003e\u003ctd\u003eX\u003c/td\u003e\n \u003c/tr\u003e\n \u003ctr\u003e\u003ctd align\u003dright\u003e{@code T}\u003c/td\u003e\u003ctd\u003e{@link #getDeclaredAnnotation(Class) getDeclaredAnnotation(Class\u0026lt;T\u0026gt;)}\n \u003ctd\u003eX\u003c/td\u003e\u003ctd\u003e\u003c/td\u003e\u003ctd\u003e\u003c/td\u003e\u003ctd\u003e\u003c/td\u003e\n \u003c/tr\u003e\n \u003ctr\u003e\u003ctd align\u003dright\u003e{@code Annotation[]}\u003c/td\u003e\u003ctd\u003e{@link #getDeclaredAnnotations getDeclaredAnnotations()}\n \u003ctd\u003eX\u003c/td\u003e\u003ctd\u003e\u003c/td\u003e\u003ctd\u003e\u003c/td\u003e\u003ctd\u003e\u003c/td\u003e\n \u003c/tr\u003e\n \u003ctr\u003e\u003ctd align\u003dright\u003e{@code T[]}\u003c/td\u003e\u003ctd\u003e{@link #getDeclaredAnnotationsByType(Class) getDeclaredAnnotationsByType(Class\u0026lt;T\u0026gt;)}\n \u003ctd\u003eX\u003c/td\u003e\u003ctd\u003eX\u003c/td\u003e\u003ctd\u003e\u003c/td\u003e\u003ctd\u003e\u003c/td\u003e\n \u003c/tr\u003e\n \u003c/table\u003e\n\n \u003cp\u003eFor an invocation of {@code get[Declared]AnnotationsByType( Class \u003c\n T \u003e)}, the order of annotations which are directly or indirectly\n present on an element \u003ci\u003eE\u003c/i\u003e is computed as if indirectly present\n annotations on \u003ci\u003eE\u003c/i\u003e are directly present on \u003ci\u003eE\u003c/i\u003e in place\n of their container annotation, in the order in which they appear in\n the value element of the container annotation.\n\n \u003cp\u003eThere are several compatibility concerns to keep in mind if an\n annotation type \u003ci\u003eT\u003c/i\u003e is originally \u003cem\u003enot\u003c/em\u003e repeatable and\n later modified to be repeatable.\n\n The containing annotation type for \u003ci\u003eT\u003c/i\u003e is \u003ci\u003eTC\u003c/i\u003e.\n\n \u003cul\u003e\n\n \u003cli\u003eModifying \u003ci\u003eT\u003c/i\u003e to be repeatable is source and binary\n compatible with existing uses of \u003ci\u003eT\u003c/i\u003e and with existing uses\n of \u003ci\u003eTC\u003c/i\u003e.\n\n That is, for source compatibility, source code with annotations of\n type \u003ci\u003eT\u003c/i\u003e or of type \u003ci\u003eTC\u003c/i\u003e will still compile. For binary\n compatibility, class files with annotations of type \u003ci\u003eT\u003c/i\u003e or of\n type \u003ci\u003eTC\u003c/i\u003e (or with other kinds of uses of type \u003ci\u003eT\u003c/i\u003e or of\n type \u003ci\u003eTC\u003c/i\u003e) will link against the modified version of \u003ci\u003eT\u003c/i\u003e\n if they linked against the earlier version.\n\n (An annotation type \u003ci\u003eTC\u003c/i\u003e may informally serve as an acting\n containing annotation type before \u003ci\u003eT\u003c/i\u003e is modified to be\n formally repeatable. Alternatively, when \u003ci\u003eT\u003c/i\u003e is made\n repeatable, \u003ci\u003eTC\u003c/i\u003e can be introduced as a new type.)\n\n \u003cli\u003eIf an annotation type \u003ci\u003eTC\u003c/i\u003e is present on an element, and\n \u003ci\u003eT\u003c/i\u003e is modified to be repeatable with \u003ci\u003eTC\u003c/i\u003e as its\n containing annotation type then:\n\n \u003cul\u003e\n\n \u003cli\u003eThe change to \u003ci\u003eT\u003c/i\u003e is behaviorally compatible with respect\n to the {@code get[Declared]Annotation(Class\u003cT\u003e)} (called with an\n argument of \u003ci\u003eT\u003c/i\u003e or \u003ci\u003eTC\u003c/i\u003e) and {@code\n get[Declared]Annotations()} methods because the results of the\n methods will not change due to \u003ci\u003eTC\u003c/i\u003e becoming the containing\n annotation type for \u003ci\u003eT\u003c/i\u003e.\n\n \u003cli\u003eThe change to \u003ci\u003eT\u003c/i\u003e changes the results of the {@code\n get[Declared]AnnotationsByType(Class\u003cT\u003e)} methods called with an\n argument of \u003ci\u003eT\u003c/i\u003e, because those methods will now recognize an\n annotation of type \u003ci\u003eTC\u003c/i\u003e as a container annotation for \u003ci\u003eT\u003c/i\u003e\n and will \"look through\" it to expose annotations of type \u003ci\u003eT\u003c/i\u003e.\n\n \u003c/ul\u003e\n\n \u003cli\u003eIf an annotation of type \u003ci\u003eT\u003c/i\u003e is present on an\n element and \u003ci\u003eT\u003c/i\u003e is made repeatable and more annotations of\n type \u003ci\u003eT\u003c/i\u003e are added to the element:\n\n \u003cul\u003e\n\n \u003cli\u003e The addition of the annotations of type \u003ci\u003eT\u003c/i\u003e is both\n source compatible and binary compatible.\n\n \u003cli\u003eThe addition of the annotations of type \u003ci\u003eT\u003c/i\u003e changes the results\n of the {@code get[Declared]Annotation(Class\u003cT\u003e)} methods and {@code\n get[Declared]Annotations()} methods, because those methods will now\n only see a container annotation on the element and not see an\n annotation of type \u003ci\u003eT\u003c/i\u003e.\n\n \u003cli\u003eThe addition of the annotations of type \u003ci\u003eT\u003c/i\u003e changes the\n results of the {@code get[Declared]AnnotationsByType(Class\u003cT\u003e)}\n methods, because their results will expose the additional\n annotations of type \u003ci\u003eT\u003c/i\u003e whereas previously they exposed only a\n single annotation of type \u003ci\u003eT\u003c/i\u003e.\n\n \u003c/ul\u003e\n\n \u003c/ul\u003e\n\n \u003cp\u003eIf an annotation returned by a method in this interface contains\n (directly or indirectly) a {@link Class}-valued member referring to\n a class that is not accessible in this VM, attempting to read the class\n by calling the relevant Class-returning method on the returned annotation\n will result in a {@link TypeNotPresentException}.\n\n \u003cp\u003eSimilarly, attempting to read an enum-valued member will result in\n a {@link EnumConstantNotPresentException} if the enum constant in the\n annotation is no longer present in the enum type.\n\n \u003cp\u003eIf an annotation type \u003ci\u003eT\u003c/i\u003e is (meta-)annotated with an\n {@code @Repeatable} annotation whose value element indicates a type\n \u003ci\u003eTC\u003c/i\u003e, but \u003ci\u003eTC\u003c/i\u003e does not declare a {@code value()} method\n with a return type of \u003ci\u003eT\u003c/i\u003e{@code []}, then an exception of type\n {@link java.lang.annotation.AnnotationFormatError} is thrown.\n\n \u003cp\u003eFinally, attempting to read a member whose definition has evolved\n incompatibly will result in a {@link\n java.lang.annotation.AnnotationTypeMismatchException} or an\n {@link java.lang.annotation.IncompleteAnnotationException}.","isClass":false,"isInterface":true,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":false,"isOrdinaryClass":false,"isPrimitive":false,"simpleName":"AnnotatedElement","qualifiedName":"java.lang.reflect.AnnotatedElement","dimension":"","elementType":{},"package":"java.lang.reflect","interfaces":[],"isAbstract":true,"isStatic":false,"since":"1.5","innerClasses":[],"isInnerClass":false,"constructors":[],"fields":[],"methods":[{"name":"isAnnotationPresent","comment":"Returns true if an annotation for the specified type\n is \u003cem\u003epresent\u003c/em\u003e on this element, else false.  This method\n is designed primarily for convenient access to marker annotations.\n\n \u003cp\u003eThe truth value returned by this method is equivalent to:\n {@code getAnnotation(annotationClass) !\u003d null}\n\n \u003cp\u003eThe body of the default method is specified to be the code\n above.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.lang.Class\u003c? extends java.lang.annotation.Annotation\u003e)","flatSignature":"(Class\u003c? extends Annotation\u003e)","returnType":{"isPrimitive":true,"simpleName":"boolean","qualifiedName":"boolean","dimension":"","elementType":{}},"isAbstract":false,"isDefault":true,"isStatic":false,"parameters":[{"name":"annotationClass","type":{"isPrimitive":false,"simpleName":"Class","qualifiedName":"java.lang.Class","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"getAnnotation","comment":"Returns this element\u0027s annotation for the specified type if\n such an annotation is \u003cem\u003epresent\u003c/em\u003e, else null.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.lang.Class\u003cT\u003e)","flatSignature":"(Class\u003cT\u003e)","returnType":{"isPrimitive":false,"simpleName":"T","qualifiedName":"T","dimension":"","elementType":{},"typeVariable":{"name":"T","bounds":["java.lang.annotation.Annotation"]}},"isAbstract":true,"isDefault":false,"isStatic":false,"parameters":[{"name":"annotationClass","type":{"isPrimitive":false,"simpleName":"Class","qualifiedName":"java.lang.Class","dimension":"","elementType":{}}}],"typeParameters":[{"name":"T","bounds":["java.lang.annotation.Annotation"]}]},{"name":"getAnnotations","comment":"Returns annotations that are \u003cem\u003epresent\u003c/em\u003e on this element.\n\n If there are no annotations \u003cem\u003epresent\u003c/em\u003e on this element, the return\n value is an array of length 0.\n\n The caller of this method is free to modify the returned array; it will\n have no effect on the arrays returned to other callers.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":false,"simpleName":"Annotation","qualifiedName":"java.lang.annotation.Annotation","dimension":"[]","elementType":{"isPrimitive":false,"simpleName":"Annotation","qualifiedName":"java.lang.annotation.Annotation","dimension":"","elementType":{}}},"isAbstract":true,"isDefault":false,"isStatic":false,"parameters":[],"typeParameters":[]},{"name":"getAnnotationsByType","comment":"Returns annotations that are \u003cem\u003eassociated\u003c/em\u003e with this element.\n\n If there are no annotations \u003cem\u003eassociated\u003c/em\u003e with this element, the return\n value is an array of length 0.\n\n The difference between this method and {@link #getAnnotation(Class)}\n is that this method detects if its argument is a \u003cem\u003erepeatable\n annotation type\u003c/em\u003e (JLS 9.6), and if so, attempts to find one or\n more annotations of that type by \"looking through\" a container\n annotation.\n\n The caller of this method is free to modify the returned array; it will\n have no effect on the arrays returned to other callers.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.lang.Class\u003cT\u003e)","flatSignature":"(Class\u003cT\u003e)","returnType":{"isPrimitive":false,"simpleName":"T","qualifiedName":"T","dimension":"[]","elementType":{"isPrimitive":false,"simpleName":"T","qualifiedName":"T","dimension":"","elementType":{},"typeVariable":{"name":"T","bounds":["java.lang.annotation.Annotation"]}},"typeVariable":{"name":"T","bounds":["java.lang.annotation.Annotation"]}},"isAbstract":false,"isDefault":true,"isStatic":false,"parameters":[{"name":"annotationClass","type":{"isPrimitive":false,"simpleName":"Class","qualifiedName":"java.lang.Class","dimension":"","elementType":{}}}],"typeParameters":[{"name":"T","bounds":["java.lang.annotation.Annotation"]}]},{"name":"getDeclaredAnnotation","comment":"Returns this element\u0027s annotation for the specified type if\n such an annotation is \u003cem\u003edirectly present\u003c/em\u003e, else null.\n\n This method ignores inherited annotations. (Returns null if no\n annotations are directly present on this element.)","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.lang.Class\u003cT\u003e)","flatSignature":"(Class\u003cT\u003e)","returnType":{"isPrimitive":false,"simpleName":"T","qualifiedName":"T","dimension":"","elementType":{},"typeVariable":{"name":"T","bounds":["java.lang.annotation.Annotation"]}},"isAbstract":false,"isDefault":true,"isStatic":false,"parameters":[{"name":"annotationClass","type":{"isPrimitive":false,"simpleName":"Class","qualifiedName":"java.lang.Class","dimension":"","elementType":{}}}],"typeParameters":[{"name":"T","bounds":["java.lang.annotation.Annotation"]}]},{"name":"getDeclaredAnnotationsByType","comment":"Returns this element\u0027s annotation(s) for the specified type if\n such annotations are either \u003cem\u003edirectly present\u003c/em\u003e or\n \u003cem\u003eindirectly present\u003c/em\u003e. This method ignores inherited\n annotations.\n\n If there are no specified annotations directly or indirectly\n present on this element, the return value is an array of length\n 0.\n\n The difference between this method and {@link\n #getDeclaredAnnotation(Class)} is that this method detects if its\n argument is a \u003cem\u003erepeatable annotation type\u003c/em\u003e (JLS 9.6), and if so,\n attempts to find one or more annotations of that type by \"looking\n through\" a container annotation if one is present.\n\n The caller of this method is free to modify the returned array; it will\n have no effect on the arrays returned to other callers.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.lang.Class\u003cT\u003e)","flatSignature":"(Class\u003cT\u003e)","returnType":{"isPrimitive":false,"simpleName":"T","qualifiedName":"T","dimension":"[]","elementType":{"isPrimitive":false,"simpleName":"T","qualifiedName":"T","dimension":"","elementType":{},"typeVariable":{"name":"T","bounds":["java.lang.annotation.Annotation"]}},"typeVariable":{"name":"T","bounds":["java.lang.annotation.Annotation"]}},"isAbstract":false,"isDefault":true,"isStatic":false,"parameters":[{"name":"annotationClass","type":{"isPrimitive":false,"simpleName":"Class","qualifiedName":"java.lang.Class","dimension":"","elementType":{}}}],"typeParameters":[{"name":"T","bounds":["java.lang.annotation.Annotation"]}]},{"name":"getDeclaredAnnotations","comment":"Returns annotations that are \u003cem\u003edirectly present\u003c/em\u003e on this element.\n This method ignores inherited annotations.\n\n If there are no annotations \u003cem\u003edirectly present\u003c/em\u003e on this element,\n the return value is an array of length 0.\n\n The caller of this method is free to modify the returned array; it will\n have no effect on the arrays returned to other callers.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":false,"simpleName":"Annotation","qualifiedName":"java.lang.annotation.Annotation","dimension":"[]","elementType":{"isPrimitive":false,"simpleName":"Annotation","qualifiedName":"java.lang.annotation.Annotation","dimension":"","elementType":{}}},"isAbstract":true,"isDefault":false,"isStatic":false,"parameters":[],"typeParameters":[]}],"typeParameters":[],"subInterfaces":["java.lang.Package","java.lang.reflect.GenericDeclaration","java.lang.Class","java.lang.reflect.TypeVariable","java.lang.reflect.Parameter","java.lang.reflect.AnnotatedType","java.lang.reflect.AccessibleObject"],"enumConstants":[]}