{"name":"Proxy","comment":"{@code Proxy} provides static methods for creating dynamic proxy\n classes and instances, and it is also the superclass of all\n dynamic proxy classes created by those methods.\n\n \u003cp\u003eTo create a proxy for some interface {@code Foo}:\n \u003cpre\u003e\n     InvocationHandler handler \u003d new MyInvocationHandler(...);\n     Class\u0026lt;?\u0026gt; proxyClass \u003d Proxy.getProxyClass(Foo.class.getClassLoader(), Foo.class);\n     Foo f \u003d (Foo) proxyClass.getConstructor(InvocationHandler.class).\n                     newInstance(handler);\n \u003c/pre\u003e\n or more simply:\n \u003cpre\u003e\n     Foo f \u003d (Foo) Proxy.newProxyInstance(Foo.class.getClassLoader(),\n                                          new Class\u0026lt;?\u0026gt;[] { Foo.class },\n                                          handler);\n \u003c/pre\u003e\n\n \u003cp\u003eA \u003ci\u003edynamic proxy class\u003c/i\u003e (simply referred to as a \u003ci\u003eproxy\n class\u003c/i\u003e below) is a class that implements a list of interfaces\n specified at runtime when the class is created, with behavior as\n described below.\n\n A \u003ci\u003eproxy interface\u003c/i\u003e is such an interface that is implemented\n by a proxy class.\n\n A \u003ci\u003eproxy instance\u003c/i\u003e is an instance of a proxy class.\n\n Each proxy instance has an associated \u003ci\u003einvocation handler\u003c/i\u003e\n object, which implements the interface {@link InvocationHandler}.\n A method invocation on a proxy instance through one of its proxy\n interfaces will be dispatched to the {@link InvocationHandler#invoke\n invoke} method of the instance\u0027s invocation handler, passing the proxy\n instance, a {@code java.lang.reflect.Method} object identifying\n the method that was invoked, and an array of type {@code Object}\n containing the arguments.  The invocation handler processes the\n encoded method invocation as appropriate and the result that it\n returns will be returned as the result of the method invocation on\n the proxy instance.\n\n \u003cp\u003eA proxy class has the following properties:\n\n \u003cul\u003e\n \u003cli\u003eProxy classes are \u003cem\u003epublic, final, and not abstract\u003c/em\u003e if\n all proxy interfaces are public.\u003c/li\u003e\n\n \u003cli\u003eProxy classes are \u003cem\u003enon-public, final, and not abstract\u003c/em\u003e if\n any of the proxy interfaces is non-public.\u003c/li\u003e\n\n \u003cli\u003eThe unqualified name of a proxy class is unspecified.  The space\n of class names that begin with the string {@code \"$Proxy\"}\n should be, however, reserved for proxy classes.\n\n \u003cli\u003eA proxy class extends {@code java.lang.reflect.Proxy}.\n\n \u003cli\u003eA proxy class implements exactly the interfaces specified at its\n creation, in the same order.\n\n \u003cli\u003eIf a proxy class implements a non-public interface, then it will\n be defined in the same package as that interface.  Otherwise, the\n package of a proxy class is also unspecified.  Note that package\n sealing will not prevent a proxy class from being successfully defined\n in a particular package at runtime, and neither will classes already\n defined by the same class loader and the same package with particular\n signers.\n\n \u003cli\u003eSince a proxy class implements all of the interfaces specified at\n its creation, invoking {@code getInterfaces} on its\n {@code Class} object will return an array containing the same\n list of interfaces (in the order specified at its creation), invoking\n {@code getMethods} on its {@code Class} object will return\n an array of {@code Method} objects that include all of the\n methods in those interfaces, and invoking {@code getMethod} will\n find methods in the proxy interfaces as would be expected.\n\n \u003cli\u003eThe {@link Proxy#isProxyClass Proxy.isProxyClass} method will\n return true if it is passed a proxy class-- a class returned by\n {@code Proxy.getProxyClass} or the class of an object returned by\n {@code Proxy.newProxyInstance}-- and false otherwise.\n\n \u003cli\u003eThe {@code java.security.ProtectionDomain} of a proxy class\n is the same as that of system classes loaded by the bootstrap class\n loader, such as {@code java.lang.Object}, because the code for a\n proxy class is generated by trusted system code.  This protection\n domain will typically be granted\n {@code java.security.AllPermission}.\n\n \u003cli\u003eEach proxy class has one public constructor that takes one argument,\n an implementation of the interface {@link InvocationHandler}, to set\n the invocation handler for a proxy instance.  Rather than having to use\n the reflection API to access the public constructor, a proxy instance\n can be also be created by calling the {@link Proxy#newProxyInstance\n Proxy.newProxyInstance} method, which combines the actions of calling\n {@link Proxy#getProxyClass Proxy.getProxyClass} with invoking the\n constructor with an invocation handler.\n \u003c/ul\u003e\n\n \u003cp\u003eA proxy instance has the following properties:\n\n \u003cul\u003e\n \u003cli\u003eGiven a proxy instance {@code proxy} and one of the\n interfaces implemented by its proxy class {@code Foo}, the\n following expression will return true:\n \u003cpre\u003e\n     {@code proxy instanceof Foo}\n \u003c/pre\u003e\n and the following cast operation will succeed (rather than throwing\n a {@code ClassCastException}):\n \u003cpre\u003e\n     {@code (Foo) proxy}\n \u003c/pre\u003e\n\n \u003cli\u003eEach proxy instance has an associated invocation handler, the one\n that was passed to its constructor.  The static\n {@link Proxy#getInvocationHandler Proxy.getInvocationHandler} method\n will return the invocation handler associated with the proxy instance\n passed as its argument.\n\n \u003cli\u003eAn interface method invocation on a proxy instance will be\n encoded and dispatched to the invocation handler\u0027s {@link\n InvocationHandler#invoke invoke} method as described in the\n documentation for that method.\n\n \u003cli\u003eAn invocation of the {@code hashCode},\n {@code equals}, or {@code toString} methods declared in\n {@code java.lang.Object} on a proxy instance will be encoded and\n dispatched to the invocation handler\u0027s {@code invoke} method in\n the same manner as interface method invocations are encoded and\n dispatched, as described above.  The declaring class of the\n {@code Method} object passed to {@code invoke} will be\n {@code java.lang.Object}.  Other public methods of a proxy\n instance inherited from {@code java.lang.Object} are not\n overridden by a proxy class, so invocations of those methods behave\n like they do for instances of {@code java.lang.Object}.\n \u003c/ul\u003e\n\n \u003ch3\u003eMethods Duplicated in Multiple Proxy Interfaces\u003c/h3\u003e\n\n \u003cp\u003eWhen two or more interfaces of a proxy class contain a method with\n the same name and parameter signature, the order of the proxy class\u0027s\n interfaces becomes significant.  When such a \u003ci\u003eduplicate method\u003c/i\u003e\n is invoked on a proxy instance, the {@code Method} object passed\n to the invocation handler will not necessarily be the one whose\n declaring class is assignable from the reference type of the interface\n that the proxy\u0027s method was invoked through.  This limitation exists\n because the corresponding method implementation in the generated proxy\n class cannot determine which interface it was invoked through.\n Therefore, when a duplicate method is invoked on a proxy instance,\n the {@code Method} object for the method in the foremost interface\n that contains the method (either directly or inherited through a\n superinterface) in the proxy class\u0027s list of interfaces is passed to\n the invocation handler\u0027s {@code invoke} method, regardless of the\n reference type through which the method invocation occurred.\n\n \u003cp\u003eIf a proxy interface contains a method with the same name and\n parameter signature as the {@code hashCode}, {@code equals},\n or {@code toString} methods of {@code java.lang.Object},\n when such a method is invoked on a proxy instance, the\n {@code Method} object passed to the invocation handler will have\n {@code java.lang.Object} as its declaring class.  In other words,\n the public, non-final methods of {@code java.lang.Object}\n logically precede all of the proxy interfaces for the determination of\n which {@code Method} object to pass to the invocation handler.\n\n \u003cp\u003eNote also that when a duplicate method is dispatched to an\n invocation handler, the {@code invoke} method may only throw\n checked exception types that are assignable to one of the exception\n types in the {@code throws} clause of the method in \u003ci\u003eall\u003c/i\u003e of\n the proxy interfaces that it can be invoked through.  If the\n {@code invoke} method throws a checked exception that is not\n assignable to any of the exception types declared by the method in one\n of the proxy interfaces that it can be invoked through, then an\n unchecked {@code UndeclaredThrowableException} will be thrown by\n the invocation on the proxy instance.  This restriction means that not\n all of the exception types returned by invoking\n {@code getExceptionTypes} on the {@code Method} object\n passed to the {@code invoke} method can necessarily be thrown\n successfully by the {@code invoke} method.","isClass":true,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":false,"isOrdinaryClass":true,"isPrimitive":false,"simpleName":"Proxy","qualifiedName":"java.lang.reflect.Proxy","dimension":"","elementType":{},"package":"java.lang.reflect","superclass":"java.lang.Object","interfaces":["java.io.Serializable"],"isAbstract":false,"isStatic":false,"since":"1.3","innerClasses":[],"isInnerClass":false,"constructors":[],"fields":[],"methods":[{"name":"getProxyClass","comment":"Returns the {@code java.lang.Class} object for a proxy class\n given a class loader and an array of interfaces.  The proxy class\n will be defined by the specified class loader and will implement\n all of the supplied interfaces.  If any of the given interfaces\n is non-public, the proxy class will be non-public. If a proxy class\n for the same permutation of interfaces has already been defined by the\n class loader, then the existing proxy class will be returned; otherwise,\n a proxy class for those interfaces will be generated dynamically\n and defined by the class loader.\n\n \u003cp\u003eThere are several restrictions on the parameters that may be\n passed to {@code Proxy.getProxyClass}:\n\n \u003cul\u003e\n \u003cli\u003eAll of the {@code Class} objects in the\n {@code interfaces} array must represent interfaces, not\n classes or primitive types.\n\n \u003cli\u003eNo two elements in the {@code interfaces} array may\n refer to identical {@code Class} objects.\n\n \u003cli\u003eAll of the interface types must be visible by name through the\n specified class loader.  In other words, for class loader\n {@code cl} and every interface {@code i}, the following\n expression must be true:\n \u003cpre\u003e\n     Class.forName(i.getName(), false, cl) \u003d\u003d i\n \u003c/pre\u003e\n\n \u003cli\u003eAll non-public interfaces must be in the same package;\n otherwise, it would not be possible for the proxy class to\n implement all of the interfaces, regardless of what package it is\n defined in.\n\n \u003cli\u003eFor any set of member methods of the specified interfaces\n that have the same signature:\n \u003cul\u003e\n \u003cli\u003eIf the return type of any of the methods is a primitive\n type or void, then all of the methods must have that same\n return type.\n \u003cli\u003eOtherwise, one of the methods must have a return type that\n is assignable to all of the return types of the rest of the\n methods.\n \u003c/ul\u003e\n\n \u003cli\u003eThe resulting proxy class must not exceed any limits imposed\n on classes by the virtual machine.  For example, the VM may limit\n the number of interfaces that a class may implement to 65535; in\n that case, the size of the {@code interfaces} array must not\n exceed 65535.\n \u003c/ul\u003e\n\n \u003cp\u003eIf any of these restrictions are violated,\n {@code Proxy.getProxyClass} will throw an\n {@code IllegalArgumentException}.  If the {@code interfaces}\n array argument or any of its elements are {@code null}, a\n {@code NullPointerException} will be thrown.\n\n \u003cp\u003eNote that the order of the specified proxy interfaces is\n significant: two requests for a proxy class with the same combination\n of interfaces but in a different order will result in two distinct\n proxy classes.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.lang.ClassLoader, java.lang.Class\u003c?\u003e...)","flatSignature":"(ClassLoader, Class\u003c?\u003e...)","returnType":{"isPrimitive":false,"simpleName":"Class","qualifiedName":"java.lang.Class","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"loader","type":{"isPrimitive":false,"simpleName":"ClassLoader","qualifiedName":"java.lang.ClassLoader","dimension":"","elementType":{}}},{"name":"interfaces","type":{"isPrimitive":false,"simpleName":"Class","qualifiedName":"java.lang.Class","dimension":"[]","elementType":{"isPrimitive":false,"simpleName":"Class","qualifiedName":"java.lang.Class","dimension":"","elementType":{}}}}],"typeParameters":[]},{"name":"newProxyInstance","comment":"Returns an instance of a proxy class for the specified interfaces\n that dispatches method invocations to the specified invocation\n handler.\n\n \u003cp\u003e{@code Proxy.newProxyInstance} throws\n {@code IllegalArgumentException} for the same reasons that\n {@code Proxy.getProxyClass} does.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.lang.ClassLoader, java.lang.Class\u003c?\u003e[], java.lang.reflect.InvocationHandler)","flatSignature":"(ClassLoader, Class\u003c?\u003e[], InvocationHandler)","returnType":{"isPrimitive":false,"simpleName":"Object","qualifiedName":"java.lang.Object","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"loader","type":{"isPrimitive":false,"simpleName":"ClassLoader","qualifiedName":"java.lang.ClassLoader","dimension":"","elementType":{}}},{"name":"interfaces","type":{"isPrimitive":false,"simpleName":"Class","qualifiedName":"java.lang.Class","dimension":"[]","elementType":{"isPrimitive":false,"simpleName":"Class","qualifiedName":"java.lang.Class","dimension":"","elementType":{}}}},{"name":"h","type":{"isPrimitive":false,"simpleName":"InvocationHandler","qualifiedName":"java.lang.reflect.InvocationHandler","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"isProxyClass","comment":"Returns true if and only if the specified class was dynamically\n generated to be a proxy class using the {@code getProxyClass}\n method or the {@code newProxyInstance} method.\n\n \u003cp\u003eThe reliability of this method is important for the ability\n to use it to make security decisions, so its implementation should\n not just test if the class in question extends {@code Proxy}.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.lang.Class\u003c?\u003e)","flatSignature":"(Class\u003c?\u003e)","returnType":{"isPrimitive":true,"simpleName":"boolean","qualifiedName":"boolean","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"cl","type":{"isPrimitive":false,"simpleName":"Class","qualifiedName":"java.lang.Class","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"getInvocationHandler","comment":"Returns the invocation handler for the specified proxy instance.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.lang.Object)","flatSignature":"(Object)","returnType":{"isPrimitive":false,"simpleName":"InvocationHandler","qualifiedName":"java.lang.reflect.InvocationHandler","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"proxy","type":{"isPrimitive":false,"simpleName":"Object","qualifiedName":"java.lang.Object","dimension":"","elementType":{}}}],"typeParameters":[]}],"typeParameters":[],"enumConstants":[]}