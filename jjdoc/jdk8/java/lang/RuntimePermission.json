{"name":"RuntimePermission","comment":"This class is for runtime permissions. A RuntimePermission\n contains a name (also referred to as a \"target name\") but\n no actions list; you either have the named permission\n or you don\u0027t.\n\n \u003cP\u003e\n The target name is the name of the runtime permission (see below). The\n naming convention follows the  hierarchical property naming convention.\n Also, an asterisk\n may appear at the end of the name, following a \".\", or by itself, to\n signify a wildcard match. For example: \"loadLibrary.*\" and \"*\" signify a\n wildcard match, while \"*loadLibrary\" and \"a*b\" do not.\n \u003cP\u003e\n The following table lists all the possible RuntimePermission target names,\n and for each provides a description of what the permission allows\n and a discussion of the risks of granting code the permission.\n\n \u003ctable border\u003d1 cellpadding\u003d5 summary\u003d\"permission target name,\n  what the target allows,and associated risks\"\u003e\n \u003ctr\u003e\n \u003cth\u003ePermission Target Name\u003c/th\u003e\n \u003cth\u003eWhat the Permission Allows\u003c/th\u003e\n \u003cth\u003eRisks of Allowing this Permission\u003c/th\u003e\n \u003c/tr\u003e\n\n \u003ctr\u003e\n   \u003ctd\u003ecreateClassLoader\u003c/td\u003e\n   \u003ctd\u003eCreation of a class loader\u003c/td\u003e\n   \u003ctd\u003eThis is an extremely dangerous permission to grant.\n Malicious applications that can instantiate their own class\n loaders could then load their own rogue classes into the system.\n These newly loaded classes could be placed into any protection\n domain by the class loader, thereby automatically granting the\n classes the permissions for that domain.\u003c/td\u003e\n \u003c/tr\u003e\n\n \u003ctr\u003e\n   \u003ctd\u003egetClassLoader\u003c/td\u003e\n   \u003ctd\u003eRetrieval of a class loader (e.g., the class loader for the calling\n class)\u003c/td\u003e\n   \u003ctd\u003eThis would grant an attacker permission to get the\n class loader for a particular class. This is dangerous because\n having access to a class\u0027s class loader allows the attacker to\n load other classes available to that class loader. The attacker\n would typically otherwise not have access to those classes.\u003c/td\u003e\n \u003c/tr\u003e\n\n \u003ctr\u003e\n   \u003ctd\u003esetContextClassLoader\u003c/td\u003e\n   \u003ctd\u003eSetting of the context class loader used by a thread\u003c/td\u003e\n   \u003ctd\u003eThe context class loader is used by system code and extensions\n when they need to lookup resources that might not exist in the system\n class loader. Granting setContextClassLoader permission would allow\n code to change which context class loader is used\n for a particular thread, including system threads.\u003c/td\u003e\n \u003c/tr\u003e\n\n \u003ctr\u003e\n   \u003ctd\u003eenableContextClassLoaderOverride\u003c/td\u003e\n   \u003ctd\u003eSubclass implementation of the thread context class loader methods\u003c/td\u003e\n   \u003ctd\u003eThe context class loader is used by system code and extensions\n when they need to lookup resources that might not exist in the system\n class loader. Granting enableContextClassLoaderOverride permission would allow\n a subclass of Thread to override the methods that are used\n to get or set the context class loader for a particular thread.\u003c/td\u003e\n \u003c/tr\u003e\n\n \u003ctr\u003e\n   \u003ctd\u003ecloseClassLoader\u003c/td\u003e\n   \u003ctd\u003eClosing of a ClassLoader\u003c/td\u003e\n   \u003ctd\u003eGranting this permission allows code to close any URLClassLoader\n that it has a reference to.\u003c/td\u003e\n \u003c/tr\u003e\n\n \u003ctr\u003e\n   \u003ctd\u003esetSecurityManager\u003c/td\u003e\n   \u003ctd\u003eSetting of the security manager (possibly replacing an existing one)\n \u003c/td\u003e\n   \u003ctd\u003eThe security manager is a class that allows\n applications to implement a security policy. Granting the setSecurityManager\n permission would allow code to change which security manager is used by\n installing a different, possibly less restrictive security manager,\n thereby bypassing checks that would have been enforced by the original\n security manager.\u003c/td\u003e\n \u003c/tr\u003e\n\n \u003ctr\u003e\n   \u003ctd\u003ecreateSecurityManager\u003c/td\u003e\n   \u003ctd\u003eCreation of a new security manager\u003c/td\u003e\n   \u003ctd\u003eThis gives code access to protected, sensitive methods that may\n disclose information about other classes or the execution stack.\u003c/td\u003e\n \u003c/tr\u003e\n\n \u003ctr\u003e\n   \u003ctd\u003egetenv.{variable name}\u003c/td\u003e\n   \u003ctd\u003eReading of the value of the specified environment variable\u003c/td\u003e\n   \u003ctd\u003eThis would allow code to read the value, or determine the\n       existence, of a particular environment variable.  This is\n       dangerous if the variable contains confidential data.\u003c/td\u003e\n \u003c/tr\u003e\n\n \u003ctr\u003e\n   \u003ctd\u003eexitVM.{exit status}\u003c/td\u003e\n   \u003ctd\u003eHalting of the Java Virtual Machine with the specified exit status\u003c/td\u003e\n   \u003ctd\u003eThis allows an attacker to mount a denial-of-service attack\n by automatically forcing the virtual machine to halt.\n Note: The \"exitVM.*\" permission is automatically granted to all code\n loaded from the application class path, thus enabling applications\n to terminate themselves. Also, the \"exitVM\" permission is equivalent to\n \"exitVM.*\".\u003c/td\u003e\n \u003c/tr\u003e\n\n \u003ctr\u003e\n   \u003ctd\u003eshutdownHooks\u003c/td\u003e\n   \u003ctd\u003eRegistration and cancellation of virtual-machine shutdown hooks\u003c/td\u003e\n   \u003ctd\u003eThis allows an attacker to register a malicious shutdown\n hook that interferes with the clean shutdown of the virtual machine.\u003c/td\u003e\n \u003c/tr\u003e\n\n \u003ctr\u003e\n   \u003ctd\u003esetFactory\u003c/td\u003e\n   \u003ctd\u003eSetting of the socket factory used by ServerSocket or Socket,\n or of the stream handler factory used by URL\u003c/td\u003e\n   \u003ctd\u003eThis allows code to set the actual implementation\n for the socket, server socket, stream handler, or RMI socket factory.\n An attacker may set a faulty implementation which mangles the data\n stream.\u003c/td\u003e\n \u003c/tr\u003e\n\n \u003ctr\u003e\n   \u003ctd\u003esetIO\u003c/td\u003e\n   \u003ctd\u003eSetting of System.out, System.in, and System.err\u003c/td\u003e\n   \u003ctd\u003eThis allows changing the value of the standard system streams.\n An attacker may change System.in to monitor and\n steal user input, or may set System.err to a \"null\" OutputStream,\n which would hide any error messages sent to System.err. \u003c/td\u003e\n \u003c/tr\u003e\n\n \u003ctr\u003e\n   \u003ctd\u003emodifyThread\u003c/td\u003e\n   \u003ctd\u003eModification of threads, e.g., via calls to Thread\n \u003ctt\u003einterrupt\u003c/tt\u003e, \u003ctt\u003estop\u003c/tt\u003e, \u003ctt\u003esuspend\u003c/tt\u003e,\n \u003ctt\u003eresume\u003c/tt\u003e, \u003ctt\u003esetDaemon\u003c/tt\u003e, \u003ctt\u003esetPriority\u003c/tt\u003e,\n \u003ctt\u003esetName\u003c/tt\u003e and \u003ctt\u003esetUncaughtExceptionHandler\u003c/tt\u003e\n methods\u003c/td\u003e\n \u003ctd\u003eThis allows an attacker to modify the behaviour of\n any thread in the system.\u003c/td\u003e\n \u003c/tr\u003e\n\n \u003ctr\u003e\n   \u003ctd\u003estopThread\u003c/td\u003e\n   \u003ctd\u003eStopping of threads via calls to the Thread \u003ccode\u003estop\u003c/code\u003e\n method\u003c/td\u003e\n   \u003ctd\u003eThis allows code to stop any thread in the system provided that it is\n already granted permission to access that thread.\n This poses as a threat, because that code may corrupt the system by\n killing existing threads.\u003c/td\u003e\n \u003c/tr\u003e\n\n \u003ctr\u003e\n   \u003ctd\u003emodifyThreadGroup\u003c/td\u003e\n   \u003ctd\u003emodification of thread groups, e.g., via calls to ThreadGroup\n \u003ccode\u003edestroy\u003c/code\u003e, \u003ccode\u003egetParent\u003c/code\u003e, \u003ccode\u003eresume\u003c/code\u003e,\n \u003ccode\u003esetDaemon\u003c/code\u003e, \u003ccode\u003esetMaxPriority\u003c/code\u003e, \u003ccode\u003estop\u003c/code\u003e,\n and \u003ccode\u003esuspend\u003c/code\u003e methods\u003c/td\u003e\n   \u003ctd\u003eThis allows an attacker to create thread groups and\n set their run priority.\u003c/td\u003e\n \u003c/tr\u003e\n\n \u003ctr\u003e\n   \u003ctd\u003egetProtectionDomain\u003c/td\u003e\n   \u003ctd\u003eRetrieval of the ProtectionDomain for a class\u003c/td\u003e\n   \u003ctd\u003eThis allows code to obtain policy information\n for a particular code source. While obtaining policy information\n does not compromise the security of the system, it does give\n attackers additional information, such as local file names for\n example, to better aim an attack.\u003c/td\u003e\n \u003c/tr\u003e\n\n \u003ctr\u003e\n   \u003ctd\u003egetFileSystemAttributes\u003c/td\u003e\n   \u003ctd\u003eRetrieval of file system attributes\u003c/td\u003e\n   \u003ctd\u003eThis allows code to obtain file system information such as disk usage\n       or disk space available to the caller.  This is potentially dangerous\n       because it discloses information about the system hardware\n       configuration and some information about the caller\u0027s privilege to\n       write files.\u003c/td\u003e\n \u003c/tr\u003e\n\n \u003ctr\u003e\n   \u003ctd\u003ereadFileDescriptor\u003c/td\u003e\n   \u003ctd\u003eReading of file descriptors\u003c/td\u003e\n   \u003ctd\u003eThis would allow code to read the particular file associated\n       with the file descriptor read. This is dangerous if the file\n       contains confidential data.\u003c/td\u003e\n \u003c/tr\u003e\n\n \u003ctr\u003e\n   \u003ctd\u003ewriteFileDescriptor\u003c/td\u003e\n   \u003ctd\u003eWriting to file descriptors\u003c/td\u003e\n   \u003ctd\u003eThis allows code to write to a particular file associated\n       with the descriptor. This is dangerous because it may allow\n       malicious code to plant viruses or at the very least, fill up\n       your entire disk.\u003c/td\u003e\n \u003c/tr\u003e\n\n \u003ctr\u003e\n   \u003ctd\u003eloadLibrary.{library name}\u003c/td\u003e\n   \u003ctd\u003eDynamic linking of the specified library\u003c/td\u003e\n   \u003ctd\u003eIt is dangerous to allow an applet permission to load native code\n libraries, because the Java security architecture is not designed to and\n does not prevent malicious behavior at the level of native code.\u003c/td\u003e\n \u003c/tr\u003e\n\n \u003ctr\u003e\n   \u003ctd\u003eaccessClassInPackage.{package name}\u003c/td\u003e\n   \u003ctd\u003eAccess to the specified package via a class loader\u0027s\n \u003ccode\u003eloadClass\u003c/code\u003e method when that class loader calls\n the SecurityManager \u003ccode\u003echeckPackageAccess\u003c/code\u003e method\u003c/td\u003e\n   \u003ctd\u003eThis gives code access to classes in packages\n to which it normally does not have access. Malicious code\n may use these classes to help in its attempt to compromise\n security in the system.\u003c/td\u003e\n \u003c/tr\u003e\n\n \u003ctr\u003e\n   \u003ctd\u003edefineClassInPackage.{package name}\u003c/td\u003e\n   \u003ctd\u003eDefinition of classes in the specified package, via a class\n loader\u0027s \u003ccode\u003edefineClass\u003c/code\u003e method when that class loader calls\n the SecurityManager \u003ccode\u003echeckPackageDefinition\u003c/code\u003e method.\u003c/td\u003e\n   \u003ctd\u003eThis grants code permission to define a class\n in a particular package. This is dangerous because malicious\n code with this permission may define rogue classes in\n trusted packages like \u003ccode\u003ejava.security\u003c/code\u003e or \u003ccode\u003ejava.lang\u003c/code\u003e,\n for example.\u003c/td\u003e\n \u003c/tr\u003e\n\n \u003ctr\u003e\n   \u003ctd\u003eaccessDeclaredMembers\u003c/td\u003e\n   \u003ctd\u003eAccess to the declared members of a class\u003c/td\u003e\n   \u003ctd\u003eThis grants code permission to query a class for its public,\n protected, default (package) access, and private fields and/or\n methods. Although the code would have\n access to the private and protected field and method names, it would not\n have access to the private/protected field data and would not be able\n to invoke any private methods. Nevertheless, malicious code\n may use this information to better aim an attack.\n Additionally, it may invoke any public methods and/or access public fields\n in the class.  This could be dangerous if\n the code would normally not be able to invoke those methods and/or\n access the fields  because\n it can\u0027t cast the object to the class/interface with those methods\n and fields.\n\u003c/td\u003e\n \u003c/tr\u003e\n \u003ctr\u003e\n   \u003ctd\u003equeuePrintJob\u003c/td\u003e\n   \u003ctd\u003eInitiation of a print job request\u003c/td\u003e\n   \u003ctd\u003eThis could print sensitive information to a printer,\n or simply waste paper.\u003c/td\u003e\n \u003c/tr\u003e\n\n \u003ctr\u003e\n   \u003ctd\u003egetStackTrace\u003c/td\u003e\n   \u003ctd\u003eRetrieval of the stack trace information of another thread.\u003c/td\u003e\n   \u003ctd\u003eThis allows retrieval of the stack trace information of\n another thread.  This might allow malicious code to monitor the\n execution of threads and discover vulnerabilities in applications.\u003c/td\u003e\n \u003c/tr\u003e\n\n \u003ctr\u003e\n   \u003ctd\u003esetDefaultUncaughtExceptionHandler\u003c/td\u003e\n   \u003ctd\u003eSetting the default handler to be used when a thread\n   terminates abruptly due to an uncaught exception\u003c/td\u003e\n   \u003ctd\u003eThis allows an attacker to register a malicious\n   uncaught exception handler that could interfere with termination\n   of a thread\u003c/td\u003e\n \u003c/tr\u003e\n\n \u003ctr\u003e\n   \u003ctd\u003epreferences\u003c/td\u003e\n   \u003ctd\u003eRepresents the permission required to get access to the\n   java.util.prefs.Preferences implementations user or system root\n   which in turn allows retrieval or update operations within the\n   Preferences persistent backing store.) \u003c/td\u003e\n   \u003ctd\u003eThis permission allows the user to read from or write to the\n   preferences backing store if the user running the code has\n   sufficient OS privileges to read/write to that backing store.\n   The actual backing store may reside within a traditional filesystem\n   directory or within a registry depending on the platform OS\u003c/td\u003e\n \u003c/tr\u003e\n\n \u003ctr\u003e\n   \u003ctd\u003eusePolicy\u003c/td\u003e\n   \u003ctd\u003eGranting this permission disables the Java Plug-In\u0027s default\n   security prompting behavior.\u003c/td\u003e\n   \u003ctd\u003eFor more information, refer to Java Plug-In\u0027s guides, \u003ca href\u003d\n   \"../../../technotes/guides/plugin/developer_guide/security.html\"\u003e\n   Applet Security Basics\u003c/a\u003e and \u003ca href\u003d\n   \"../../../technotes/guides/plugin/developer_guide/rsa_how.html#use\"\u003e\n   usePolicy Permission\u003c/a\u003e.\u003c/td\u003e\n \u003c/tr\u003e\n \u003c/table\u003e","isClass":true,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":false,"isOrdinaryClass":true,"isPrimitive":false,"simpleName":"RuntimePermission","qualifiedName":"java.lang.RuntimePermission","dimension":"","elementType":{},"package":"java.lang","superclass":"java.security.BasicPermission","interfaces":[],"isAbstract":false,"isStatic":false,"innerClasses":[],"isInnerClass":false,"constructors":[{"name":"RuntimePermission","comment":"Creates a new RuntimePermission with the specified name.\n The name is the symbolic name of the RuntimePermission, such as\n \"exit\", \"setFactory\", etc. An asterisk\n may appear at the end of the name, following a \".\", or by itself, to\n signify a wildcard match.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":true,"isField":false,"isMethod":false,"isOrdinaryClass":false,"signature":"(java.lang.String)","flatSignature":"(String)","parameters":[{"name":"name","type":{"isPrimitive":false,"simpleName":"String","qualifiedName":"java.lang.String","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"RuntimePermission","comment":"Creates a new RuntimePermission object with the specified name.\n The name is the symbolic name of the RuntimePermission, and the\n actions String is currently unused and should be null.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":true,"isField":false,"isMethod":false,"isOrdinaryClass":false,"signature":"(java.lang.String, java.lang.String)","flatSignature":"(String, String)","parameters":[{"name":"name","type":{"isPrimitive":false,"simpleName":"String","qualifiedName":"java.lang.String","dimension":"","elementType":{}}},{"name":"actions","type":{"isPrimitive":false,"simpleName":"String","qualifiedName":"java.lang.String","dimension":"","elementType":{}}}],"typeParameters":[]}],"fields":[],"methods":[],"typeParameters":[],"enumConstants":[]}