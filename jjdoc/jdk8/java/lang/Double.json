{"name":"Double","comment":"The {@code Double} class wraps a value of the primitive type\n {@code double} in an object. An object of type\n {@code Double} contains a single field whose type is\n {@code double}.\n\n \u003cp\u003eIn addition, this class provides several methods for converting a\n {@code double} to a {@code String} and a\n {@code String} to a {@code double}, as well as other\n constants and methods useful when dealing with a\n {@code double}.","isClass":true,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":false,"isOrdinaryClass":true,"isPrimitive":false,"simpleName":"Double","qualifiedName":"java.lang.Double","dimension":"","elementType":{},"package":"java.lang","superclass":"java.lang.Number","interfaces":["java.lang.Comparable"],"isAbstract":false,"isStatic":false,"since":"JDK1.0","innerClasses":[],"isInnerClass":false,"constructors":[{"name":"Double","comment":"Constructs a newly allocated {@code Double} object that\n represents the primitive {@code double} argument.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":true,"isField":false,"isMethod":false,"isOrdinaryClass":false,"signature":"(double)","flatSignature":"(double)","parameters":[{"name":"value","type":{"isPrimitive":true,"simpleName":"double","qualifiedName":"double","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"Double","comment":"Constructs a newly allocated {@code Double} object that\n represents the floating-point value of type {@code double}\n represented by the string. The string is converted to a\n {@code double} value as if by the {@code valueOf} method.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":true,"isField":false,"isMethod":false,"isOrdinaryClass":false,"signature":"(java.lang.String)","flatSignature":"(String)","parameters":[{"name":"s","type":{"isPrimitive":false,"simpleName":"String","qualifiedName":"java.lang.String","dimension":"","elementType":{}}}],"typeParameters":[]}],"fields":[{"name":"POSITIVE_INFINITY","comment":"A constant holding the positive infinity of type\n {@code double}. It is equal to the value returned by\n {@code Double.longBitsToDouble(0x7ff0000000000000L)}.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":true,"isMethod":false,"isOrdinaryClass":false,"type":{"isPrimitive":true,"simpleName":"double","qualifiedName":"double","dimension":"","elementType":{}},"isStatic":true,"constantValue":"1d/0d"},{"name":"NEGATIVE_INFINITY","comment":"A constant holding the negative infinity of type\n {@code double}. It is equal to the value returned by\n {@code Double.longBitsToDouble(0xfff0000000000000L)}.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":true,"isMethod":false,"isOrdinaryClass":false,"type":{"isPrimitive":true,"simpleName":"double","qualifiedName":"double","dimension":"","elementType":{}},"isStatic":true,"constantValue":"-1d/0d"},{"name":"NaN","comment":"A constant holding a Not-a-Number (NaN) value of type\n {@code double}. It is equivalent to the value returned by\n {@code Double.longBitsToDouble(0x7ff8000000000000L)}.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":true,"isMethod":false,"isOrdinaryClass":false,"type":{"isPrimitive":true,"simpleName":"double","qualifiedName":"double","dimension":"","elementType":{}},"isStatic":true,"constantValue":"0d/0d"},{"name":"MAX_VALUE","comment":"A constant holding the largest positive finite value of type\n {@code double},\n (2-2\u003csup\u003e-52\u003c/sup\u003e)\u0026middot;2\u003csup\u003e1023\u003c/sup\u003e.  It is equal to\n the hexadecimal floating-point literal\n {@code 0x1.fffffffffffffP+1023} and also equal to\n {@code Double.longBitsToDouble(0x7fefffffffffffffL)}.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":true,"isMethod":false,"isOrdinaryClass":false,"type":{"isPrimitive":true,"simpleName":"double","qualifiedName":"double","dimension":"","elementType":{}},"isStatic":true,"constantValue":"1.7976931348623157E308"},{"name":"MIN_NORMAL","comment":"A constant holding the smallest positive normal value of type\n {@code double}, 2\u003csup\u003e-1022\u003c/sup\u003e.  It is equal to the\n hexadecimal floating-point literal {@code 0x1.0p-1022} and also\n equal to {@code Double.longBitsToDouble(0x0010000000000000L)}.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":true,"isMethod":false,"isOrdinaryClass":false,"type":{"isPrimitive":true,"simpleName":"double","qualifiedName":"double","dimension":"","elementType":{}},"isStatic":true,"constantValue":"2.2250738585072014E-308"},{"name":"MIN_VALUE","comment":"A constant holding the smallest positive nonzero value of type\n {@code double}, 2\u003csup\u003e-1074\u003c/sup\u003e. It is equal to the\n hexadecimal floating-point literal\n {@code 0x0.0000000000001P-1022} and also equal to\n {@code Double.longBitsToDouble(0x1L)}.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":true,"isMethod":false,"isOrdinaryClass":false,"type":{"isPrimitive":true,"simpleName":"double","qualifiedName":"double","dimension":"","elementType":{}},"isStatic":true,"constantValue":"4.9E-324"},{"name":"MAX_EXPONENT","comment":"Maximum exponent a finite {@code double} variable may have.\n It is equal to the value returned by\n {@code Math.getExponent(Double.MAX_VALUE)}.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":true,"isMethod":false,"isOrdinaryClass":false,"type":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}},"isStatic":true,"constantValue":"1023"},{"name":"MIN_EXPONENT","comment":"Minimum exponent a normalized {@code double} variable may\n have.  It is equal to the value returned by\n {@code Math.getExponent(Double.MIN_NORMAL)}.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":true,"isMethod":false,"isOrdinaryClass":false,"type":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}},"isStatic":true,"constantValue":"-1022"},{"name":"SIZE","comment":"The number of bits used to represent a {@code double} value.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":true,"isMethod":false,"isOrdinaryClass":false,"type":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}},"isStatic":true,"constantValue":"64"},{"name":"BYTES","comment":"The number of bytes used to represent a {@code double} value.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":true,"isMethod":false,"isOrdinaryClass":false,"type":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}},"isStatic":true,"constantValue":"8"},{"name":"TYPE","comment":"The {@code Class} instance representing the primitive type\n {@code double}.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":true,"isMethod":false,"isOrdinaryClass":false,"type":{"isPrimitive":false,"simpleName":"Class","qualifiedName":"java.lang.Class","dimension":"","elementType":{}},"isStatic":true}],"methods":[{"name":"toString","comment":"Returns a string representation of the {@code double}\n argument. All characters mentioned below are ASCII characters.\n \u003cul\u003e\n \u003cli\u003eIf the argument is NaN, the result is the string\n     \"{@code NaN}\".\n \u003cli\u003eOtherwise, the result is a string that represents the sign and\n magnitude (absolute value) of the argument. If the sign is negative,\n the first character of the result is \u0027{@code -}\u0027\n ({@code \u0027\\u002D\u0027}); if the sign is positive, no sign character\n appears in the result. As for the magnitude \u003ci\u003em\u003c/i\u003e:\n \u003cul\u003e\n \u003cli\u003eIf \u003ci\u003em\u003c/i\u003e is infinity, it is represented by the characters\n {@code \"Infinity\"}; thus, positive infinity produces the result\n {@code \"Infinity\"} and negative infinity produces the result\n {@code \"-Infinity\"}.\n\n \u003cli\u003eIf \u003ci\u003em\u003c/i\u003e is zero, it is represented by the characters\n {@code \"0.0\"}; thus, negative zero produces the result\n {@code \"-0.0\"} and positive zero produces the result\n {@code \"0.0\"}.\n\n \u003cli\u003eIf \u003ci\u003em\u003c/i\u003e is greater than or equal to 10\u003csup\u003e-3\u003c/sup\u003e but less\n than 10\u003csup\u003e7\u003c/sup\u003e, then it is represented as the integer part of\n \u003ci\u003em\u003c/i\u003e, in decimal form with no leading zeroes, followed by\n \u0027{@code .}\u0027 ({@code \u0027\\u002E\u0027}), followed by one or\n more decimal digits representing the fractional part of \u003ci\u003em\u003c/i\u003e.\n\n \u003cli\u003eIf \u003ci\u003em\u003c/i\u003e is less than 10\u003csup\u003e-3\u003c/sup\u003e or greater than or\n equal to 10\u003csup\u003e7\u003c/sup\u003e, then it is represented in so-called\n \"computerized scientific notation.\" Let \u003ci\u003en\u003c/i\u003e be the unique\n integer such that 10\u003csup\u003e\u003ci\u003en\u003c/i\u003e\u003c/sup\u003e \u0026le; \u003ci\u003em\u003c/i\u003e {@literal \u003c}\n 10\u003csup\u003e\u003ci\u003en\u003c/i\u003e+1\u003c/sup\u003e; then let \u003ci\u003ea\u003c/i\u003e be the\n mathematically exact quotient of \u003ci\u003em\u003c/i\u003e and\n 10\u003csup\u003e\u003ci\u003en\u003c/i\u003e\u003c/sup\u003e so that 1 \u0026le; \u003ci\u003ea\u003c/i\u003e {@literal \u003c} 10. The\n magnitude is then represented as the integer part of \u003ci\u003ea\u003c/i\u003e,\n as a single decimal digit, followed by \u0027{@code .}\u0027\n ({@code \u0027\\u002E\u0027}), followed by decimal digits\n representing the fractional part of \u003ci\u003ea\u003c/i\u003e, followed by the\n letter \u0027{@code E}\u0027 ({@code \u0027\\u0045\u0027}), followed\n by a representation of \u003ci\u003en\u003c/i\u003e as a decimal integer, as\n produced by the method {@link Integer#toString(int)}.\n \u003c/ul\u003e\n \u003c/ul\u003e\n How many digits must be printed for the fractional part of\n \u003ci\u003em\u003c/i\u003e or \u003ci\u003ea\u003c/i\u003e? There must be at least one digit to represent\n the fractional part, and beyond that as many, but only as many, more\n digits as are needed to uniquely distinguish the argument value from\n adjacent values of type {@code double}. That is, suppose that\n \u003ci\u003ex\u003c/i\u003e is the exact mathematical value represented by the decimal\n representation produced by this method for a finite nonzero argument\n \u003ci\u003ed\u003c/i\u003e. Then \u003ci\u003ed\u003c/i\u003e must be the {@code double} value nearest\n to \u003ci\u003ex\u003c/i\u003e; or if two {@code double} values are equally close\n to \u003ci\u003ex\u003c/i\u003e, then \u003ci\u003ed\u003c/i\u003e must be one of them and the least\n significant bit of the significand of \u003ci\u003ed\u003c/i\u003e must be {@code 0}.\n\n \u003cp\u003eTo create localized string representations of a floating-point\n value, use subclasses of {@link java.text.NumberFormat}.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(double)","flatSignature":"(double)","returnType":{"isPrimitive":false,"simpleName":"String","qualifiedName":"java.lang.String","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"d","type":{"isPrimitive":true,"simpleName":"double","qualifiedName":"double","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"toHexString","comment":"Returns a hexadecimal string representation of the\n {@code double} argument. All characters mentioned below\n are ASCII characters.\n\n \u003cul\u003e\n \u003cli\u003eIf the argument is NaN, the result is the string\n     \"{@code NaN}\".\n \u003cli\u003eOtherwise, the result is a string that represents the sign\n and magnitude of the argument. If the sign is negative, the\n first character of the result is \u0027{@code -}\u0027\n ({@code \u0027\\u002D\u0027}); if the sign is positive, no sign\n character appears in the result. As for the magnitude \u003ci\u003em\u003c/i\u003e:\n\n \u003cul\u003e\n \u003cli\u003eIf \u003ci\u003em\u003c/i\u003e is infinity, it is represented by the string\n {@code \"Infinity\"}; thus, positive infinity produces the\n result {@code \"Infinity\"} and negative infinity produces\n the result {@code \"-Infinity\"}.\n\n \u003cli\u003eIf \u003ci\u003em\u003c/i\u003e is zero, it is represented by the string\n {@code \"0x0.0p0\"}; thus, negative zero produces the result\n {@code \"-0x0.0p0\"} and positive zero produces the result\n {@code \"0x0.0p0\"}.\n\n \u003cli\u003eIf \u003ci\u003em\u003c/i\u003e is a {@code double} value with a\n normalized representation, substrings are used to represent the\n significand and exponent fields.  The significand is\n represented by the characters {@code \"0x1.\"}\n followed by a lowercase hexadecimal representation of the rest\n of the significand as a fraction.  Trailing zeros in the\n hexadecimal representation are removed unless all the digits\n are zero, in which case a single zero is used. Next, the\n exponent is represented by {@code \"p\"} followed\n by a decimal string of the unbiased exponent as if produced by\n a call to {@link Integer#toString(int) Integer.toString} on the\n exponent value.\n\n \u003cli\u003eIf \u003ci\u003em\u003c/i\u003e is a {@code double} value with a subnormal\n representation, the significand is represented by the\n characters {@code \"0x0.\"} followed by a\n hexadecimal representation of the rest of the significand as a\n fraction.  Trailing zeros in the hexadecimal representation are\n removed. Next, the exponent is represented by\n {@code \"p-1022\"}.  Note that there must be at\n least one nonzero digit in a subnormal significand.\n\n \u003c/ul\u003e\n\n \u003c/ul\u003e\n\n \u003ctable border\u003e\n \u003ccaption\u003eExamples\u003c/caption\u003e\n \u003ctr\u003e\u003cth\u003eFloating-point Value\u003c/th\u003e\u003cth\u003eHexadecimal String\u003c/th\u003e\n \u003ctr\u003e\u003ctd\u003e{@code 1.0}\u003c/td\u003e \u003ctd\u003e{@code 0x1.0p0}\u003c/td\u003e\n \u003ctr\u003e\u003ctd\u003e{@code -1.0}\u003c/td\u003e        \u003ctd\u003e{@code -0x1.0p0}\u003c/td\u003e\n \u003ctr\u003e\u003ctd\u003e{@code 2.0}\u003c/td\u003e \u003ctd\u003e{@code 0x1.0p1}\u003c/td\u003e\n \u003ctr\u003e\u003ctd\u003e{@code 3.0}\u003c/td\u003e \u003ctd\u003e{@code 0x1.8p1}\u003c/td\u003e\n \u003ctr\u003e\u003ctd\u003e{@code 0.5}\u003c/td\u003e \u003ctd\u003e{@code 0x1.0p-1}\u003c/td\u003e\n \u003ctr\u003e\u003ctd\u003e{@code 0.25}\u003c/td\u003e        \u003ctd\u003e{@code 0x1.0p-2}\u003c/td\u003e\n \u003ctr\u003e\u003ctd\u003e{@code Double.MAX_VALUE}\u003c/td\u003e\n     \u003ctd\u003e{@code 0x1.fffffffffffffp1023}\u003c/td\u003e\n \u003ctr\u003e\u003ctd\u003e{@code Minimum Normal Value}\u003c/td\u003e\n     \u003ctd\u003e{@code 0x1.0p-1022}\u003c/td\u003e\n \u003ctr\u003e\u003ctd\u003e{@code Maximum Subnormal Value}\u003c/td\u003e\n     \u003ctd\u003e{@code 0x0.fffffffffffffp-1022}\u003c/td\u003e\n \u003ctr\u003e\u003ctd\u003e{@code Double.MIN_VALUE}\u003c/td\u003e\n     \u003ctd\u003e{@code 0x0.0000000000001p-1022}\u003c/td\u003e\n \u003c/table\u003e","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(double)","flatSignature":"(double)","returnType":{"isPrimitive":false,"simpleName":"String","qualifiedName":"java.lang.String","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"d","type":{"isPrimitive":true,"simpleName":"double","qualifiedName":"double","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"valueOf","comment":"Returns a {@code Double} object holding the\n {@code double} value represented by the argument string\n {@code s}.\n\n \u003cp\u003eIf {@code s} is {@code null}, then a\n {@code NullPointerException} is thrown.\n\n \u003cp\u003eLeading and trailing whitespace characters in {@code s}\n are ignored.  Whitespace is removed as if by the {@link\n String#trim} method; that is, both ASCII space and control\n characters are removed. The rest of {@code s} should\n constitute a \u003ci\u003eFloatValue\u003c/i\u003e as described by the lexical\n syntax rules:\n\n \u003cblockquote\u003e\n \u003cdl\u003e\n \u003cdt\u003e\u003ci\u003eFloatValue:\u003c/i\u003e\n \u003cdd\u003e\u003ci\u003eSign\u003csub\u003eopt\u003c/sub\u003e\u003c/i\u003e {@code NaN}\n \u003cdd\u003e\u003ci\u003eSign\u003csub\u003eopt\u003c/sub\u003e\u003c/i\u003e {@code Infinity}\n \u003cdd\u003e\u003ci\u003eSign\u003csub\u003eopt\u003c/sub\u003e FloatingPointLiteral\u003c/i\u003e\n \u003cdd\u003e\u003ci\u003eSign\u003csub\u003eopt\u003c/sub\u003e HexFloatingPointLiteral\u003c/i\u003e\n \u003cdd\u003e\u003ci\u003eSignedInteger\u003c/i\u003e\n \u003c/dl\u003e\n\n \u003cdl\u003e\n \u003cdt\u003e\u003ci\u003eHexFloatingPointLiteral\u003c/i\u003e:\n \u003cdd\u003e \u003ci\u003eHexSignificand BinaryExponent FloatTypeSuffix\u003csub\u003eopt\u003c/sub\u003e\u003c/i\u003e\n \u003c/dl\u003e\n\n \u003cdl\u003e\n \u003cdt\u003e\u003ci\u003eHexSignificand:\u003c/i\u003e\n \u003cdd\u003e\u003ci\u003eHexNumeral\u003c/i\u003e\n \u003cdd\u003e\u003ci\u003eHexNumeral\u003c/i\u003e {@code .}\n \u003cdd\u003e{@code 0x} \u003ci\u003eHexDigits\u003csub\u003eopt\u003c/sub\u003e\n     \u003c/i\u003e{@code .}\u003ci\u003e HexDigits\u003c/i\u003e\n \u003cdd\u003e{@code 0X}\u003ci\u003e HexDigits\u003csub\u003eopt\u003c/sub\u003e\n     \u003c/i\u003e{@code .} \u003ci\u003eHexDigits\u003c/i\u003e\n \u003c/dl\u003e\n\n \u003cdl\u003e\n \u003cdt\u003e\u003ci\u003eBinaryExponent:\u003c/i\u003e\n \u003cdd\u003e\u003ci\u003eBinaryExponentIndicator SignedInteger\u003c/i\u003e\n \u003c/dl\u003e\n\n \u003cdl\u003e\n \u003cdt\u003e\u003ci\u003eBinaryExponentIndicator:\u003c/i\u003e\n \u003cdd\u003e{@code p}\n \u003cdd\u003e{@code P}\n \u003c/dl\u003e\n\n \u003c/blockquote\u003e\n\n where \u003ci\u003eSign\u003c/i\u003e, \u003ci\u003eFloatingPointLiteral\u003c/i\u003e,\n \u003ci\u003eHexNumeral\u003c/i\u003e, \u003ci\u003eHexDigits\u003c/i\u003e, \u003ci\u003eSignedInteger\u003c/i\u003e and\n \u003ci\u003eFloatTypeSuffix\u003c/i\u003e are as defined in the lexical structure\n sections of\n \u003ccite\u003eThe Java\u0026trade; Language Specification\u003c/cite\u003e,\n except that underscores are not accepted between digits.\n If {@code s} does not have the form of\n a \u003ci\u003eFloatValue\u003c/i\u003e, then a {@code NumberFormatException}\n is thrown. Otherwise, {@code s} is regarded as\n representing an exact decimal value in the usual\n \"computerized scientific notation\" or as an exact\n hexadecimal value; this exact numerical value is then\n conceptually converted to an \"infinitely precise\"\n binary value that is then rounded to type {@code double}\n by the usual round-to-nearest rule of IEEE 754 floating-point\n arithmetic, which includes preserving the sign of a zero\n value.\n\n Note that the round-to-nearest rule also implies overflow and\n underflow behaviour; if the exact value of {@code s} is large\n enough in magnitude (greater than or equal to ({@link\n #MAX_VALUE} + {@link Math#ulp(double) ulp(MAX_VALUE)}/2),\n rounding to {@code double} will result in an infinity and if the\n exact value of {@code s} is small enough in magnitude (less\n than or equal to {@link #MIN_VALUE}/2), rounding to float will\n result in a zero.\n\n Finally, after rounding a {@code Double} object representing\n this {@code double} value is returned.\n\n \u003cp\u003e To interpret localized string representations of a\n floating-point value, use subclasses of {@link\n java.text.NumberFormat}.\n\n \u003cp\u003eNote that trailing format specifiers, specifiers that\n determine the type of a floating-point literal\n ({@code 1.0f} is a {@code float} value;\n {@code 1.0d} is a {@code double} value), do\n \u003cem\u003enot\u003c/em\u003e influence the results of this method.  In other\n words, the numerical value of the input string is converted\n directly to the target floating-point type.  The two-step\n sequence of conversions, string to {@code float} followed\n by {@code float} to {@code double}, is \u003cem\u003enot\u003c/em\u003e\n equivalent to converting a string directly to\n {@code double}. For example, the {@code float}\n literal {@code 0.1f} is equal to the {@code double}\n value {@code 0.10000000149011612}; the {@code float}\n literal {@code 0.1f} represents a different numerical\n value than the {@code double} literal\n {@code 0.1}. (The numerical value 0.1 cannot be exactly\n represented in a binary floating-point number.)\n\n \u003cp\u003eTo avoid calling this method on an invalid string and having\n a {@code NumberFormatException} be thrown, the regular\n expression below can be used to screen the input string:\n\n \u003cpre\u003e{@code\n  final String Digits     \u003d \"(\\\\p{Digit}+)\";\n  final String HexDigits  \u003d \"(\\\\p{XDigit}+)\";\n  // an exponent is \u0027e\u0027 or \u0027E\u0027 followed by an optionally\n  // signed decimal integer.\n  final String Exp        \u003d \"[eE][+-]?\"+Digits;\n  final String fpRegex    \u003d\n      (\"[\\\\x00-\\\\x20]*\"+  // Optional leading \"whitespace\"\n       \"[+-]?(\" + // Optional sign character\n       \"NaN|\" +           // \"NaN\" string\n       \"Infinity|\" +      // \"Infinity\" string\n\n       // A decimal floating-point string representing a finite positive\n       // number without a leading sign has at most five basic pieces:\n       // Digits . Digits ExponentPart FloatTypeSuffix\n       //\n       // Since this method allows integer-only strings as input\n       // in addition to strings of floating-point literals, the\n       // two sub-patterns below are simplifications of the grammar\n       // productions from section 3.10.2 of\n       // The Java Language Specification.\n\n       // Digits ._opt Digits_opt ExponentPart_opt FloatTypeSuffix_opt\n       \"(((\"+Digits+\"(\\\\.)?(\"+Digits+\"?)(\"+Exp+\")?)|\"+\n\n       // . Digits ExponentPart_opt FloatTypeSuffix_opt\n       \"(\\\\.(\"+Digits+\")(\"+Exp+\")?)|\"+\n\n       // Hexadecimal strings\n       \"((\" +\n        // 0[xX] HexDigits ._opt BinaryExponent FloatTypeSuffix_opt\n        \"(0[xX]\" + HexDigits + \"(\\\\.)?)|\" +\n\n        // 0[xX] HexDigits_opt . HexDigits BinaryExponent FloatTypeSuffix_opt\n        \"(0[xX]\" + HexDigits + \"?(\\\\.)\" + HexDigits + \")\" +\n\n        \")[pP][+-]?\" + Digits + \"))\" +\n       \"[fFdD]?))\" +\n       \"[\\\\x00-\\\\x20]*\");// Optional trailing \"whitespace\"\n\n  if (Pattern.matches(fpRegex, myString))\n      Double.valueOf(myString); // Will not throw NumberFormatException\n  else {\n      // Perform suitable alternative action\n  }\n }\u003c/pre\u003e","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.lang.String)","flatSignature":"(String)","returnType":{"isPrimitive":false,"simpleName":"Double","qualifiedName":"java.lang.Double","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"s","type":{"isPrimitive":false,"simpleName":"String","qualifiedName":"java.lang.String","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"valueOf","comment":"Returns a {@code Double} instance representing the specified\n {@code double} value.\n If a new {@code Double} instance is not required, this method\n should generally be used in preference to the constructor\n {@link #Double(double)}, as this method is likely to yield\n significantly better space and time performance by caching\n frequently requested values.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(double)","flatSignature":"(double)","returnType":{"isPrimitive":false,"simpleName":"Double","qualifiedName":"java.lang.Double","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"d","type":{"isPrimitive":true,"simpleName":"double","qualifiedName":"double","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"parseDouble","comment":"Returns a new {@code double} initialized to the value\n represented by the specified {@code String}, as performed\n by the {@code valueOf} method of class\n {@code Double}.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.lang.String)","flatSignature":"(String)","returnType":{"isPrimitive":true,"simpleName":"double","qualifiedName":"double","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"s","type":{"isPrimitive":false,"simpleName":"String","qualifiedName":"java.lang.String","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"isNaN","comment":"Returns {@code true} if the specified number is a\n Not-a-Number (NaN) value, {@code false} otherwise.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(double)","flatSignature":"(double)","returnType":{"isPrimitive":true,"simpleName":"boolean","qualifiedName":"boolean","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"v","type":{"isPrimitive":true,"simpleName":"double","qualifiedName":"double","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"isInfinite","comment":"Returns {@code true} if the specified number is infinitely\n large in magnitude, {@code false} otherwise.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(double)","flatSignature":"(double)","returnType":{"isPrimitive":true,"simpleName":"boolean","qualifiedName":"boolean","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"v","type":{"isPrimitive":true,"simpleName":"double","qualifiedName":"double","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"isFinite","comment":"Returns {@code true} if the argument is a finite floating-point\n value; returns {@code false} otherwise (for NaN and infinity\n arguments).","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(double)","flatSignature":"(double)","returnType":{"isPrimitive":true,"simpleName":"boolean","qualifiedName":"boolean","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"d","type":{"isPrimitive":true,"simpleName":"double","qualifiedName":"double","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"isNaN","comment":"Returns {@code true} if this {@code Double} value is\n a Not-a-Number (NaN), {@code false} otherwise.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":true,"simpleName":"boolean","qualifiedName":"boolean","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[],"typeParameters":[]},{"name":"isInfinite","comment":"Returns {@code true} if this {@code Double} value is\n infinitely large in magnitude, {@code false} otherwise.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":true,"simpleName":"boolean","qualifiedName":"boolean","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[],"typeParameters":[]},{"name":"toString","comment":"Returns a string representation of this {@code Double} object.\n The primitive {@code double} value represented by this\n object is converted to a string exactly as if by the method\n {@code toString} of one argument.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":false,"simpleName":"String","qualifiedName":"java.lang.String","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[],"typeParameters":[]},{"name":"byteValue","comment":"Returns the value of this {@code Double} as a {@code byte}\n after a narrowing primitive conversion.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":true,"simpleName":"byte","qualifiedName":"byte","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[],"typeParameters":[]},{"name":"shortValue","comment":"Returns the value of this {@code Double} as a {@code short}\n after a narrowing primitive conversion.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":true,"simpleName":"short","qualifiedName":"short","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[],"typeParameters":[]},{"name":"intValue","comment":"Returns the value of this {@code Double} as an {@code int}\n after a narrowing primitive conversion.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[],"typeParameters":[]},{"name":"longValue","comment":"Returns the value of this {@code Double} as a {@code long}\n after a narrowing primitive conversion.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":true,"simpleName":"long","qualifiedName":"long","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[],"typeParameters":[]},{"name":"floatValue","comment":"Returns the value of this {@code Double} as a {@code float}\n after a narrowing primitive conversion.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":true,"simpleName":"float","qualifiedName":"float","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[],"typeParameters":[]},{"name":"doubleValue","comment":"Returns the {@code double} value of this {@code Double} object.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":true,"simpleName":"double","qualifiedName":"double","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[],"typeParameters":[]},{"name":"hashCode","comment":"Returns a hash code for this {@code Double} object. The\n result is the exclusive OR of the two halves of the\n {@code long} integer bit representation, exactly as\n produced by the method {@link #doubleToLongBits(double)}, of\n the primitive {@code double} value represented by this\n {@code Double} object. That is, the hash code is the value\n of the expression:\n\n \u003cblockquote\u003e\n  {@code (int)(v^(v\u003e\u003e\u003e32))}\n \u003c/blockquote\u003e\n\n where {@code v} is defined by:\n\n \u003cblockquote\u003e\n  {@code long v \u003d Double.doubleToLongBits(this.doubleValue());}\n \u003c/blockquote\u003e","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[],"typeParameters":[]},{"name":"hashCode","comment":"Returns a hash code for a {@code double} value; compatible with\n {@code Double.hashCode()}.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(double)","flatSignature":"(double)","returnType":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"value","type":{"isPrimitive":true,"simpleName":"double","qualifiedName":"double","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"equals","comment":"Compares this object against the specified object.  The result\n is {@code true} if and only if the argument is not\n {@code null} and is a {@code Double} object that\n represents a {@code double} that has the same value as the\n {@code double} represented by this object. For this\n purpose, two {@code double} values are considered to be\n the same if and only if the method {@link\n #doubleToLongBits(double)} returns the identical\n {@code long} value when applied to each.\n\n \u003cp\u003eNote that in most cases, for two instances of class\n {@code Double}, {@code d1} and {@code d2}, the\n value of {@code d1.equals(d2)} is {@code true} if and\n only if\n\n \u003cblockquote\u003e\n  {@code d1.doubleValue() \u003d\u003d d2.doubleValue()}\n \u003c/blockquote\u003e\n\n \u003cp\u003ealso has the value {@code true}. However, there are two\n exceptions:\n \u003cul\u003e\n \u003cli\u003eIf {@code d1} and {@code d2} both represent\n     {@code Double.NaN}, then the {@code equals} method\n     returns {@code true}, even though\n     {@code Double.NaN\u003d\u003dDouble.NaN} has the value\n     {@code false}.\n \u003cli\u003eIf {@code d1} represents {@code +0.0} while\n     {@code d2} represents {@code -0.0}, or vice versa,\n     the {@code equal} test has the value {@code false},\n     even though {@code +0.0\u003d\u003d-0.0} has the value {@code true}.\n \u003c/ul\u003e\n This definition allows hash tables to operate properly.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.lang.Object)","flatSignature":"(Object)","returnType":{"isPrimitive":true,"simpleName":"boolean","qualifiedName":"boolean","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[{"name":"obj","type":{"isPrimitive":false,"simpleName":"Object","qualifiedName":"java.lang.Object","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"doubleToLongBits","comment":"Returns a representation of the specified floating-point value\n according to the IEEE 754 floating-point \"double\n format\" bit layout.\n\n \u003cp\u003eBit 63 (the bit that is selected by the mask\n {@code 0x8000000000000000L}) represents the sign of the\n floating-point number. Bits\n 62-52 (the bits that are selected by the mask\n {@code 0x7ff0000000000000L}) represent the exponent. Bits 51-0\n (the bits that are selected by the mask\n {@code 0x000fffffffffffffL}) represent the significand\n (sometimes called the mantissa) of the floating-point number.\n\n \u003cp\u003eIf the argument is positive infinity, the result is\n {@code 0x7ff0000000000000L}.\n\n \u003cp\u003eIf the argument is negative infinity, the result is\n {@code 0xfff0000000000000L}.\n\n \u003cp\u003eIf the argument is NaN, the result is\n {@code 0x7ff8000000000000L}.\n\n \u003cp\u003eIn all cases, the result is a {@code long} integer that, when\n given to the {@link #longBitsToDouble(long)} method, will produce a\n floating-point value the same as the argument to\n {@code doubleToLongBits} (except all NaN values are\n collapsed to a single \"canonical\" NaN value).","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(double)","flatSignature":"(double)","returnType":{"isPrimitive":true,"simpleName":"long","qualifiedName":"long","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"value","type":{"isPrimitive":true,"simpleName":"double","qualifiedName":"double","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"doubleToRawLongBits","comment":"Returns a representation of the specified floating-point value\n according to the IEEE 754 floating-point \"double\n format\" bit layout, preserving Not-a-Number (NaN) values.\n\n \u003cp\u003eBit 63 (the bit that is selected by the mask\n {@code 0x8000000000000000L}) represents the sign of the\n floating-point number. Bits\n 62-52 (the bits that are selected by the mask\n {@code 0x7ff0000000000000L}) represent the exponent. Bits 51-0\n (the bits that are selected by the mask\n {@code 0x000fffffffffffffL}) represent the significand\n (sometimes called the mantissa) of the floating-point number.\n\n \u003cp\u003eIf the argument is positive infinity, the result is\n {@code 0x7ff0000000000000L}.\n\n \u003cp\u003eIf the argument is negative infinity, the result is\n {@code 0xfff0000000000000L}.\n\n \u003cp\u003eIf the argument is NaN, the result is the {@code long}\n integer representing the actual NaN value.  Unlike the\n {@code doubleToLongBits} method,\n {@code doubleToRawLongBits} does not collapse all the bit\n patterns encoding a NaN to a single \"canonical\" NaN\n value.\n\n \u003cp\u003eIn all cases, the result is a {@code long} integer that,\n when given to the {@link #longBitsToDouble(long)} method, will\n produce a floating-point value the same as the argument to\n {@code doubleToRawLongBits}.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(double)","flatSignature":"(double)","returnType":{"isPrimitive":true,"simpleName":"long","qualifiedName":"long","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"value","type":{"isPrimitive":true,"simpleName":"double","qualifiedName":"double","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"longBitsToDouble","comment":"Returns the {@code double} value corresponding to a given\n bit representation.\n The argument is considered to be a representation of a\n floating-point value according to the IEEE 754 floating-point\n \"double format\" bit layout.\n\n \u003cp\u003eIf the argument is {@code 0x7ff0000000000000L}, the result\n is positive infinity.\n\n \u003cp\u003eIf the argument is {@code 0xfff0000000000000L}, the result\n is negative infinity.\n\n \u003cp\u003eIf the argument is any value in the range\n {@code 0x7ff0000000000001L} through\n {@code 0x7fffffffffffffffL} or in the range\n {@code 0xfff0000000000001L} through\n {@code 0xffffffffffffffffL}, the result is a NaN.  No IEEE\n 754 floating-point operation provided by Java can distinguish\n between two NaN values of the same type with different bit\n patterns.  Distinct values of NaN are only distinguishable by\n use of the {@code Double.doubleToRawLongBits} method.\n\n \u003cp\u003eIn all other cases, let \u003ci\u003es\u003c/i\u003e, \u003ci\u003ee\u003c/i\u003e, and \u003ci\u003em\u003c/i\u003e be three\n values that can be computed from the argument:\n\n \u003cblockquote\u003e\u003cpre\u003e{@code\n int s \u003d ((bits \u003e\u003e 63) \u003d\u003d 0) ? 1 : -1;\n int e \u003d (int)((bits \u003e\u003e 52) \u0026 0x7ffL);\n long m \u003d (e \u003d\u003d 0) ?\n                 (bits \u0026 0xfffffffffffffL) \u003c\u003c 1 :\n                 (bits \u0026 0xfffffffffffffL) | 0x10000000000000L;\n }\u003c/pre\u003e\u003c/blockquote\u003e\n\n Then the floating-point result equals the value of the mathematical\n expression \u003ci\u003es\u003c/i\u003e\u0026middot;\u003ci\u003em\u003c/i\u003e\u0026middot;2\u003csup\u003e\u003ci\u003ee\u003c/i\u003e-1075\u003c/sup\u003e.\n\n \u003cp\u003eNote that this method may not be able to return a\n {@code double} NaN with exactly same bit pattern as the\n {@code long} argument.  IEEE 754 distinguishes between two\n kinds of NaNs, quiet NaNs and \u003ci\u003esignaling NaNs\u003c/i\u003e.  The\n differences between the two kinds of NaN are generally not\n visible in Java.  Arithmetic operations on signaling NaNs turn\n them into quiet NaNs with a different, but often similar, bit\n pattern.  However, on some processors merely copying a\n signaling NaN also performs that conversion.  In particular,\n copying a signaling NaN to return it to the calling method\n may perform this conversion.  So {@code longBitsToDouble}\n may not be able to return a {@code double} with a\n signaling NaN bit pattern.  Consequently, for some\n {@code long} values,\n {@code doubleToRawLongBits(longBitsToDouble(start))} may\n \u003ci\u003enot\u003c/i\u003e equal {@code start}.  Moreover, which\n particular bit patterns represent signaling NaNs is platform\n dependent; although all NaN bit patterns, quiet or signaling,\n must be in the NaN range identified above.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(long)","flatSignature":"(long)","returnType":{"isPrimitive":true,"simpleName":"double","qualifiedName":"double","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"bits","type":{"isPrimitive":true,"simpleName":"long","qualifiedName":"long","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"compareTo","comment":"Compares two {@code Double} objects numerically.  There\n are two ways in which comparisons performed by this method\n differ from those performed by the Java language numerical\n comparison operators ({@code \u003c, \u003c\u003d, \u003d\u003d, \u003e\u003d, \u003e})\n when applied to primitive {@code double} values:\n \u003cul\u003e\u003cli\u003e\n          {@code Double.NaN} is considered by this method\n          to be equal to itself and greater than all other\n          {@code double} values (including\n          {@code Double.POSITIVE_INFINITY}).\n \u003cli\u003e\n          {@code 0.0d} is considered by this method to be greater\n          than {@code -0.0d}.\n \u003c/ul\u003e\n This ensures that the \u003ci\u003enatural ordering\u003c/i\u003e of\n {@code Double} objects imposed by this method is \u003ci\u003econsistent\n with equals\u003c/i\u003e.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.lang.Double)","flatSignature":"(Double)","returnType":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[{"name":"anotherDouble","type":{"isPrimitive":false,"simpleName":"Double","qualifiedName":"java.lang.Double","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"compare","comment":"Compares the two specified {@code double} values. The sign\n of the integer value returned is the same as that of the\n integer that would be returned by the call:\n \u003cpre\u003e\n    new Double(d1).compareTo(new Double(d2))\n \u003c/pre\u003e","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(double, double)","flatSignature":"(double, double)","returnType":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"d1","type":{"isPrimitive":true,"simpleName":"double","qualifiedName":"double","dimension":"","elementType":{}}},{"name":"d2","type":{"isPrimitive":true,"simpleName":"double","qualifiedName":"double","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"sum","comment":"Adds two {@code double} values together as per the + operator.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(double, double)","flatSignature":"(double, double)","returnType":{"isPrimitive":true,"simpleName":"double","qualifiedName":"double","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"a","type":{"isPrimitive":true,"simpleName":"double","qualifiedName":"double","dimension":"","elementType":{}}},{"name":"b","type":{"isPrimitive":true,"simpleName":"double","qualifiedName":"double","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"max","comment":"Returns the greater of two {@code double} values\n as if by calling {@link Math#max(double, double) Math.max}.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(double, double)","flatSignature":"(double, double)","returnType":{"isPrimitive":true,"simpleName":"double","qualifiedName":"double","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"a","type":{"isPrimitive":true,"simpleName":"double","qualifiedName":"double","dimension":"","elementType":{}}},{"name":"b","type":{"isPrimitive":true,"simpleName":"double","qualifiedName":"double","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"min","comment":"Returns the smaller of two {@code double} values\n as if by calling {@link Math#min(double, double) Math.min}.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(double, double)","flatSignature":"(double, double)","returnType":{"isPrimitive":true,"simpleName":"double","qualifiedName":"double","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"a","type":{"isPrimitive":true,"simpleName":"double","qualifiedName":"double","dimension":"","elementType":{}}},{"name":"b","type":{"isPrimitive":true,"simpleName":"double","qualifiedName":"double","dimension":"","elementType":{}}}],"typeParameters":[]}],"typeParameters":[],"enumConstants":[]}