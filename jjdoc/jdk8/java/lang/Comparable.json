{"name":"Comparable","comment":"This interface imposes a total ordering on the objects of each class that\n implements it.  This ordering is referred to as the class\u0027s \u003ci\u003enatural\n ordering\u003c/i\u003e, and the class\u0027s \u003ctt\u003ecompareTo\u003c/tt\u003e method is referred to as\n its \u003ci\u003enatural comparison method\u003c/i\u003e.\u003cp\u003e\n\n Lists (and arrays) of objects that implement this interface can be sorted\n automatically by {@link Collections#sort(List) Collections.sort} (and\n {@link Arrays#sort(Object[]) Arrays.sort}).  Objects that implement this\n interface can be used as keys in a {@linkplain SortedMap sorted map} or as\n elements in a {@linkplain SortedSet sorted set}, without the need to\n specify a {@linkplain Comparator comparator}.\u003cp\u003e\n\n The natural ordering for a class \u003ctt\u003eC\u003c/tt\u003e is said to be \u003ci\u003econsistent\n with equals\u003c/i\u003e if and only if \u003ctt\u003ee1.compareTo(e2) \u003d\u003d 0\u003c/tt\u003e has\n the same boolean value as \u003ctt\u003ee1.equals(e2)\u003c/tt\u003e for every\n \u003ctt\u003ee1\u003c/tt\u003e and \u003ctt\u003ee2\u003c/tt\u003e of class \u003ctt\u003eC\u003c/tt\u003e.  Note that \u003ctt\u003enull\u003c/tt\u003e\n is not an instance of any class, and \u003ctt\u003ee.compareTo(null)\u003c/tt\u003e should\n throw a \u003ctt\u003eNullPointerException\u003c/tt\u003e even though \u003ctt\u003ee.equals(null)\u003c/tt\u003e\n returns \u003ctt\u003efalse\u003c/tt\u003e.\u003cp\u003e\n\n It is strongly recommended (though not required) that natural orderings be\n consistent with equals.  This is so because sorted sets (and sorted maps)\n without explicit comparators behave \"strangely\" when they are used with\n elements (or keys) whose natural ordering is inconsistent with equals.  In\n particular, such a sorted set (or sorted map) violates the general contract\n for set (or map), which is defined in terms of the \u003ctt\u003eequals\u003c/tt\u003e\n method.\u003cp\u003e\n\n For example, if one adds two keys \u003ctt\u003ea\u003c/tt\u003e and \u003ctt\u003eb\u003c/tt\u003e such that\n {@code (!a.equals(b) \u0026\u0026 a.compareTo(b) \u003d\u003d 0)} to a sorted\n set that does not use an explicit comparator, the second \u003ctt\u003eadd\u003c/tt\u003e\n operation returns false (and the size of the sorted set does not increase)\n because \u003ctt\u003ea\u003c/tt\u003e and \u003ctt\u003eb\u003c/tt\u003e are equivalent from the sorted set\u0027s\n perspective.\u003cp\u003e\n\n Virtually all Java core classes that implement \u003ctt\u003eComparable\u003c/tt\u003e have natural\n orderings that are consistent with equals.  One exception is\n \u003ctt\u003ejava.math.BigDecimal\u003c/tt\u003e, whose natural ordering equates\n \u003ctt\u003eBigDecimal\u003c/tt\u003e objects with equal values and different precisions\n (such as 4.0 and 4.00).\u003cp\u003e\n\n For the mathematically inclined, the \u003ci\u003erelation\u003c/i\u003e that defines\n the natural ordering on a given class C is:\u003cpre\u003e\n       {(x, y) such that x.compareTo(y) \u0026lt;\u003d 0}.\n \u003c/pre\u003e The \u003ci\u003equotient\u003c/i\u003e for this total order is: \u003cpre\u003e\n       {(x, y) such that x.compareTo(y) \u003d\u003d 0}.\n \u003c/pre\u003e\n\n It follows immediately from the contract for \u003ctt\u003ecompareTo\u003c/tt\u003e that the\n quotient is an \u003ci\u003eequivalence relation\u003c/i\u003e on \u003ctt\u003eC\u003c/tt\u003e, and that the\n natural ordering is a \u003ci\u003etotal order\u003c/i\u003e on \u003ctt\u003eC\u003c/tt\u003e.  When we say that a\n class\u0027s natural ordering is \u003ci\u003econsistent with equals\u003c/i\u003e, we mean that the\n quotient for the natural ordering is the equivalence relation defined by\n the class\u0027s {@link Object#equals(Object) equals(Object)} method:\u003cpre\u003e\n     {(x, y) such that x.equals(y)}. \u003c/pre\u003e\u003cp\u003e\n\n This interface is a member of the\n \u003ca href\u003d\"{@docRoot}/../technotes/guides/collections/index.html\"\u003e\n Java Collections Framework\u003c/a\u003e.","isClass":false,"isInterface":true,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":false,"isOrdinaryClass":false,"isPrimitive":false,"simpleName":"Comparable","qualifiedName":"java.lang.Comparable","dimension":"","elementType":{},"package":"java.lang","interfaces":[],"isAbstract":true,"isStatic":false,"since":"1.2","innerClasses":[],"isInnerClass":false,"constructors":[],"fields":[],"methods":[{"name":"compareTo","comment":"Compares this object with the specified object for order.  Returns a\n negative integer, zero, or a positive integer as this object is less\n than, equal to, or greater than the specified object.\n\n \u003cp\u003eThe implementor must ensure \u003ctt\u003esgn(x.compareTo(y)) \u003d\u003d\n -sgn(y.compareTo(x))\u003c/tt\u003e for all \u003ctt\u003ex\u003c/tt\u003e and \u003ctt\u003ey\u003c/tt\u003e.  (This\n implies that \u003ctt\u003ex.compareTo(y)\u003c/tt\u003e must throw an exception iff\n \u003ctt\u003ey.compareTo(x)\u003c/tt\u003e throws an exception.)\n\n \u003cp\u003eThe implementor must also ensure that the relation is transitive:\n \u003ctt\u003e(x.compareTo(y)\u0026gt;0 \u0026amp;\u0026amp; y.compareTo(z)\u0026gt;0)\u003c/tt\u003e implies\n \u003ctt\u003ex.compareTo(z)\u0026gt;0\u003c/tt\u003e.\n\n \u003cp\u003eFinally, the implementor must ensure that \u003ctt\u003ex.compareTo(y)\u003d\u003d0\u003c/tt\u003e\n implies that \u003ctt\u003esgn(x.compareTo(z)) \u003d\u003d sgn(y.compareTo(z))\u003c/tt\u003e, for\n all \u003ctt\u003ez\u003c/tt\u003e.\n\n \u003cp\u003eIt is strongly recommended, but \u003ci\u003enot\u003c/i\u003e strictly required that\n \u003ctt\u003e(x.compareTo(y)\u003d\u003d0) \u003d\u003d (x.equals(y))\u003c/tt\u003e.  Generally speaking, any\n class that implements the \u003ctt\u003eComparable\u003c/tt\u003e interface and violates\n this condition should clearly indicate this fact.  The recommended\n language is \"Note: this class has a natural ordering that is\n inconsistent with equals.\"\n\n \u003cp\u003eIn the foregoing description, the notation\n \u003ctt\u003esgn(\u003c/tt\u003e\u003ci\u003eexpression\u003c/i\u003e\u003ctt\u003e)\u003c/tt\u003e designates the mathematical\n \u003ci\u003esignum\u003c/i\u003e function, which is defined to return one of \u003ctt\u003e-1\u003c/tt\u003e,\n \u003ctt\u003e0\u003c/tt\u003e, or \u003ctt\u003e1\u003c/tt\u003e according to whether the value of\n \u003ci\u003eexpression\u003c/i\u003e is negative, zero or positive.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(T)","flatSignature":"(T)","returnType":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}},"isAbstract":true,"isDefault":false,"isStatic":false,"parameters":[{"name":"o","type":{"isPrimitive":false,"simpleName":"T","qualifiedName":"T","dimension":"","elementType":{},"typeVariable":{"name":"T","bounds":[]}}}],"typeParameters":[]}],"typeParameters":[{"name":"T","bounds":[]}],"subInterfaces":["java.net.URI","java.nio.ShortBuffer","java.nio.LongBuffer","java.nio.IntBuffer","java.nio.FloatBuffer","java.nio.DoubleBuffer","java.nio.CharBuffer","java.nio.ByteBuffer","java.nio.file.Path","java.nio.file.attribute.FileTime","java.nio.charset.Charset","java.text.CollationKey","java.lang.String","java.lang.Short","java.lang.Long","java.lang.Integer","java.lang.Float","java.lang.Enum","java.lang.Double","java.lang.Character","java.lang.Byte","java.lang.Boolean","java.io.ObjectStreamField","java.io.File","java.time.zone.ZoneOffsetTransition","java.time.chrono.ChronoZonedDateTime","java.time.ZoneOffset","java.time.YearMonth","java.time.Year","java.time.OffsetTime","java.time.OffsetDateTime","java.time.MonthDay","java.time.LocalTime","java.time.chrono.ChronoLocalDateTime","java.time.chrono.ChronoLocalDate","java.time.Instant","java.time.Duration","java.time.chrono.Chronology","java.util.UUID","java.util.Date","java.util.Calendar","java.util.concurrent.Delayed","java.math.BigInteger","java.math.BigDecimal"],"enumConstants":[]}