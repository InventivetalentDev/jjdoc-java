{"name":"LambdaMetafactory","comment":"\u003cp\u003eMethods to facilitate the creation of simple \"function objects\" that\n implement one or more interfaces by delegation to a provided {@link MethodHandle},\n possibly after type adaptation and partial evaluation of arguments.  These\n methods are typically used as \u003cem\u003ebootstrap methods\u003c/em\u003e for {@code invokedynamic}\n call sites, to support the \u003cem\u003elambda expression\u003c/em\u003e and \u003cem\u003emethod\n reference expression\u003c/em\u003e features of the Java Programming Language.\n\n \u003cp\u003eIndirect access to the behavior specified by the provided {@code MethodHandle}\n proceeds in order through three phases:\n \u003cul\u003e\n     \u003cli\u003e\u003cem\u003eLinkage\u003c/em\u003e occurs when the methods in this class are invoked.\n     They take as arguments an interface to be implemented (typically a\n     \u003cem\u003efunctional interface\u003c/em\u003e, one with a single abstract method), a\n     name and signature of a method from that interface to be implemented, a\n     method handle describing the desired implementation behavior\n     for that method, and possibly other additional metadata, and produce a\n     {@link CallSite} whose target can be used to create suitable function\n     objects.  Linkage may involve dynamically loading a new class that\n     implements the target interface. The {@code CallSite} can be considered a\n     \"factory\" for function objects and so these linkage methods are referred\n     to as \"metafactories\".\u003c/li\u003e\n\n     \u003cli\u003e\u003cem\u003eCapture\u003c/em\u003e occurs when the {@code CallSite}\u0027s target is\n     invoked, typically through an {@code invokedynamic} call site,\n     producing a function object.  This may occur many times for\n     a single factory {@code CallSite}.  Capture may involve allocation of a\n     new function object, or may return an existing function object.  The\n     behavior {@code MethodHandle} may have additional parameters beyond those\n     of the specified interface method; these are referred to as \u003cem\u003ecaptured\n     parameters\u003c/em\u003e, which must be provided as arguments to the\n     {@code CallSite} target, and which may be early-bound to the behavior\n     {@code MethodHandle}.  The number of captured parameters and their types\n     are determined during linkage.\u003c/li\u003e\n\n     \u003cli\u003e\u003cem\u003eInvocation\u003c/em\u003e occurs when an implemented interface method\n     is invoked on a function object.  This may occur many times for a single\n     function object.  The method referenced by the behavior {@code MethodHandle}\n     is invoked with the captured arguments and any additional arguments\n     provided on invocation, as if by {@link MethodHandle#invoke(Object...)}.\u003c/li\u003e\n \u003c/ul\u003e\n\n \u003cp\u003eIt is sometimes useful to restrict the set of inputs or results permitted\n at invocation.  For example, when the generic interface {@code Predicate\u003cT\u003e}\n is parameterized as {@code Predicate\u003cString\u003e}, the input must be a\n {@code String}, even though the method to implement allows any {@code Object}.\n At linkage time, an additional {@link MethodType} parameter describes the\n \"instantiated\" method type; on invocation, the arguments and eventual result\n are checked against this {@code MethodType}.\n\n \u003cp\u003eThis class provides two forms of linkage methods: a standard version\n ({@link #metafactory(MethodHandles.Lookup, String, MethodType, MethodType, MethodHandle, MethodType)})\n using an optimized protocol, and an alternate version\n {@link #altMetafactory(MethodHandles.Lookup, String, MethodType, Object...)}).\n The alternate version is a generalization of the standard version, providing\n additional control over the behavior of the generated function objects via\n flags and additional arguments.  The alternate version adds the ability to\n manage the following attributes of function objects:\n\n \u003cul\u003e\n     \u003cli\u003e\u003cem\u003eBridging.\u003c/em\u003e  It is sometimes useful to implement multiple\n     variations of the method signature, involving argument or return type\n     adaptation.  This occurs when multiple distinct VM signatures for a method\n     are logically considered to be the same method by the language.  The\n     flag {@code FLAG_BRIDGES} indicates that a list of additional\n     {@code MethodType}s will be provided, each of which will be implemented\n     by the resulting function object.  These methods will share the same\n     name and instantiated type.\u003c/li\u003e\n\n     \u003cli\u003e\u003cem\u003eMultiple interfaces.\u003c/em\u003e  If needed, more than one interface\n     can be implemented by the function object.  (These additional interfaces\n     are typically marker interfaces with no methods.)  The flag {@code FLAG_MARKERS}\n     indicates that a list of additional interfaces will be provided, each of\n     which should be implemented by the resulting function object.\u003c/li\u003e\n\n     \u003cli\u003e\u003cem\u003eSerializability.\u003c/em\u003e  The generated function objects do not\n     generally support serialization.  If desired, {@code FLAG_SERIALIZABLE}\n     can be used to indicate that the function objects should be serializable.\n     Serializable function objects will use, as their serialized form,\n     instances of the class {@code SerializedLambda}, which requires additional\n     assistance from the capturing class (the class described by the\n     {@link MethodHandles.Lookup} parameter {@code caller}); see\n     {@link SerializedLambda} for details.\u003c/li\u003e\n \u003c/ul\u003e\n\n \u003cp\u003eAssume the linkage arguments are as follows:\n \u003cul\u003e\n      \u003cli\u003e{@code invokedType} (describing the {@code CallSite} signature) has\n      K parameters of types (D1..Dk) and return type Rd;\u003c/li\u003e\n      \u003cli\u003e{@code samMethodType} (describing the implemented method type) has N\n      parameters, of types (U1..Un) and return type Ru;\u003c/li\u003e\n      \u003cli\u003e{@code implMethod} (the {@code MethodHandle} providing the\n      implementation has M parameters, of types (A1..Am) and return type Ra\n      (if the method describes an instance method, the method type of this\n      method handle already includes an extra first argument corresponding to\n      the receiver);\u003c/li\u003e\n      \u003cli\u003e{@code instantiatedMethodType} (allowing restrictions on invocation)\n      has N parameters, of types (T1..Tn) and return type Rt.\u003c/li\u003e\n \u003c/ul\u003e\n\n \u003cp\u003eThen the following linkage invariants must hold:\n \u003cul\u003e\n     \u003cli\u003eRd is an interface\u003c/li\u003e\n     \u003cli\u003e{@code implMethod} is a \u003cem\u003edirect method handle\u003c/em\u003e\u003c/li\u003e\n     \u003cli\u003e{@code samMethodType} and {@code instantiatedMethodType} have the same\n     arity N, and for i\u003d1..N, Ti and Ui are the same type, or Ti and Ui are\n     both reference types and Ti is a subtype of Ui\u003c/li\u003e\n     \u003cli\u003eEither Rt and Ru are the same type, or both are reference types and\n     Rt is a subtype of Ru\u003c/li\u003e\n     \u003cli\u003eK + N \u003d M\u003c/li\u003e\n     \u003cli\u003eFor i\u003d1..K, Di \u003d Ai\u003c/li\u003e\n     \u003cli\u003eFor i\u003d1..N, Ti is adaptable to Aj, where j\u003di+k\u003c/li\u003e\n     \u003cli\u003eThe return type Rt is void, or the return type Ra is not void and is\n     adaptable to Rt\u003c/li\u003e\n \u003c/ul\u003e\n\n \u003cp\u003eFurther, at capture time, if {@code implMethod} corresponds to an instance\n method, and there are any capture arguments ({@code K \u003e 0}), then the first\n capture argument (corresponding to the receiver) must be non-null.\n\n \u003cp\u003eA type Q is considered adaptable to S as follows:\n \u003ctable summary\u003d\"adaptable types\"\u003e\n     \u003ctr\u003e\u003cth\u003eQ\u003c/th\u003e\u003cth\u003eS\u003c/th\u003e\u003cth\u003eLink-time checks\u003c/th\u003e\u003cth\u003eInvocation-time checks\u003c/th\u003e\u003c/tr\u003e\n     \u003ctr\u003e\n         \u003ctd\u003ePrimitive\u003c/td\u003e\u003ctd\u003ePrimitive\u003c/td\u003e\n         \u003ctd\u003eQ can be converted to S via a primitive widening conversion\u003c/td\u003e\n         \u003ctd\u003eNone\u003c/td\u003e\n     \u003c/tr\u003e\n     \u003ctr\u003e\n         \u003ctd\u003ePrimitive\u003c/td\u003e\u003ctd\u003eReference\u003c/td\u003e\n         \u003ctd\u003eS is a supertype of the Wrapper(Q)\u003c/td\u003e\n         \u003ctd\u003eCast from Wrapper(Q) to S\u003c/td\u003e\n     \u003c/tr\u003e\n     \u003ctr\u003e\n         \u003ctd\u003eReference\u003c/td\u003e\u003ctd\u003ePrimitive\u003c/td\u003e\n         \u003ctd\u003efor parameter types: Q is a primitive wrapper and Primitive(Q)\n         can be widened to S\n         \u003cbr\u003efor return types: If Q is a primitive wrapper, check that\n         Primitive(Q) can be widened to S\u003c/td\u003e\n         \u003ctd\u003eIf Q is not a primitive wrapper, cast Q to the base Wrapper(S);\n         for example Number for numeric types\u003c/td\u003e\n     \u003c/tr\u003e\n     \u003ctr\u003e\n         \u003ctd\u003eReference\u003c/td\u003e\u003ctd\u003eReference\u003c/td\u003e\n         \u003ctd\u003efor parameter types: S is a supertype of Q\n         \u003cbr\u003efor return types: none\u003c/td\u003e\n         \u003ctd\u003eCast from Q to S\u003c/td\u003e\n     \u003c/tr\u003e\n \u003c/table\u003e","isClass":true,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":false,"isOrdinaryClass":true,"isPrimitive":false,"simpleName":"LambdaMetafactory","qualifiedName":"java.lang.invoke.LambdaMetafactory","dimension":"","elementType":{},"package":"java.lang.invoke","superclass":"java.lang.Object","interfaces":[],"isAbstract":false,"isStatic":false,"innerClasses":[],"isInnerClass":false,"constructors":[{"name":"LambdaMetafactory","comment":"","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":true,"isField":false,"isMethod":false,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","parameters":[],"typeParameters":[]}],"fields":[{"name":"FLAG_SERIALIZABLE","comment":"Flag for alternate metafactories indicating the lambda object\n must be serializable","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":true,"isMethod":false,"isOrdinaryClass":false,"type":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}},"isStatic":true,"constantValue":"1"},{"name":"FLAG_MARKERS","comment":"Flag for alternate metafactories indicating the lambda object implements\n other marker interfaces\n besides Serializable","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":true,"isMethod":false,"isOrdinaryClass":false,"type":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}},"isStatic":true,"constantValue":"2"},{"name":"FLAG_BRIDGES","comment":"Flag for alternate metafactories indicating the lambda object requires\n additional bridge methods","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":true,"isMethod":false,"isOrdinaryClass":false,"type":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}},"isStatic":true,"constantValue":"4"}],"methods":[{"name":"metafactory","comment":"Facilitates the creation of simple \"function objects\" that implement one\n or more interfaces by delegation to a provided {@link MethodHandle},\n after appropriate type adaptation and partial evaluation of arguments.\n Typically used as a \u003cem\u003ebootstrap method\u003c/em\u003e for {@code invokedynamic}\n call sites, to support the \u003cem\u003elambda expression\u003c/em\u003e and \u003cem\u003emethod\n reference expression\u003c/em\u003e features of the Java Programming Language.\n\n \u003cp\u003eThis is the standard, streamlined metafactory; additional flexibility\n is provided by {@link #altMetafactory(MethodHandles.Lookup, String, MethodType, Object...)}.\n A general description of the behavior of this method is provided\n {@link LambdaMetafactory above}.\n\n \u003cp\u003eWhen the target of the {@code CallSite} returned from this method is\n invoked, the resulting function objects are instances of a class which\n implements the interface named by the return type of {@code invokedType},\n declares a method with the name given by {@code invokedName} and the\n signature given by {@code samMethodType}.  It may also override additional\n methods from {@code Object}.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.lang.invoke.MethodHandles.Lookup, java.lang.String, java.lang.invoke.MethodType, java.lang.invoke.MethodType, java.lang.invoke.MethodHandle, java.lang.invoke.MethodType)","flatSignature":"(MethodHandles.Lookup, String, MethodType, MethodType, MethodHandle, MethodType)","returnType":{"isPrimitive":false,"simpleName":"CallSite","qualifiedName":"java.lang.invoke.CallSite","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"caller","type":{"isPrimitive":false,"simpleName":"Lookup","qualifiedName":"java.lang.invoke.MethodHandles.Lookup","dimension":"","elementType":{}}},{"name":"invokedName","type":{"isPrimitive":false,"simpleName":"String","qualifiedName":"java.lang.String","dimension":"","elementType":{}}},{"name":"invokedType","type":{"isPrimitive":false,"simpleName":"MethodType","qualifiedName":"java.lang.invoke.MethodType","dimension":"","elementType":{}}},{"name":"samMethodType","type":{"isPrimitive":false,"simpleName":"MethodType","qualifiedName":"java.lang.invoke.MethodType","dimension":"","elementType":{}}},{"name":"implMethod","type":{"isPrimitive":false,"simpleName":"MethodHandle","qualifiedName":"java.lang.invoke.MethodHandle","dimension":"","elementType":{}}},{"name":"instantiatedMethodType","type":{"isPrimitive":false,"simpleName":"MethodType","qualifiedName":"java.lang.invoke.MethodType","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"altMetafactory","comment":"Facilitates the creation of simple \"function objects\" that implement one\n or more interfaces by delegation to a provided {@link MethodHandle},\n after appropriate type adaptation and partial evaluation of arguments.\n Typically used as a \u003cem\u003ebootstrap method\u003c/em\u003e for {@code invokedynamic}\n call sites, to support the \u003cem\u003elambda expression\u003c/em\u003e and \u003cem\u003emethod\n reference expression\u003c/em\u003e features of the Java Programming Language.\n\n \u003cp\u003eThis is the general, more flexible metafactory; a streamlined version\n is provided by {@link #metafactory(java.lang.invoke.MethodHandles.Lookup,\n String, MethodType, MethodType, MethodHandle, MethodType)}.\n A general description of the behavior of this method is provided\n {@link LambdaMetafactory above}.\n\n \u003cp\u003eThe argument list for this method includes three fixed parameters,\n corresponding to the parameters automatically stacked by the VM for the\n bootstrap method in an {@code invokedynamic} invocation, and an {@code Object[]}\n parameter that contains additional parameters.  The declared argument\n list for this method is:\n\n \u003cpre\u003e{@code\n  CallSite altMetafactory(MethodHandles.Lookup caller,\n                          String invokedName,\n                          MethodType invokedType,\n                          Object... args)\n }\u003c/pre\u003e\n\n \u003cp\u003ebut it behaves as if the argument list is as follows:\n\n \u003cpre\u003e{@code\n  CallSite altMetafactory(MethodHandles.Lookup caller,\n                          String invokedName,\n                          MethodType invokedType,\n                          MethodType samMethodType,\n                          MethodHandle implMethod,\n                          MethodType instantiatedMethodType,\n                          int flags,\n                          int markerInterfaceCount,  // IF flags has MARKERS set\n                          Class... markerInterfaces, // IF flags has MARKERS set\n                          int bridgeCount,           // IF flags has BRIDGES set\n                          MethodType... bridges      // IF flags has BRIDGES set\n                          )\n }\u003c/pre\u003e\n\n \u003cp\u003eArguments that appear in the argument list for\n {@link #metafactory(MethodHandles.Lookup, String, MethodType, MethodType, MethodHandle, MethodType)}\n have the same specification as in that method.  The additional arguments\n are interpreted as follows:\n \u003cul\u003e\n     \u003cli\u003e{@code flags} indicates additional options; this is a bitwise\n     OR of desired flags.  Defined flags are {@link #FLAG_BRIDGES},\n     {@link #FLAG_MARKERS}, and {@link #FLAG_SERIALIZABLE}.\u003c/li\u003e\n     \u003cli\u003e{@code markerInterfaceCount} is the number of additional interfaces\n     the function object should implement, and is present if and only if the\n     {@code FLAG_MARKERS} flag is set.\u003c/li\u003e\n     \u003cli\u003e{@code markerInterfaces} is a variable-length list of additional\n     interfaces to implement, whose length equals {@code markerInterfaceCount},\n     and is present if and only if the {@code FLAG_MARKERS} flag is set.\u003c/li\u003e\n     \u003cli\u003e{@code bridgeCount} is the number of additional method signatures\n     the function object should implement, and is present if and only if\n     the {@code FLAG_BRIDGES} flag is set.\u003c/li\u003e\n     \u003cli\u003e{@code bridges} is a variable-length list of additional\n     methods signatures to implement, whose length equals {@code bridgeCount},\n     and is present if and only if the {@code FLAG_BRIDGES} flag is set.\u003c/li\u003e\n \u003c/ul\u003e\n\n \u003cp\u003eEach class named by {@code markerInterfaces} is subject to the same\n restrictions as {@code Rd}, the return type of {@code invokedType},\n as described {@link LambdaMetafactory above}.  Each {@code MethodType}\n named by {@code bridges} is subject to the same restrictions as\n {@code samMethodType}, as described {@link LambdaMetafactory above}.\n\n \u003cp\u003eWhen FLAG_SERIALIZABLE is set in {@code flags}, the function objects\n will implement {@code Serializable}, and will have a {@code writeReplace}\n method that returns an appropriate {@link SerializedLambda}.  The\n {@code caller} class must have an appropriate {@code $deserializeLambda$}\n method, as described in {@link SerializedLambda}.\n\n \u003cp\u003eWhen the target of the {@code CallSite} returned from this method is\n invoked, the resulting function objects are instances of a class with\n the following properties:\n \u003cul\u003e\n     \u003cli\u003eThe class implements the interface named by the return type\n     of {@code invokedType} and any interfaces named by {@code markerInterfaces}\u003c/li\u003e\n     \u003cli\u003eThe class declares methods with the name given by {@code invokedName},\n     and the signature given by {@code samMethodType} and additional signatures\n     given by {@code bridges}\u003c/li\u003e\n     \u003cli\u003eThe class may override methods from {@code Object}, and may\n     implement methods related to serialization.\u003c/li\u003e\n \u003c/ul\u003e","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.lang.invoke.MethodHandles.Lookup, java.lang.String, java.lang.invoke.MethodType, java.lang.Object...)","flatSignature":"(MethodHandles.Lookup, String, MethodType, Object...)","returnType":{"isPrimitive":false,"simpleName":"CallSite","qualifiedName":"java.lang.invoke.CallSite","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"caller","type":{"isPrimitive":false,"simpleName":"Lookup","qualifiedName":"java.lang.invoke.MethodHandles.Lookup","dimension":"","elementType":{}}},{"name":"invokedName","type":{"isPrimitive":false,"simpleName":"String","qualifiedName":"java.lang.String","dimension":"","elementType":{}}},{"name":"invokedType","type":{"isPrimitive":false,"simpleName":"MethodType","qualifiedName":"java.lang.invoke.MethodType","dimension":"","elementType":{}}},{"name":"args","type":{"isPrimitive":false,"simpleName":"Object","qualifiedName":"java.lang.Object","dimension":"[]","elementType":{"isPrimitive":false,"simpleName":"Object","qualifiedName":"java.lang.Object","dimension":"","elementType":{}}}}],"typeParameters":[]}],"typeParameters":[],"enumConstants":[]}