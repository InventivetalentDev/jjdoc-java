{"name":"MethodHandles","comment":"This class consists exclusively of static methods that operate on or return\n method handles. They fall into several categories:\n \u003cul\u003e\n \u003cli\u003eLookup methods which help create method handles for methods and fields.\n \u003cli\u003eCombinator methods, which combine or transform pre-existing method handles into new ones.\n \u003cli\u003eOther factory methods to create method handles that emulate other common JVM operations or control flow patterns.\n \u003c/ul\u003e\n \u003cp\u003e","isClass":true,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":false,"isOrdinaryClass":true,"isPrimitive":false,"simpleName":"MethodHandles","qualifiedName":"java.lang.invoke.MethodHandles","dimension":"","elementType":{},"package":"java.lang.invoke","superclass":"java.lang.Object","interfaces":[],"isAbstract":false,"isStatic":false,"since":"1.7","innerClasses":["java.lang.invoke.MethodHandles.Lookup"],"isInnerClass":false,"constructors":[],"fields":[],"methods":[{"name":"lookup","comment":"Returns a {@link Lookup lookup object} with\n full capabilities to emulate all supported bytecode behaviors of the caller.\n These capabilities include \u003ca href\u003d\"MethodHandles.Lookup.html#privacc\"\u003eprivate access\u003c/a\u003e to the caller.\n Factory methods on the lookup object can create\n \u003ca href\u003d\"MethodHandleInfo.html#directmh\"\u003edirect method handles\u003c/a\u003e\n for any member that the caller has access to via bytecodes,\n including protected and private fields and methods.\n This lookup object is a \u003cem\u003ecapability\u003c/em\u003e which may be delegated to trusted agents.\n Do not store it in place where untrusted code can access it.\n \u003cp\u003e\n This method is caller sensitive, which means that it may return different\n values to different callers.\n \u003cp\u003e\n For any given caller class {@code C}, the lookup object returned by this call\n has equivalent capabilities to any lookup object\n supplied by the JVM to the bootstrap method of an\n \u003ca href\u003d\"package-summary.html#indyinsn\"\u003einvokedynamic instruction\u003c/a\u003e\n executing in the same caller class {@code C}.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":false,"simpleName":"Lookup","qualifiedName":"java.lang.invoke.MethodHandles.Lookup","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[],"typeParameters":[]},{"name":"publicLookup","comment":"Returns a {@link Lookup lookup object} which is trusted minimally.\n It can only be used to create method handles to\n publicly accessible fields and methods.\n \u003cp\u003e\n As a matter of pure convention, the {@linkplain Lookup#lookupClass lookup class}\n of this lookup object will be {@link java.lang.Object}.\n\n \u003cp style\u003d\"font-size:smaller;\"\u003e\n \u003cem\u003eDiscussion:\u003c/em\u003e\n The lookup class can be changed to any other class {@code C} using an expression of the form\n {@link Lookup#in publicLookup().in(C.class)}.\n Since all classes have equal access to public names,\n such a change would confer no new access rights.\n A public lookup object is always subject to\n \u003ca href\u003d\"MethodHandles.Lookup.html#secmgr\"\u003esecurity manager checks\u003c/a\u003e.\n Also, it cannot access\n \u003ca href\u003d\"MethodHandles.Lookup.html#callsens\"\u003ecaller sensitive methods\u003c/a\u003e.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":false,"simpleName":"Lookup","qualifiedName":"java.lang.invoke.MethodHandles.Lookup","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[],"typeParameters":[]},{"name":"reflectAs","comment":"Performs an unchecked \"crack\" of a\n \u003ca href\u003d\"MethodHandleInfo.html#directmh\"\u003edirect method handle\u003c/a\u003e.\n The result is as if the user had obtained a lookup object capable enough\n to crack the target method handle, called\n {@link java.lang.invoke.MethodHandles.Lookup#revealDirect Lookup.revealDirect}\n on the target to obtain its symbolic reference, and then called\n {@link java.lang.invoke.MethodHandleInfo#reflectAs MethodHandleInfo.reflectAs}\n to resolve the symbolic reference to a member.\n \u003cp\u003e\n If there is a security manager, its {@code checkPermission} method\n is called with a {@code ReflectPermission(\"suppressAccessChecks\")} permission.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.lang.Class\u003cT\u003e, java.lang.invoke.MethodHandle)","flatSignature":"(Class\u003cT\u003e, MethodHandle)","returnType":{"isPrimitive":false,"simpleName":"T","qualifiedName":"T","dimension":"","elementType":{},"typeVariable":{"name":"T","bounds":["java.lang.reflect.Member"]}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"expected","type":{"isPrimitive":false,"simpleName":"Class","qualifiedName":"java.lang.Class","dimension":"","elementType":{}}},{"name":"target","type":{"isPrimitive":false,"simpleName":"MethodHandle","qualifiedName":"java.lang.invoke.MethodHandle","dimension":"","elementType":{}}}],"typeParameters":[{"name":"T","bounds":["java.lang.reflect.Member"]}]},{"name":"arrayElementGetter","comment":"Produces a method handle giving read access to elements of an array.\n The type of the method handle will have a return type of the array\u0027s\n element type.  Its first argument will be the array type,\n and the second will be {@code int}.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.lang.Class\u003c?\u003e)","flatSignature":"(Class\u003c?\u003e)","returnType":{"isPrimitive":false,"simpleName":"MethodHandle","qualifiedName":"java.lang.invoke.MethodHandle","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"arrayClass","type":{"isPrimitive":false,"simpleName":"Class","qualifiedName":"java.lang.Class","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"arrayElementSetter","comment":"Produces a method handle giving write access to elements of an array.\n The type of the method handle will have a void return type.\n Its last argument will be the array\u0027s element type.\n The first and second arguments will be the array type and int.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.lang.Class\u003c?\u003e)","flatSignature":"(Class\u003c?\u003e)","returnType":{"isPrimitive":false,"simpleName":"MethodHandle","qualifiedName":"java.lang.invoke.MethodHandle","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"arrayClass","type":{"isPrimitive":false,"simpleName":"Class","qualifiedName":"java.lang.Class","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"spreadInvoker","comment":"Produces a method handle which will invoke any method handle of the\n given {@code type}, with a given number of trailing arguments replaced by\n a single trailing {@code Object[]} array.\n The resulting invoker will be a method handle with the following\n arguments:\n \u003cul\u003e\n \u003cli\u003ea single {@code MethodHandle} target\n \u003cli\u003ezero or more leading values (counted by {@code leadingArgCount})\n \u003cli\u003ean {@code Object[]} array containing trailing arguments\n \u003c/ul\u003e\n \u003cp\u003e\n The invoker will invoke its target like a call to {@link MethodHandle#invoke invoke} with\n the indicated {@code type}.\n That is, if the target is exactly of the given {@code type}, it will behave\n like {@code invokeExact}; otherwise it behave as if {@link MethodHandle#asType asType}\n is used to convert the target to the required {@code type}.\n \u003cp\u003e\n The type of the returned invoker will not be the given {@code type}, but rather\n will have all parameters except the first {@code leadingArgCount}\n replaced by a single array of type {@code Object[]}, which will be\n the final parameter.\n \u003cp\u003e\n Before invoking its target, the invoker will spread the final array, apply\n reference casts as necessary, and unbox and widen primitive arguments.\n If, when the invoker is called, the supplied array argument does\n not have the correct number of elements, the invoker will throw\n an {@link IllegalArgumentException} instead of invoking the target.\n \u003cp\u003e\n This method is equivalent to the following code (though it may be more efficient):\n \u003cblockquote\u003e\u003cpre\u003e{@code\nMethodHandle invoker \u003d MethodHandles.invoker(type);\nint spreadArgCount \u003d type.parameterCount() - leadingArgCount;\ninvoker \u003d invoker.asSpreader(Object[].class, spreadArgCount);\nreturn invoker;\n }\u003c/pre\u003e\u003c/blockquote\u003e\n This method throws no reflective or security exceptions.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.lang.invoke.MethodType, int)","flatSignature":"(MethodType, int)","returnType":{"isPrimitive":false,"simpleName":"MethodHandle","qualifiedName":"java.lang.invoke.MethodHandle","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"type","type":{"isPrimitive":false,"simpleName":"MethodType","qualifiedName":"java.lang.invoke.MethodType","dimension":"","elementType":{}}},{"name":"leadingArgCount","type":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"exactInvoker","comment":"Produces a special \u003cem\u003einvoker method handle\u003c/em\u003e which can be used to\n invoke any method handle of the given type, as if by {@link MethodHandle#invokeExact invokeExact}.\n The resulting invoker will have a type which is\n exactly equal to the desired type, except that it will accept\n an additional leading argument of type {@code MethodHandle}.\n \u003cp\u003e\n This method is equivalent to the following code (though it may be more efficient):\n {@code publicLookup().findVirtual(MethodHandle.class, \"invokeExact\", type)}\n\n \u003cp style\u003d\"font-size:smaller;\"\u003e\n \u003cem\u003eDiscussion:\u003c/em\u003e\n Invoker method handles can be useful when working with variable method handles\n of unknown types.\n For example, to emulate an {@code invokeExact} call to a variable method\n handle {@code M}, extract its type {@code T},\n look up the invoker method {@code X} for {@code T},\n and call the invoker method, as {@code X.invoke(T, A...)}.\n (It would not work to call {@code X.invokeExact}, since the type {@code T}\n is unknown.)\n If spreading, collecting, or other argument transformations are required,\n they can be applied once to the invoker {@code X} and reused on many {@code M}\n method handle values, as long as they are compatible with the type of {@code X}.\n \u003cp style\u003d\"font-size:smaller;\"\u003e\n \u003cem\u003e(Note:  The invoker method is not available via the Core Reflection API.\n An attempt to call {@linkplain java.lang.reflect.Method#invoke java.lang.reflect.Method.invoke}\n on the declared {@code invokeExact} or {@code invoke} method will raise an\n {@link java.lang.UnsupportedOperationException UnsupportedOperationException}.)\u003c/em\u003e\n \u003cp\u003e\n This method throws no reflective or security exceptions.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.lang.invoke.MethodType)","flatSignature":"(MethodType)","returnType":{"isPrimitive":false,"simpleName":"MethodHandle","qualifiedName":"java.lang.invoke.MethodHandle","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"type","type":{"isPrimitive":false,"simpleName":"MethodType","qualifiedName":"java.lang.invoke.MethodType","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"invoker","comment":"Produces a special \u003cem\u003einvoker method handle\u003c/em\u003e which can be used to\n invoke any method handle compatible with the given type, as if by {@link MethodHandle#invoke invoke}.\n The resulting invoker will have a type which is\n exactly equal to the desired type, except that it will accept\n an additional leading argument of type {@code MethodHandle}.\n \u003cp\u003e\n Before invoking its target, if the target differs from the expected type,\n the invoker will apply reference casts as\n necessary and box, unbox, or widen primitive values, as if by {@link MethodHandle#asType asType}.\n Similarly, the return value will be converted as necessary.\n If the target is a {@linkplain MethodHandle#asVarargsCollector variable arity method handle},\n the required arity conversion will be made, again as if by {@link MethodHandle#asType asType}.\n \u003cp\u003e\n This method is equivalent to the following code (though it may be more efficient):\n {@code publicLookup().findVirtual(MethodHandle.class, \"invoke\", type)}\n \u003cp style\u003d\"font-size:smaller;\"\u003e\n \u003cem\u003eDiscussion:\u003c/em\u003e\n A {@linkplain MethodType#genericMethodType general method type} is one which\n mentions only {@code Object} arguments and return values.\n An invoker for such a type is capable of calling any method handle\n of the same arity as the general type.\n \u003cp style\u003d\"font-size:smaller;\"\u003e\n \u003cem\u003e(Note:  The invoker method is not available via the Core Reflection API.\n An attempt to call {@linkplain java.lang.reflect.Method#invoke java.lang.reflect.Method.invoke}\n on the declared {@code invokeExact} or {@code invoke} method will raise an\n {@link java.lang.UnsupportedOperationException UnsupportedOperationException}.)\u003c/em\u003e\n \u003cp\u003e\n This method throws no reflective or security exceptions.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.lang.invoke.MethodType)","flatSignature":"(MethodType)","returnType":{"isPrimitive":false,"simpleName":"MethodHandle","qualifiedName":"java.lang.invoke.MethodHandle","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"type","type":{"isPrimitive":false,"simpleName":"MethodType","qualifiedName":"java.lang.invoke.MethodType","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"explicitCastArguments","comment":"Produces a method handle which adapts the type of the\n given method handle to a new type by pairwise argument and return type conversion.\n The original type and new type must have the same number of arguments.\n The resulting method handle is guaranteed to report a type\n which is equal to the desired new type.\n \u003cp\u003e\n If the original type and new type are equal, returns target.\n \u003cp\u003e\n The same conversions are allowed as for {@link MethodHandle#asType MethodHandle.asType},\n and some additional conversions are also applied if those conversions fail.\n Given types \u003cem\u003eT0\u003c/em\u003e, \u003cem\u003eT1\u003c/em\u003e, one of the following conversions is applied\n if possible, before or instead of any conversions done by {@code asType}:\n \u003cul\u003e\n \u003cli\u003eIf \u003cem\u003eT0\u003c/em\u003e and \u003cem\u003eT1\u003c/em\u003e are references, and \u003cem\u003eT1\u003c/em\u003e is an interface type,\n     then the value of type \u003cem\u003eT0\u003c/em\u003e is passed as a \u003cem\u003eT1\u003c/em\u003e without a cast.\n     (This treatment of interfaces follows the usage of the bytecode verifier.)\n \u003cli\u003eIf \u003cem\u003eT0\u003c/em\u003e is boolean and \u003cem\u003eT1\u003c/em\u003e is another primitive,\n     the boolean is converted to a byte value, 1 for true, 0 for false.\n     (This treatment follows the usage of the bytecode verifier.)\n \u003cli\u003eIf \u003cem\u003eT1\u003c/em\u003e is boolean and \u003cem\u003eT0\u003c/em\u003e is another primitive,\n     \u003cem\u003eT0\u003c/em\u003e is converted to byte via Java casting conversion (JLS 5.5),\n     and the low order bit of the result is tested, as if by {@code (x \u0026 1) !\u003d 0}.\n \u003cli\u003eIf \u003cem\u003eT0\u003c/em\u003e and \u003cem\u003eT1\u003c/em\u003e are primitives other than boolean,\n     then a Java casting conversion (JLS 5.5) is applied.\n     (Specifically, \u003cem\u003eT0\u003c/em\u003e will convert to \u003cem\u003eT1\u003c/em\u003e by\n     widening and/or narrowing.)\n \u003cli\u003eIf \u003cem\u003eT0\u003c/em\u003e is a reference and \u003cem\u003eT1\u003c/em\u003e a primitive, an unboxing\n     conversion will be applied at runtime, possibly followed\n     by a Java casting conversion (JLS 5.5) on the primitive value,\n     possibly followed by a conversion from byte to boolean by testing\n     the low-order bit.\n \u003cli\u003eIf \u003cem\u003eT0\u003c/em\u003e is a reference and \u003cem\u003eT1\u003c/em\u003e a primitive,\n     and if the reference is null at runtime, a zero value is introduced.\n \u003c/ul\u003e","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.lang.invoke.MethodHandle, java.lang.invoke.MethodType)","flatSignature":"(MethodHandle, MethodType)","returnType":{"isPrimitive":false,"simpleName":"MethodHandle","qualifiedName":"java.lang.invoke.MethodHandle","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"target","type":{"isPrimitive":false,"simpleName":"MethodHandle","qualifiedName":"java.lang.invoke.MethodHandle","dimension":"","elementType":{}}},{"name":"newType","type":{"isPrimitive":false,"simpleName":"MethodType","qualifiedName":"java.lang.invoke.MethodType","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"permuteArguments","comment":"Produces a method handle which adapts the calling sequence of the\n given method handle to a new type, by reordering the arguments.\n The resulting method handle is guaranteed to report a type\n which is equal to the desired new type.\n \u003cp\u003e\n The given array controls the reordering.\n Call {@code #I} the number of incoming parameters (the value\n {@code newType.parameterCount()}, and call {@code #O} the number\n of outgoing parameters (the value {@code target.type().parameterCount()}).\n Then the length of the reordering array must be {@code #O},\n and each element must be a non-negative number less than {@code #I}.\n For every {@code N} less than {@code #O}, the {@code N}-th\n outgoing argument will be taken from the {@code I}-th incoming\n argument, where {@code I} is {@code reorder[N]}.\n \u003cp\u003e\n No argument or return value conversions are applied.\n The type of each incoming argument, as determined by {@code newType},\n must be identical to the type of the corresponding outgoing parameter\n or parameters in the target method handle.\n The return type of {@code newType} must be identical to the return\n type of the original target.\n \u003cp\u003e\n The reordering array need not specify an actual permutation.\n An incoming argument will be duplicated if its index appears\n more than once in the array, and an incoming argument will be dropped\n if its index does not appear in the array.\n As in the case of {@link #dropArguments(MethodHandle,int,List) dropArguments},\n incoming arguments which are not mentioned in the reordering array\n are may be any type, as determined only by {@code newType}.\n \u003cblockquote\u003e\u003cpre\u003e{@code\nimport static java.lang.invoke.MethodHandles.*;\nimport static java.lang.invoke.MethodType.*;\n...\nMethodType intfn1 \u003d methodType(int.class, int.class);\nMethodType intfn2 \u003d methodType(int.class, int.class, int.class);\nMethodHandle sub \u003d ... (int x, int y) -\u003e (x-y) ...;\nassert(sub.type().equals(intfn2));\nMethodHandle sub1 \u003d permuteArguments(sub, intfn2, 0, 1);\nMethodHandle rsub \u003d permuteArguments(sub, intfn2, 1, 0);\nassert((int)rsub.invokeExact(1, 100) \u003d\u003d 99);\nMethodHandle add \u003d ... (int x, int y) -\u003e (x+y) ...;\nassert(add.type().equals(intfn2));\nMethodHandle twice \u003d permuteArguments(add, intfn1, 0, 0);\nassert(twice.type().equals(intfn1));\nassert((int)twice.invokeExact(21) \u003d\u003d 42);\n }\u003c/pre\u003e\u003c/blockquote\u003e","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.lang.invoke.MethodHandle, java.lang.invoke.MethodType, int...)","flatSignature":"(MethodHandle, MethodType, int...)","returnType":{"isPrimitive":false,"simpleName":"MethodHandle","qualifiedName":"java.lang.invoke.MethodHandle","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"target","type":{"isPrimitive":false,"simpleName":"MethodHandle","qualifiedName":"java.lang.invoke.MethodHandle","dimension":"","elementType":{}}},{"name":"newType","type":{"isPrimitive":false,"simpleName":"MethodType","qualifiedName":"java.lang.invoke.MethodType","dimension":"","elementType":{}}},{"name":"reorder","type":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"[]","elementType":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}}}}],"typeParameters":[]},{"name":"constant","comment":"Produces a method handle of the requested return type which returns the given\n constant value every time it is invoked.\n \u003cp\u003e\n Before the method handle is returned, the passed-in value is converted to the requested type.\n If the requested type is primitive, widening primitive conversions are attempted,\n else reference conversions are attempted.\n \u003cp\u003eThe returned method handle is equivalent to {@code identity(type).bindTo(value)}.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.lang.Class\u003c?\u003e, java.lang.Object)","flatSignature":"(Class\u003c?\u003e, Object)","returnType":{"isPrimitive":false,"simpleName":"MethodHandle","qualifiedName":"java.lang.invoke.MethodHandle","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"type","type":{"isPrimitive":false,"simpleName":"Class","qualifiedName":"java.lang.Class","dimension":"","elementType":{}}},{"name":"value","type":{"isPrimitive":false,"simpleName":"Object","qualifiedName":"java.lang.Object","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"identity","comment":"Produces a method handle which returns its sole argument when invoked.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.lang.Class\u003c?\u003e)","flatSignature":"(Class\u003c?\u003e)","returnType":{"isPrimitive":false,"simpleName":"MethodHandle","qualifiedName":"java.lang.invoke.MethodHandle","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"type","type":{"isPrimitive":false,"simpleName":"Class","qualifiedName":"java.lang.Class","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"insertArguments","comment":"Provides a target method handle with one or more \u003cem\u003ebound arguments\u003c/em\u003e\n in advance of the method handle\u0027s invocation.\n The formal parameters to the target corresponding to the bound\n arguments are called \u003cem\u003ebound parameters\u003c/em\u003e.\n Returns a new method handle which saves away the bound arguments.\n When it is invoked, it receives arguments for any non-bound parameters,\n binds the saved arguments to their corresponding parameters,\n and calls the original target.\n \u003cp\u003e\n The type of the new method handle will drop the types for the bound\n parameters from the original target type, since the new method handle\n will no longer require those arguments to be supplied by its callers.\n \u003cp\u003e\n Each given argument object must match the corresponding bound parameter type.\n If a bound parameter type is a primitive, the argument object\n must be a wrapper, and will be unboxed to produce the primitive value.\n \u003cp\u003e\n The {@code pos} argument selects which parameters are to be bound.\n It may range between zero and \u003ci\u003eN-L\u003c/i\u003e (inclusively),\n where \u003ci\u003eN\u003c/i\u003e is the arity of the target method handle\n and \u003ci\u003eL\u003c/i\u003e is the length of the values array.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.lang.invoke.MethodHandle, int, java.lang.Object...)","flatSignature":"(MethodHandle, int, Object...)","returnType":{"isPrimitive":false,"simpleName":"MethodHandle","qualifiedName":"java.lang.invoke.MethodHandle","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"target","type":{"isPrimitive":false,"simpleName":"MethodHandle","qualifiedName":"java.lang.invoke.MethodHandle","dimension":"","elementType":{}}},{"name":"pos","type":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}}},{"name":"values","type":{"isPrimitive":false,"simpleName":"Object","qualifiedName":"java.lang.Object","dimension":"[]","elementType":{"isPrimitive":false,"simpleName":"Object","qualifiedName":"java.lang.Object","dimension":"","elementType":{}}}}],"typeParameters":[]},{"name":"dropArguments","comment":"Produces a method handle which will discard some dummy arguments\n before calling some other specified \u003ci\u003etarget\u003c/i\u003e method handle.\n The type of the new method handle will be the same as the target\u0027s type,\n except it will also include the dummy argument types,\n at some given position.\n \u003cp\u003e\n The {@code pos} argument may range between zero and \u003ci\u003eN\u003c/i\u003e,\n where \u003ci\u003eN\u003c/i\u003e is the arity of the target.\n If {@code pos} is zero, the dummy arguments will precede\n the target\u0027s real arguments; if {@code pos} is \u003ci\u003eN\u003c/i\u003e\n they will come after.\n \u003cp\u003e\n \u003cb\u003eExample:\u003c/b\u003e\n \u003cblockquote\u003e\u003cpre\u003e{@code\nimport static java.lang.invoke.MethodHandles.*;\nimport static java.lang.invoke.MethodType.*;\n...\nMethodHandle cat \u003d lookup().findVirtual(String.class,\n  \"concat\", methodType(String.class, String.class));\nassertEquals(\"xy\", (String) cat.invokeExact(\"x\", \"y\"));\nMethodType bigType \u003d cat.type().insertParameterTypes(0, int.class, String.class);\nMethodHandle d0 \u003d dropArguments(cat, 0, bigType.parameterList().subList(0,2));\nassertEquals(bigType, d0.type());\nassertEquals(\"yz\", (String) d0.invokeExact(123, \"x\", \"y\", \"z\"));\n }\u003c/pre\u003e\u003c/blockquote\u003e\n \u003cp\u003e\n This method is also equivalent to the following code:\n \u003cblockquote\u003e\u003cpre\u003e\n {@link #dropArguments(MethodHandle,int,Class...) dropArguments}{@code (target, pos, valueTypes.toArray(new Class[0]))}\n \u003c/pre\u003e\u003c/blockquote\u003e","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.lang.invoke.MethodHandle, int, java.util.List\u003cjava.lang.Class\u003c?\u003e\u003e)","flatSignature":"(MethodHandle, int, List\u003cClass\u003c?\u003e\u003e)","returnType":{"isPrimitive":false,"simpleName":"MethodHandle","qualifiedName":"java.lang.invoke.MethodHandle","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"target","type":{"isPrimitive":false,"simpleName":"MethodHandle","qualifiedName":"java.lang.invoke.MethodHandle","dimension":"","elementType":{}}},{"name":"pos","type":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}}},{"name":"valueTypes","type":{"isPrimitive":false,"simpleName":"List","qualifiedName":"java.util.List","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"dropArguments","comment":"Produces a method handle which will discard some dummy arguments\n before calling some other specified \u003ci\u003etarget\u003c/i\u003e method handle.\n The type of the new method handle will be the same as the target\u0027s type,\n except it will also include the dummy argument types,\n at some given position.\n \u003cp\u003e\n The {@code pos} argument may range between zero and \u003ci\u003eN\u003c/i\u003e,\n where \u003ci\u003eN\u003c/i\u003e is the arity of the target.\n If {@code pos} is zero, the dummy arguments will precede\n the target\u0027s real arguments; if {@code pos} is \u003ci\u003eN\u003c/i\u003e\n they will come after.\n \u003cp\u003e\n \u003cb\u003eExample:\u003c/b\u003e\n \u003cblockquote\u003e\u003cpre\u003e{@code\nimport static java.lang.invoke.MethodHandles.*;\nimport static java.lang.invoke.MethodType.*;\n...\nMethodHandle cat \u003d lookup().findVirtual(String.class,\n  \"concat\", methodType(String.class, String.class));\nassertEquals(\"xy\", (String) cat.invokeExact(\"x\", \"y\"));\nMethodHandle d0 \u003d dropArguments(cat, 0, String.class);\nassertEquals(\"yz\", (String) d0.invokeExact(\"x\", \"y\", \"z\"));\nMethodHandle d1 \u003d dropArguments(cat, 1, String.class);\nassertEquals(\"xz\", (String) d1.invokeExact(\"x\", \"y\", \"z\"));\nMethodHandle d2 \u003d dropArguments(cat, 2, String.class);\nassertEquals(\"xy\", (String) d2.invokeExact(\"x\", \"y\", \"z\"));\nMethodHandle d12 \u003d dropArguments(cat, 1, int.class, boolean.class);\nassertEquals(\"xz\", (String) d12.invokeExact(\"x\", 12, true, \"z\"));\n }\u003c/pre\u003e\u003c/blockquote\u003e\n \u003cp\u003e\n This method is also equivalent to the following code:\n \u003cblockquote\u003e\u003cpre\u003e\n {@link #dropArguments(MethodHandle,int,List) dropArguments}{@code (target, pos, Arrays.asList(valueTypes))}\n \u003c/pre\u003e\u003c/blockquote\u003e","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.lang.invoke.MethodHandle, int, java.lang.Class\u003c?\u003e...)","flatSignature":"(MethodHandle, int, Class\u003c?\u003e...)","returnType":{"isPrimitive":false,"simpleName":"MethodHandle","qualifiedName":"java.lang.invoke.MethodHandle","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"target","type":{"isPrimitive":false,"simpleName":"MethodHandle","qualifiedName":"java.lang.invoke.MethodHandle","dimension":"","elementType":{}}},{"name":"pos","type":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}}},{"name":"valueTypes","type":{"isPrimitive":false,"simpleName":"Class","qualifiedName":"java.lang.Class","dimension":"[]","elementType":{"isPrimitive":false,"simpleName":"Class","qualifiedName":"java.lang.Class","dimension":"","elementType":{}}}}],"typeParameters":[]},{"name":"filterArguments","comment":"Adapts a target method handle by pre-processing\n one or more of its arguments, each with its own unary filter function,\n and then calling the target with each pre-processed argument\n replaced by the result of its corresponding filter function.\n \u003cp\u003e\n The pre-processing is performed by one or more method handles,\n specified in the elements of the {@code filters} array.\n The first element of the filter array corresponds to the {@code pos}\n argument of the target, and so on in sequence.\n \u003cp\u003e\n Null arguments in the array are treated as identity functions,\n and the corresponding arguments left unchanged.\n (If there are no non-null elements in the array, the original target is returned.)\n Each filter is applied to the corresponding argument of the adapter.\n \u003cp\u003e\n If a filter {@code F} applies to the {@code N}th argument of\n the target, then {@code F} must be a method handle which\n takes exactly one argument.  The type of {@code F}\u0027s sole argument\n replaces the corresponding argument type of the target\n in the resulting adapted method handle.\n The return type of {@code F} must be identical to the corresponding\n parameter type of the target.\n \u003cp\u003e\n It is an error if there are elements of {@code filters}\n (null or not)\n which do not correspond to argument positions in the target.\n \u003cp\u003e\u003cb\u003eExample:\u003c/b\u003e\n \u003cblockquote\u003e\u003cpre\u003e{@code\nimport static java.lang.invoke.MethodHandles.*;\nimport static java.lang.invoke.MethodType.*;\n...\nMethodHandle cat \u003d lookup().findVirtual(String.class,\n  \"concat\", methodType(String.class, String.class));\nMethodHandle upcase \u003d lookup().findVirtual(String.class,\n  \"toUpperCase\", methodType(String.class));\nassertEquals(\"xy\", (String) cat.invokeExact(\"x\", \"y\"));\nMethodHandle f0 \u003d filterArguments(cat, 0, upcase);\nassertEquals(\"Xy\", (String) f0.invokeExact(\"x\", \"y\")); // Xy\nMethodHandle f1 \u003d filterArguments(cat, 1, upcase);\nassertEquals(\"xY\", (String) f1.invokeExact(\"x\", \"y\")); // xY\nMethodHandle f2 \u003d filterArguments(cat, 0, upcase, upcase);\nassertEquals(\"XY\", (String) f2.invokeExact(\"x\", \"y\")); // XY\n }\u003c/pre\u003e\u003c/blockquote\u003e\n \u003cp\u003e Here is pseudocode for the resulting adapter:\n \u003cblockquote\u003e\u003cpre\u003e{@code\n V target(P... p, A[i]... a[i], B... b);\n A[i] filter[i](V[i]);\n T adapter(P... p, V[i]... v[i], B... b) {\n   return target(p..., f[i](v[i])..., b...);\n }\n }\u003c/pre\u003e\u003c/blockquote\u003e","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.lang.invoke.MethodHandle, int, java.lang.invoke.MethodHandle...)","flatSignature":"(MethodHandle, int, MethodHandle...)","returnType":{"isPrimitive":false,"simpleName":"MethodHandle","qualifiedName":"java.lang.invoke.MethodHandle","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"target","type":{"isPrimitive":false,"simpleName":"MethodHandle","qualifiedName":"java.lang.invoke.MethodHandle","dimension":"","elementType":{}}},{"name":"pos","type":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}}},{"name":"filters","type":{"isPrimitive":false,"simpleName":"MethodHandle","qualifiedName":"java.lang.invoke.MethodHandle","dimension":"[]","elementType":{"isPrimitive":false,"simpleName":"MethodHandle","qualifiedName":"java.lang.invoke.MethodHandle","dimension":"","elementType":{}}}}],"typeParameters":[]},{"name":"collectArguments","comment":"Adapts a target method handle by pre-processing\n a sub-sequence of its arguments with a filter (another method handle).\n The pre-processed arguments are replaced by the result (if any) of the\n filter function.\n The target is then called on the modified (usually shortened) argument list.\n \u003cp\u003e\n If the filter returns a value, the target must accept that value as\n its argument in position {@code pos}, preceded and/or followed by\n any arguments not passed to the filter.\n If the filter returns void, the target must accept all arguments\n not passed to the filter.\n No arguments are reordered, and a result returned from the filter\n replaces (in order) the whole subsequence of arguments originally\n passed to the adapter.\n \u003cp\u003e\n The argument types (if any) of the filter\n replace zero or one argument types of the target, at position {@code pos},\n in the resulting adapted method handle.\n The return type of the filter (if any) must be identical to the\n argument type of the target at position {@code pos}, and that target argument\n is supplied by the return value of the filter.\n \u003cp\u003e\n In all cases, {@code pos} must be greater than or equal to zero, and\n {@code pos} must also be less than or equal to the target\u0027s arity.\n \u003cp\u003e\u003cb\u003eExample:\u003c/b\u003e\n \u003cblockquote\u003e\u003cpre\u003e{@code\nimport static java.lang.invoke.MethodHandles.*;\nimport static java.lang.invoke.MethodType.*;\n...\nMethodHandle deepToString \u003d publicLookup()\n  .findStatic(Arrays.class, \"deepToString\", methodType(String.class, Object[].class));\n\nMethodHandle ts1 \u003d deepToString.asCollector(String[].class, 1);\nassertEquals(\"[strange]\", (String) ts1.invokeExact(\"strange\"));\n\nMethodHandle ts2 \u003d deepToString.asCollector(String[].class, 2);\nassertEquals(\"[up, down]\", (String) ts2.invokeExact(\"up\", \"down\"));\n\nMethodHandle ts3 \u003d deepToString.asCollector(String[].class, 3);\nMethodHandle ts3_ts2 \u003d collectArguments(ts3, 1, ts2);\nassertEquals(\"[top, [up, down], strange]\",\n             (String) ts3_ts2.invokeExact(\"top\", \"up\", \"down\", \"strange\"));\n\nMethodHandle ts3_ts2_ts1 \u003d collectArguments(ts3_ts2, 3, ts1);\nassertEquals(\"[top, [up, down], [strange]]\",\n             (String) ts3_ts2_ts1.invokeExact(\"top\", \"up\", \"down\", \"strange\"));\n\nMethodHandle ts3_ts2_ts3 \u003d collectArguments(ts3_ts2, 1, ts3);\nassertEquals(\"[top, [[up, down, strange], charm], bottom]\",\n             (String) ts3_ts2_ts3.invokeExact(\"top\", \"up\", \"down\", \"strange\", \"charm\", \"bottom\"));\n }\u003c/pre\u003e\u003c/blockquote\u003e\n \u003cp\u003e Here is pseudocode for the resulting adapter:\n \u003cblockquote\u003e\u003cpre\u003e{@code\n T target(A...,V,C...);\n V filter(B...);\n T adapter(A... a,B... b,C... c) {\n   V v \u003d filter(b...);\n   return target(a...,v,c...);\n }\n // and if the filter has no arguments:\n T target2(A...,V,C...);\n V filter2();\n T adapter2(A... a,C... c) {\n   V v \u003d filter2();\n   return target2(a...,v,c...);\n }\n // and if the filter has a void return:\n T target3(A...,C...);\n void filter3(B...);\n void adapter3(A... a,B... b,C... c) {\n   filter3(b...);\n   return target3(a...,c...);\n }\n }\u003c/pre\u003e\u003c/blockquote\u003e\n \u003cp\u003e\n A collection adapter {@code collectArguments(mh, 0, coll)} is equivalent to\n one which first \"folds\" the affected arguments, and then drops them, in separate\n steps as follows:\n \u003cblockquote\u003e\u003cpre\u003e{@code\n mh \u003d MethodHandles.dropArguments(mh, 1, coll.type().parameterList()); //step 2\n mh \u003d MethodHandles.foldArguments(mh, coll); //step 1\n }\u003c/pre\u003e\u003c/blockquote\u003e\n If the target method handle consumes no arguments besides than the result\n (if any) of the filter {@code coll}, then {@code collectArguments(mh, 0, coll)}\n is equivalent to {@code filterReturnValue(coll, mh)}.\n If the filter method handle {@code coll} consumes one argument and produces\n a non-void result, then {@code collectArguments(mh, N, coll)}\n is equivalent to {@code filterArguments(mh, N, coll)}.\n Other equivalences are possible but would require argument permutation.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.lang.invoke.MethodHandle, int, java.lang.invoke.MethodHandle)","flatSignature":"(MethodHandle, int, MethodHandle)","returnType":{"isPrimitive":false,"simpleName":"MethodHandle","qualifiedName":"java.lang.invoke.MethodHandle","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"target","type":{"isPrimitive":false,"simpleName":"MethodHandle","qualifiedName":"java.lang.invoke.MethodHandle","dimension":"","elementType":{}}},{"name":"pos","type":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}}},{"name":"filter","type":{"isPrimitive":false,"simpleName":"MethodHandle","qualifiedName":"java.lang.invoke.MethodHandle","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"filterReturnValue","comment":"Adapts a target method handle by post-processing\n its return value (if any) with a filter (another method handle).\n The result of the filter is returned from the adapter.\n \u003cp\u003e\n If the target returns a value, the filter must accept that value as\n its only argument.\n If the target returns void, the filter must accept no arguments.\n \u003cp\u003e\n The return type of the filter\n replaces the return type of the target\n in the resulting adapted method handle.\n The argument type of the filter (if any) must be identical to the\n return type of the target.\n \u003cp\u003e\u003cb\u003eExample:\u003c/b\u003e\n \u003cblockquote\u003e\u003cpre\u003e{@code\nimport static java.lang.invoke.MethodHandles.*;\nimport static java.lang.invoke.MethodType.*;\n...\nMethodHandle cat \u003d lookup().findVirtual(String.class,\n  \"concat\", methodType(String.class, String.class));\nMethodHandle length \u003d lookup().findVirtual(String.class,\n  \"length\", methodType(int.class));\nSystem.out.println((String) cat.invokeExact(\"x\", \"y\")); // xy\nMethodHandle f0 \u003d filterReturnValue(cat, length);\nSystem.out.println((int) f0.invokeExact(\"x\", \"y\")); // 2\n }\u003c/pre\u003e\u003c/blockquote\u003e\n \u003cp\u003e Here is pseudocode for the resulting adapter:\n \u003cblockquote\u003e\u003cpre\u003e{@code\n V target(A...);\n T filter(V);\n T adapter(A... a) {\n   V v \u003d target(a...);\n   return filter(v);\n }\n // and if the target has a void return:\n void target2(A...);\n T filter2();\n T adapter2(A... a) {\n   target2(a...);\n   return filter2();\n }\n // and if the filter has a void return:\n V target3(A...);\n void filter3(V);\n void adapter3(A... a) {\n   V v \u003d target3(a...);\n   filter3(v);\n }\n }\u003c/pre\u003e\u003c/blockquote\u003e","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.lang.invoke.MethodHandle, java.lang.invoke.MethodHandle)","flatSignature":"(MethodHandle, MethodHandle)","returnType":{"isPrimitive":false,"simpleName":"MethodHandle","qualifiedName":"java.lang.invoke.MethodHandle","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"target","type":{"isPrimitive":false,"simpleName":"MethodHandle","qualifiedName":"java.lang.invoke.MethodHandle","dimension":"","elementType":{}}},{"name":"filter","type":{"isPrimitive":false,"simpleName":"MethodHandle","qualifiedName":"java.lang.invoke.MethodHandle","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"foldArguments","comment":"Adapts a target method handle by pre-processing\n some of its arguments, and then calling the target with\n the result of the pre-processing, inserted into the original\n sequence of arguments.\n \u003cp\u003e\n The pre-processing is performed by {@code combiner}, a second method handle.\n Of the arguments passed to the adapter, the first {@code N} arguments\n are copied to the combiner, which is then called.\n (Here, {@code N} is defined as the parameter count of the combiner.)\n After this, control passes to the target, with any result\n from the combiner inserted before the original {@code N} incoming\n arguments.\n \u003cp\u003e\n If the combiner returns a value, the first parameter type of the target\n must be identical with the return type of the combiner, and the next\n {@code N} parameter types of the target must exactly match the parameters\n of the combiner.\n \u003cp\u003e\n If the combiner has a void return, no result will be inserted,\n and the first {@code N} parameter types of the target\n must exactly match the parameters of the combiner.\n \u003cp\u003e\n The resulting adapter is the same type as the target, except that the\n first parameter type is dropped,\n if it corresponds to the result of the combiner.\n \u003cp\u003e\n (Note that {@link #dropArguments(MethodHandle,int,List) dropArguments} can be used to remove any arguments\n that either the combiner or the target does not wish to receive.\n If some of the incoming arguments are destined only for the combiner,\n consider using {@link MethodHandle#asCollector asCollector} instead, since those\n arguments will not need to be live on the stack on entry to the\n target.)\n \u003cp\u003e\u003cb\u003eExample:\u003c/b\u003e\n \u003cblockquote\u003e\u003cpre\u003e{@code\nimport static java.lang.invoke.MethodHandles.*;\nimport static java.lang.invoke.MethodType.*;\n...\nMethodHandle trace \u003d publicLookup().findVirtual(java.io.PrintStream.class,\n  \"println\", methodType(void.class, String.class))\n    .bindTo(System.out);\nMethodHandle cat \u003d lookup().findVirtual(String.class,\n  \"concat\", methodType(String.class, String.class));\nassertEquals(\"boojum\", (String) cat.invokeExact(\"boo\", \"jum\"));\nMethodHandle catTrace \u003d foldArguments(cat, trace);\n// also prints \"boo\":\nassertEquals(\"boojum\", (String) catTrace.invokeExact(\"boo\", \"jum\"));\n }\u003c/pre\u003e\u003c/blockquote\u003e\n \u003cp\u003e Here is pseudocode for the resulting adapter:\n \u003cblockquote\u003e\u003cpre\u003e{@code\n // there are N arguments in A...\n T target(V, A[N]..., B...);\n V combiner(A...);\n T adapter(A... a, B... b) {\n   V v \u003d combiner(a...);\n   return target(v, a..., b...);\n }\n // and if the combiner has a void return:\n T target2(A[N]..., B...);\n void combiner2(A...);\n T adapter2(A... a, B... b) {\n   combiner2(a...);\n   return target2(a..., b...);\n }\n }\u003c/pre\u003e\u003c/blockquote\u003e","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.lang.invoke.MethodHandle, java.lang.invoke.MethodHandle)","flatSignature":"(MethodHandle, MethodHandle)","returnType":{"isPrimitive":false,"simpleName":"MethodHandle","qualifiedName":"java.lang.invoke.MethodHandle","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"target","type":{"isPrimitive":false,"simpleName":"MethodHandle","qualifiedName":"java.lang.invoke.MethodHandle","dimension":"","elementType":{}}},{"name":"combiner","type":{"isPrimitive":false,"simpleName":"MethodHandle","qualifiedName":"java.lang.invoke.MethodHandle","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"guardWithTest","comment":"Makes a method handle which adapts a target method handle,\n by guarding it with a test, a boolean-valued method handle.\n If the guard fails, a fallback handle is called instead.\n All three method handles must have the same corresponding\n argument and return types, except that the return type\n of the test must be boolean, and the test is allowed\n to have fewer arguments than the other two method handles.\n \u003cp\u003e Here is pseudocode for the resulting adapter:\n \u003cblockquote\u003e\u003cpre\u003e{@code\n boolean test(A...);\n T target(A...,B...);\n T fallback(A...,B...);\n T adapter(A... a,B... b) {\n   if (test(a...))\n     return target(a..., b...);\n   else\n     return fallback(a..., b...);\n }\n }\u003c/pre\u003e\u003c/blockquote\u003e\n Note that the test arguments ({@code a...} in the pseudocode) cannot\n be modified by execution of the test, and so are passed unchanged\n from the caller to the target or fallback as appropriate.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.lang.invoke.MethodHandle, java.lang.invoke.MethodHandle, java.lang.invoke.MethodHandle)","flatSignature":"(MethodHandle, MethodHandle, MethodHandle)","returnType":{"isPrimitive":false,"simpleName":"MethodHandle","qualifiedName":"java.lang.invoke.MethodHandle","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"test","type":{"isPrimitive":false,"simpleName":"MethodHandle","qualifiedName":"java.lang.invoke.MethodHandle","dimension":"","elementType":{}}},{"name":"target","type":{"isPrimitive":false,"simpleName":"MethodHandle","qualifiedName":"java.lang.invoke.MethodHandle","dimension":"","elementType":{}}},{"name":"fallback","type":{"isPrimitive":false,"simpleName":"MethodHandle","qualifiedName":"java.lang.invoke.MethodHandle","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"catchException","comment":"Makes a method handle which adapts a target method handle,\n by running it inside an exception handler.\n If the target returns normally, the adapter returns that value.\n If an exception matching the specified type is thrown, the fallback\n handle is called instead on the exception, plus the original arguments.\n \u003cp\u003e\n The target and handler must have the same corresponding\n argument and return types, except that handler may omit trailing arguments\n (similarly to the predicate in {@link #guardWithTest guardWithTest}).\n Also, the handler must have an extra leading parameter of {@code exType} or a supertype.\n \u003cp\u003e Here is pseudocode for the resulting adapter:\n \u003cblockquote\u003e\u003cpre\u003e{@code\n T target(A..., B...);\n T handler(ExType, A...);\n T adapter(A... a, B... b) {\n   try {\n     return target(a..., b...);\n   } catch (ExType ex) {\n     return handler(ex, a...);\n   }\n }\n }\u003c/pre\u003e\u003c/blockquote\u003e\n Note that the saved arguments ({@code a...} in the pseudocode) cannot\n be modified by execution of the target, and so are passed unchanged\n from the caller to the handler, if the handler is invoked.\n \u003cp\u003e\n The target and handler must return the same type, even if the handler\n always throws.  (This might happen, for instance, because the handler\n is simulating a {@code finally} clause).\n To create such a throwing handler, compose the handler creation logic\n with {@link #throwException throwException},\n in order to create a method handle of the correct return type.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.lang.invoke.MethodHandle, java.lang.Class\u003c? extends java.lang.Throwable\u003e, java.lang.invoke.MethodHandle)","flatSignature":"(MethodHandle, Class\u003c? extends Throwable\u003e, MethodHandle)","returnType":{"isPrimitive":false,"simpleName":"MethodHandle","qualifiedName":"java.lang.invoke.MethodHandle","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"target","type":{"isPrimitive":false,"simpleName":"MethodHandle","qualifiedName":"java.lang.invoke.MethodHandle","dimension":"","elementType":{}}},{"name":"exType","type":{"isPrimitive":false,"simpleName":"Class","qualifiedName":"java.lang.Class","dimension":"","elementType":{}}},{"name":"handler","type":{"isPrimitive":false,"simpleName":"MethodHandle","qualifiedName":"java.lang.invoke.MethodHandle","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"throwException","comment":"Produces a method handle which will throw exceptions of the given {@code exType}.\n The method handle will accept a single argument of {@code exType},\n and immediately throw it as an exception.\n The method type will nominally specify a return of {@code returnType}.\n The return type may be anything convenient:  It doesn\u0027t matter to the\n method handle\u0027s behavior, since it will never return normally.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.lang.Class\u003c?\u003e, java.lang.Class\u003c? extends java.lang.Throwable\u003e)","flatSignature":"(Class\u003c?\u003e, Class\u003c? extends Throwable\u003e)","returnType":{"isPrimitive":false,"simpleName":"MethodHandle","qualifiedName":"java.lang.invoke.MethodHandle","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"returnType","type":{"isPrimitive":false,"simpleName":"Class","qualifiedName":"java.lang.Class","dimension":"","elementType":{}}},{"name":"exType","type":{"isPrimitive":false,"simpleName":"Class","qualifiedName":"java.lang.Class","dimension":"","elementType":{}}}],"typeParameters":[]}],"typeParameters":[],"enumConstants":[]}