{"name":"Throwable","comment":"The {@code Throwable} class is the superclass of all errors and\n exceptions in the Java language. Only objects that are instances of this\n class (or one of its subclasses) are thrown by the Java Virtual Machine or\n can be thrown by the Java {@code throw} statement. Similarly, only\n this class or one of its subclasses can be the argument type in a\n {@code catch} clause.\n\n For the purposes of compile-time checking of exceptions, {@code\n Throwable} and any subclass of {@code Throwable} that is not also a\n subclass of either {@link RuntimeException} or {@link Error} are\n regarded as checked exceptions.\n\n \u003cp\u003eInstances of two subclasses, {@link java.lang.Error} and\n {@link java.lang.Exception}, are conventionally used to indicate\n that exceptional situations have occurred. Typically, these instances\n are freshly created in the context of the exceptional situation so\n as to include relevant information (such as stack trace data).\n\n \u003cp\u003eA throwable contains a snapshot of the execution stack of its\n thread at the time it was created. It can also contain a message\n string that gives more information about the error. Over time, a\n throwable can {@linkplain Throwable#addSuppressed suppress} other\n throwables from being propagated.  Finally, the throwable can also\n contain a \u003ci\u003ecause\u003c/i\u003e: another throwable that caused this\n throwable to be constructed.  The recording of this causal information\n is referred to as the \u003ci\u003echained exception\u003c/i\u003e facility, as the\n cause can, itself, have a cause, and so on, leading to a \"chain\" of\n exceptions, each caused by another.\n\n \u003cp\u003eOne reason that a throwable may have a cause is that the class that\n throws it is built atop a lower layered abstraction, and an operation on\n the upper layer fails due to a failure in the lower layer.  It would be bad\n design to let the throwable thrown by the lower layer propagate outward, as\n it is generally unrelated to the abstraction provided by the upper layer.\n Further, doing so would tie the API of the upper layer to the details of\n its implementation, assuming the lower layer\u0027s exception was a checked\n exception.  Throwing a \"wrapped exception\" (i.e., an exception containing a\n cause) allows the upper layer to communicate the details of the failure to\n its caller without incurring either of these shortcomings.  It preserves\n the flexibility to change the implementation of the upper layer without\n changing its API (in particular, the set of exceptions thrown by its\n methods).\n\n \u003cp\u003eA second reason that a throwable may have a cause is that the method\n that throws it must conform to a general-purpose interface that does not\n permit the method to throw the cause directly.  For example, suppose\n a persistent collection conforms to the {@link java.util.Collection\n Collection} interface, and that its persistence is implemented atop\n {@code java.io}.  Suppose the internals of the {@code add} method\n can throw an {@link java.io.IOException IOException}.  The implementation\n can communicate the details of the {@code IOException} to its caller\n while conforming to the {@code Collection} interface by wrapping the\n {@code IOException} in an appropriate unchecked exception.  (The\n specification for the persistent collection should indicate that it is\n capable of throwing such exceptions.)\n\n \u003cp\u003eA cause can be associated with a throwable in two ways: via a\n constructor that takes the cause as an argument, or via the\n {@link #initCause(Throwable)} method.  New throwable classes that\n wish to allow causes to be associated with them should provide constructors\n that take a cause and delegate (perhaps indirectly) to one of the\n {@code Throwable} constructors that takes a cause.\n\n Because the {@code initCause} method is public, it allows a cause to be\n associated with any throwable, even a \"legacy throwable\" whose\n implementation predates the addition of the exception chaining mechanism to\n {@code Throwable}.\n\n \u003cp\u003eBy convention, class {@code Throwable} and its subclasses have two\n constructors, one that takes no arguments and one that takes a\n {@code String} argument that can be used to produce a detail message.\n Further, those subclasses that might likely have a cause associated with\n them should have two more constructors, one that takes a\n {@code Throwable} (the cause), and one that takes a\n {@code String} (the detail message) and a {@code Throwable} (the\n cause).","isClass":true,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":false,"isOrdinaryClass":true,"isPrimitive":false,"simpleName":"Throwable","qualifiedName":"java.lang.Throwable","dimension":"","elementType":{},"package":"java.lang","superclass":"java.lang.Object","interfaces":["java.io.Serializable"],"isAbstract":false,"isStatic":false,"since":"JDK1.0","innerClasses":[],"isInnerClass":false,"constructors":[{"name":"Throwable","comment":"Constructs a new throwable with {@code null} as its detail message.\n The cause is not initialized, and may subsequently be initialized by a\n call to {@link #initCause}.\n\n \u003cp\u003eThe {@link #fillInStackTrace()} method is called to initialize\n the stack trace data in the newly created throwable.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":true,"isField":false,"isMethod":false,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","parameters":[],"typeParameters":[]},{"name":"Throwable","comment":"Constructs a new throwable with the specified detail message.  The\n cause is not initialized, and may subsequently be initialized by\n a call to {@link #initCause}.\n\n \u003cp\u003eThe {@link #fillInStackTrace()} method is called to initialize\n the stack trace data in the newly created throwable.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":true,"isField":false,"isMethod":false,"isOrdinaryClass":false,"signature":"(java.lang.String)","flatSignature":"(String)","parameters":[{"name":"message","type":{"isPrimitive":false,"simpleName":"String","qualifiedName":"java.lang.String","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"Throwable","comment":"Constructs a new throwable with the specified detail message and\n cause.  \u003cp\u003eNote that the detail message associated with\n {@code cause} is \u003ci\u003enot\u003c/i\u003e automatically incorporated in\n this throwable\u0027s detail message.\n\n \u003cp\u003eThe {@link #fillInStackTrace()} method is called to initialize\n the stack trace data in the newly created throwable.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":true,"isField":false,"isMethod":false,"isOrdinaryClass":false,"signature":"(java.lang.String, java.lang.Throwable)","flatSignature":"(String, Throwable)","parameters":[{"name":"message","type":{"isPrimitive":false,"simpleName":"String","qualifiedName":"java.lang.String","dimension":"","elementType":{}}},{"name":"cause","type":{"isPrimitive":false,"simpleName":"Throwable","qualifiedName":"java.lang.Throwable","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"Throwable","comment":"Constructs a new throwable with the specified cause and a detail\n message of {@code (cause\u003d\u003dnull ? null : cause.toString())} (which\n typically contains the class and detail message of {@code cause}).\n This constructor is useful for throwables that are little more than\n wrappers for other throwables (for example, {@link\n java.security.PrivilegedActionException}).\n\n \u003cp\u003eThe {@link #fillInStackTrace()} method is called to initialize\n the stack trace data in the newly created throwable.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":true,"isField":false,"isMethod":false,"isOrdinaryClass":false,"signature":"(java.lang.Throwable)","flatSignature":"(Throwable)","parameters":[{"name":"cause","type":{"isPrimitive":false,"simpleName":"Throwable","qualifiedName":"java.lang.Throwable","dimension":"","elementType":{}}}],"typeParameters":[]}],"fields":[],"methods":[{"name":"getMessage","comment":"Returns the detail message string of this throwable.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":false,"simpleName":"String","qualifiedName":"java.lang.String","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[],"typeParameters":[]},{"name":"getLocalizedMessage","comment":"Creates a localized description of this throwable.\n Subclasses may override this method in order to produce a\n locale-specific message.  For subclasses that do not override this\n method, the default implementation returns the same result as\n {@code getMessage()}.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":false,"simpleName":"String","qualifiedName":"java.lang.String","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[],"typeParameters":[]},{"name":"getCause","comment":"Returns the cause of this throwable or {@code null} if the\n cause is nonexistent or unknown.  (The cause is the throwable that\n caused this throwable to get thrown.)\n\n \u003cp\u003eThis implementation returns the cause that was supplied via one of\n the constructors requiring a {@code Throwable}, or that was set after\n creation with the {@link #initCause(Throwable)} method.  While it is\n typically unnecessary to override this method, a subclass can override\n it to return a cause set by some other means.  This is appropriate for\n a \"legacy chained throwable\" that predates the addition of chained\n exceptions to {@code Throwable}.  Note that it is \u003ci\u003enot\u003c/i\u003e\n necessary to override any of the {@code PrintStackTrace} methods,\n all of which invoke the {@code getCause} method to determine the\n cause of a throwable.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":false,"simpleName":"Throwable","qualifiedName":"java.lang.Throwable","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[],"typeParameters":[]},{"name":"initCause","comment":"Initializes the \u003ci\u003ecause\u003c/i\u003e of this throwable to the specified value.\n (The cause is the throwable that caused this throwable to get thrown.)\n\n \u003cp\u003eThis method can be called at most once.  It is generally called from\n within the constructor, or immediately after creating the\n throwable.  If this throwable was created\n with {@link #Throwable(Throwable)} or\n {@link #Throwable(String,Throwable)}, this method cannot be called\n even once.\n\n \u003cp\u003eAn example of using this method on a legacy throwable type\n without other support for setting the cause is:\n\n \u003cpre\u003e\n try {\n     lowLevelOp();\n } catch (LowLevelException le) {\n     throw (HighLevelException)\n           new HighLevelException().initCause(le); // Legacy constructor\n }\n \u003c/pre\u003e","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.lang.Throwable)","flatSignature":"(Throwable)","returnType":{"isPrimitive":false,"simpleName":"Throwable","qualifiedName":"java.lang.Throwable","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[{"name":"cause","type":{"isPrimitive":false,"simpleName":"Throwable","qualifiedName":"java.lang.Throwable","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"toString","comment":"Returns a short description of this throwable.\n The result is the concatenation of:\n \u003cul\u003e\n \u003cli\u003e the {@linkplain Class#getName() name} of the class of this object\n \u003cli\u003e \": \" (a colon and a space)\n \u003cli\u003e the result of invoking this object\u0027s {@link #getLocalizedMessage}\n      method\n \u003c/ul\u003e\n If {@code getLocalizedMessage} returns {@code null}, then just\n the class name is returned.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":false,"simpleName":"String","qualifiedName":"java.lang.String","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[],"typeParameters":[]},{"name":"printStackTrace","comment":"Prints this throwable and its backtrace to the\n standard error stream. This method prints a stack trace for this\n {@code Throwable} object on the error output stream that is\n the value of the field {@code System.err}. The first line of\n output contains the result of the {@link #toString()} method for\n this object.  Remaining lines represent data previously recorded by\n the method {@link #fillInStackTrace()}. The format of this\n information depends on the implementation, but the following\n example may be regarded as typical:\n \u003cblockquote\u003e\u003cpre\u003e\n java.lang.NullPointerException\n         at MyClass.mash(MyClass.java:9)\n         at MyClass.crunch(MyClass.java:6)\n         at MyClass.main(MyClass.java:3)\n \u003c/pre\u003e\u003c/blockquote\u003e\n This example was produced by running the program:\n \u003cpre\u003e\n class MyClass {\n     public static void main(String[] args) {\n         crunch(null);\n     }\n     static void crunch(int[] a) {\n         mash(a);\n     }\n     static void mash(int[] b) {\n         System.out.println(b[0]);\n     }\n }\n \u003c/pre\u003e\n The backtrace for a throwable with an initialized, non-null cause\n should generally include the backtrace for the cause.  The format\n of this information depends on the implementation, but the following\n example may be regarded as typical:\n \u003cpre\u003e\n HighLevelException: MidLevelException: LowLevelException\n         at Junk.a(Junk.java:13)\n         at Junk.main(Junk.java:4)\n Caused by: MidLevelException: LowLevelException\n         at Junk.c(Junk.java:23)\n         at Junk.b(Junk.java:17)\n         at Junk.a(Junk.java:11)\n         ... 1 more\n Caused by: LowLevelException\n         at Junk.e(Junk.java:30)\n         at Junk.d(Junk.java:27)\n         at Junk.c(Junk.java:21)\n         ... 3 more\n \u003c/pre\u003e\n Note the presence of lines containing the characters {@code \"...\"}.\n These lines indicate that the remainder of the stack trace for this\n exception matches the indicated number of frames from the bottom of the\n stack trace of the exception that was caused by this exception (the\n \"enclosing\" exception).  This shorthand can greatly reduce the length\n of the output in the common case where a wrapped exception is thrown\n from same method as the \"causative exception\" is caught.  The above\n example was produced by running the program:\n \u003cpre\u003e\n public class Junk {\n     public static void main(String args[]) {\n         try {\n             a();\n         } catch(HighLevelException e) {\n             e.printStackTrace();\n         }\n     }\n     static void a() throws HighLevelException {\n         try {\n             b();\n         } catch(MidLevelException e) {\n             throw new HighLevelException(e);\n         }\n     }\n     static void b() throws MidLevelException {\n         c();\n     }\n     static void c() throws MidLevelException {\n         try {\n             d();\n         } catch(LowLevelException e) {\n             throw new MidLevelException(e);\n         }\n     }\n     static void d() throws LowLevelException {\n        e();\n     }\n     static void e() throws LowLevelException {\n         throw new LowLevelException();\n     }\n }\n\n class HighLevelException extends Exception {\n     HighLevelException(Throwable cause) { super(cause); }\n }\n\n class MidLevelException extends Exception {\n     MidLevelException(Throwable cause)  { super(cause); }\n }\n\n class LowLevelException extends Exception {\n }\n \u003c/pre\u003e\n As of release 7, the platform supports the notion of\n \u003ci\u003esuppressed exceptions\u003c/i\u003e (in conjunction with the {@code\n try}-with-resources statement). Any exceptions that were\n suppressed in order to deliver an exception are printed out\n beneath the stack trace.  The format of this information\n depends on the implementation, but the following example may be\n regarded as typical:\n\n \u003cpre\u003e\n Exception in thread \"main\" java.lang.Exception: Something happened\n  at Foo.bar(Foo.java:10)\n  at Foo.main(Foo.java:5)\n  Suppressed: Resource$CloseFailException: Resource ID \u003d 0\n          at Resource.close(Resource.java:26)\n          at Foo.bar(Foo.java:9)\n          ... 1 more\n \u003c/pre\u003e\n Note that the \"... n more\" notation is used on suppressed exceptions\n just at it is used on causes. Unlike causes, suppressed exceptions are\n indented beyond their \"containing exceptions.\"\n\n \u003cp\u003eAn exception can have both a cause and one or more suppressed\n exceptions:\n \u003cpre\u003e\n Exception in thread \"main\" java.lang.Exception: Main block\n  at Foo3.main(Foo3.java:7)\n  Suppressed: Resource$CloseFailException: Resource ID \u003d 2\n          at Resource.close(Resource.java:26)\n          at Foo3.main(Foo3.java:5)\n  Suppressed: Resource$CloseFailException: Resource ID \u003d 1\n          at Resource.close(Resource.java:26)\n          at Foo3.main(Foo3.java:5)\n Caused by: java.lang.Exception: I did it\n  at Foo3.main(Foo3.java:8)\n \u003c/pre\u003e\n Likewise, a suppressed exception can have a cause:\n \u003cpre\u003e\n Exception in thread \"main\" java.lang.Exception: Main block\n  at Foo4.main(Foo4.java:6)\n  Suppressed: Resource2$CloseFailException: Resource ID \u003d 1\n          at Resource2.close(Resource2.java:20)\n          at Foo4.main(Foo4.java:5)\n  Caused by: java.lang.Exception: Rats, you caught me\n          at Resource2$CloseFailException.\u0026lt;init\u0026gt;(Resource2.java:45)\n          ... 2 more\n \u003c/pre\u003e","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":true,"simpleName":"void","qualifiedName":"void","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[],"typeParameters":[]},{"name":"printStackTrace","comment":"Prints this throwable and its backtrace to the specified print stream.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.io.PrintStream)","flatSignature":"(PrintStream)","returnType":{"isPrimitive":true,"simpleName":"void","qualifiedName":"void","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[{"name":"s","type":{"isPrimitive":false,"simpleName":"PrintStream","qualifiedName":"java.io.PrintStream","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"printStackTrace","comment":"Prints this throwable and its backtrace to the specified\n print writer.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.io.PrintWriter)","flatSignature":"(PrintWriter)","returnType":{"isPrimitive":true,"simpleName":"void","qualifiedName":"void","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[{"name":"s","type":{"isPrimitive":false,"simpleName":"PrintWriter","qualifiedName":"java.io.PrintWriter","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"fillInStackTrace","comment":"Fills in the execution stack trace. This method records within this\n {@code Throwable} object information about the current state of\n the stack frames for the current thread.\n\n \u003cp\u003eIf the stack trace of this {@code Throwable} {@linkplain\n Throwable#Throwable(String, Throwable, boolean, boolean) is not\n writable}, calling this method has no effect.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":false,"simpleName":"Throwable","qualifiedName":"java.lang.Throwable","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[],"typeParameters":[]},{"name":"getStackTrace","comment":"Provides programmatic access to the stack trace information printed by\n {@link #printStackTrace()}.  Returns an array of stack trace elements,\n each representing one stack frame.  The zeroth element of the array\n (assuming the array\u0027s length is non-zero) represents the top of the\n stack, which is the last method invocation in the sequence.  Typically,\n this is the point at which this throwable was created and thrown.\n The last element of the array (assuming the array\u0027s length is non-zero)\n represents the bottom of the stack, which is the first method invocation\n in the sequence.\n\n \u003cp\u003eSome virtual machines may, under some circumstances, omit one\n or more stack frames from the stack trace.  In the extreme case,\n a virtual machine that has no stack trace information concerning\n this throwable is permitted to return a zero-length array from this\n method.  Generally speaking, the array returned by this method will\n contain one element for every frame that would be printed by\n {@code printStackTrace}.  Writes to the returned array do not\n affect future calls to this method.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":false,"simpleName":"StackTraceElement","qualifiedName":"java.lang.StackTraceElement","dimension":"[]","elementType":{"isPrimitive":false,"simpleName":"StackTraceElement","qualifiedName":"java.lang.StackTraceElement","dimension":"","elementType":{}}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[],"typeParameters":[]},{"name":"setStackTrace","comment":"Sets the stack trace elements that will be returned by\n {@link #getStackTrace()} and printed by {@link #printStackTrace()}\n and related methods.\n\n This method, which is designed for use by RPC frameworks and other\n advanced systems, allows the client to override the default\n stack trace that is either generated by {@link #fillInStackTrace()}\n when a throwable is constructed or deserialized when a throwable is\n read from a serialization stream.\n\n \u003cp\u003eIf the stack trace of this {@code Throwable} {@linkplain\n Throwable#Throwable(String, Throwable, boolean, boolean) is not\n writable}, calling this method has no effect other than\n validating its argument.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.lang.StackTraceElement[])","flatSignature":"(StackTraceElement[])","returnType":{"isPrimitive":true,"simpleName":"void","qualifiedName":"void","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[{"name":"stackTrace","type":{"isPrimitive":false,"simpleName":"StackTraceElement","qualifiedName":"java.lang.StackTraceElement","dimension":"[]","elementType":{"isPrimitive":false,"simpleName":"StackTraceElement","qualifiedName":"java.lang.StackTraceElement","dimension":"","elementType":{}}}}],"typeParameters":[]},{"name":"addSuppressed","comment":"Appends the specified exception to the exceptions that were\n suppressed in order to deliver this exception. This method is\n thread-safe and typically called (automatically and implicitly)\n by the {@code try}-with-resources statement.\n\n \u003cp\u003eThe suppression behavior is enabled \u003cem\u003eunless\u003c/em\u003e disabled\n {@linkplain #Throwable(String, Throwable, boolean, boolean) via\n a constructor}.  When suppression is disabled, this method does\n nothing other than to validate its argument.\n\n \u003cp\u003eNote that when one exception {@linkplain\n #initCause(Throwable) causes} another exception, the first\n exception is usually caught and then the second exception is\n thrown in response.  In other words, there is a causal\n connection between the two exceptions.\n\n In contrast, there are situations where two independent\n exceptions can be thrown in sibling code blocks, in particular\n in the {@code try} block of a {@code try}-with-resources\n statement and the compiler-generated {@code finally} block\n which closes the resource.\n\n In these situations, only one of the thrown exceptions can be\n propagated.  In the {@code try}-with-resources statement, when\n there are two such exceptions, the exception originating from\n the {@code try} block is propagated and the exception from the\n {@code finally} block is added to the list of exceptions\n suppressed by the exception from the {@code try} block.  As an\n exception unwinds the stack, it can accumulate multiple\n suppressed exceptions.\n\n \u003cp\u003eAn exception may have suppressed exceptions while also being\n caused by another exception.  Whether or not an exception has a\n cause is semantically known at the time of its creation, unlike\n whether or not an exception will suppress other exceptions\n which is typically only determined after an exception is\n thrown.\n\n \u003cp\u003eNote that programmer written code is also able to take\n advantage of calling this method in situations where there are\n multiple sibling exceptions and only one can be propagated.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.lang.Throwable)","flatSignature":"(Throwable)","returnType":{"isPrimitive":true,"simpleName":"void","qualifiedName":"void","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[{"name":"exception","type":{"isPrimitive":false,"simpleName":"Throwable","qualifiedName":"java.lang.Throwable","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"getSuppressed","comment":"Returns an array containing all of the exceptions that were\n suppressed, typically by the {@code try}-with-resources\n statement, in order to deliver this exception.\n\n If no exceptions were suppressed or {@linkplain\n #Throwable(String, Throwable, boolean, boolean) suppression is\n disabled}, an empty array is returned.  This method is\n thread-safe.  Writes to the returned array do not affect future\n calls to this method.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":false,"simpleName":"Throwable","qualifiedName":"java.lang.Throwable","dimension":"[]","elementType":{"isPrimitive":false,"simpleName":"Throwable","qualifiedName":"java.lang.Throwable","dimension":"","elementType":{}}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[],"typeParameters":[]}],"typeParameters":[],"subClasses":["java.lang.Exception","java.lang.Error"],"enumConstants":[]}