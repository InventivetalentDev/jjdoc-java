{"name":"Instrumentation","comment":"This class provides services needed to instrument Java\n programming language code.\n Instrumentation is the addition of byte-codes to methods for the\n purpose of gathering data to be utilized by tools.\n Since the changes are purely additive, these tools do not modify\n application state or behavior.\n Examples of such benign tools include monitoring agents, profilers,\n coverage analyzers, and event loggers.\n\n \u003cP\u003e\n There are two ways to obtain an instance of the\n \u003ccode\u003eInstrumentation\u003c/code\u003e interface:\n\n \u003col\u003e\n   \u003cli\u003e\u003cp\u003e When a JVM is launched in a way that indicates an agent\n     class. In that case an \u003ccode\u003eInstrumentation\u003c/code\u003e instance\n     is passed to the \u003ccode\u003epremain\u003c/code\u003e method of the agent class.\n     \u003c/p\u003e\u003c/li\u003e\n   \u003cli\u003e\u003cp\u003e When a JVM provides a mechanism to start agents sometime\n     after the JVM is launched. In that case an \u003ccode\u003eInstrumentation\u003c/code\u003e\n     instance is passed to the \u003ccode\u003eagentmain\u003c/code\u003e method of the\n     agent code. \u003c/p\u003e \u003c/li\u003e\n \u003c/ol\u003e\n \u003cp\u003e\n These mechanisms are described in the\n {@linkplain java.lang.instrument package specification}.\n \u003cp\u003e\n Once an agent acquires an \u003ccode\u003eInstrumentation\u003c/code\u003e instance,\n the agent may call methods on the instance at any time.","isClass":false,"isInterface":true,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":false,"isOrdinaryClass":false,"isPrimitive":false,"simpleName":"Instrumentation","qualifiedName":"java.lang.instrument.Instrumentation","dimension":"","elementType":{},"package":"java.lang.instrument","interfaces":[],"isAbstract":true,"isStatic":false,"since":"1.5","innerClasses":[],"isInnerClass":false,"constructors":[],"fields":[],"methods":[{"name":"addTransformer","comment":"Registers the supplied transformer. All future class definitions\n will be seen by the transformer, except definitions of classes upon which any\n registered transformer is dependent.\n The transformer is called when classes are loaded, when they are\n {@linkplain #redefineClasses redefined}. and if \u003ccode\u003ecanRetransform\u003c/code\u003e is true,\n when they are {@linkplain #retransformClasses retransformed}.\n See {@link java.lang.instrument.ClassFileTransformer#transform\n ClassFileTransformer.transform} for the order\n of transform calls.\n If a transformer throws\n an exception during execution, the JVM will still call the other registered\n transformers in order. The same transformer may be added more than once,\n but it is strongly discouraged -- avoid this by creating a new instance of\n transformer class.\n \u003cP\u003e\n This method is intended for use in instrumentation, as described in the\n {@linkplain Instrumentation class specification}.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.lang.instrument.ClassFileTransformer, boolean)","flatSignature":"(ClassFileTransformer, boolean)","returnType":{"isPrimitive":true,"simpleName":"void","qualifiedName":"void","dimension":"","elementType":{}},"isAbstract":true,"isDefault":false,"isStatic":false,"parameters":[{"name":"transformer","type":{"isPrimitive":false,"simpleName":"ClassFileTransformer","qualifiedName":"java.lang.instrument.ClassFileTransformer","dimension":"","elementType":{}}},{"name":"canRetransform","type":{"isPrimitive":true,"simpleName":"boolean","qualifiedName":"boolean","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"addTransformer","comment":"Registers the supplied transformer.\n \u003cP\u003e\n Same as \u003ccode\u003eaddTransformer(transformer, false)\u003c/code\u003e.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.lang.instrument.ClassFileTransformer)","flatSignature":"(ClassFileTransformer)","returnType":{"isPrimitive":true,"simpleName":"void","qualifiedName":"void","dimension":"","elementType":{}},"isAbstract":true,"isDefault":false,"isStatic":false,"parameters":[{"name":"transformer","type":{"isPrimitive":false,"simpleName":"ClassFileTransformer","qualifiedName":"java.lang.instrument.ClassFileTransformer","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"removeTransformer","comment":"Unregisters the supplied transformer. Future class definitions will\n not be shown to the transformer. Removes the most-recently-added matching\n instance of the transformer. Due to the multi-threaded nature of\n class loading, it is possible for a transformer to receive calls\n after it has been removed. Transformers should be written defensively\n to expect this situation.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.lang.instrument.ClassFileTransformer)","flatSignature":"(ClassFileTransformer)","returnType":{"isPrimitive":true,"simpleName":"boolean","qualifiedName":"boolean","dimension":"","elementType":{}},"isAbstract":true,"isDefault":false,"isStatic":false,"parameters":[{"name":"transformer","type":{"isPrimitive":false,"simpleName":"ClassFileTransformer","qualifiedName":"java.lang.instrument.ClassFileTransformer","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"isRetransformClassesSupported","comment":"Returns whether or not the current JVM configuration supports retransformation\n of classes.\n The ability to retransform an already loaded class is an optional capability\n of a JVM.\n Retransformation will only be supported if the\n \u003ccode\u003eCan-Retransform-Classes\u003c/code\u003e manifest attribute is set to\n \u003ccode\u003etrue\u003c/code\u003e in the agent JAR file (as described in the\n {@linkplain java.lang.instrument package specification}) and the JVM supports\n this capability.\n During a single instantiation of a single JVM, multiple calls to this\n method will always return the same answer.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":true,"simpleName":"boolean","qualifiedName":"boolean","dimension":"","elementType":{}},"isAbstract":true,"isDefault":false,"isStatic":false,"parameters":[],"typeParameters":[]},{"name":"retransformClasses","comment":"Retransform the supplied set of classes.\n\n \u003cP\u003e\n This function facilitates the instrumentation\n of already loaded classes.\n When classes are initially loaded or when they are\n {@linkplain #redefineClasses redefined},\n the initial class file bytes can be transformed with the\n {@link java.lang.instrument.ClassFileTransformer ClassFileTransformer}.\n This function reruns the transformation process\n (whether or not a transformation has previously occurred).\n This retransformation follows these steps:\n  \u003cul\u003e\n    \u003cli\u003estarting from the initial class file bytes\n    \u003c/li\u003e\n    \u003cli\u003efor each transformer that was added with \u003ccode\u003ecanRetransform\u003c/code\u003e\n      false, the bytes returned by\n      {@link java.lang.instrument.ClassFileTransformer#transform transform}\n      during the last class load or redefine are\n      reused as the output of the transformation; note that this is\n      equivalent to reapplying the previous transformation, unaltered;\n      except that\n      {@link java.lang.instrument.ClassFileTransformer#transform transform}\n      is not called\n    \u003c/li\u003e\n    \u003cli\u003efor each transformer that was added with \u003ccode\u003ecanRetransform\u003c/code\u003e\n      true, the\n      {@link java.lang.instrument.ClassFileTransformer#transform transform}\n      method is called in these transformers\n    \u003c/li\u003e\n    \u003cli\u003ethe transformed class file bytes are installed as the new\n      definition of the class\n    \u003c/li\u003e\n  \u003c/ul\u003e\n \u003cP\u003e\n\n The order of transformation is described in the\n {@link java.lang.instrument.ClassFileTransformer#transform transform} method.\n This same order is used in the automatic reapplication of retransformation\n incapable transforms.\n \u003cP\u003e\n\n The initial class file bytes represent the bytes passed to\n {@link java.lang.ClassLoader#defineClass ClassLoader.defineClass} or\n {@link #redefineClasses redefineClasses}\n (before any transformations\n  were applied), however they might not exactly match them.\n  The constant pool might not have the same layout or contents.\n  The constant pool may have more or fewer entries.\n  Constant pool entries may be in a different order; however,\n  constant pool indices in the bytecodes of methods will correspond.\n  Some attributes may not be present.\n  Where order is not meaningful, for example the order of methods,\n  order might not be preserved.\n\n \u003cP\u003e\n This method operates on\n a set in order to allow interdependent changes to more than one class at the same time\n (a retransformation of class A can require a retransformation of class B).\n\n \u003cP\u003e\n If a retransformed method has active stack frames, those active frames continue to\n run the bytecodes of the original method.\n The retransformed method will be used on new invokes.\n\n \u003cP\u003e\n This method does not cause any initialization except that which would occur\n under the customary JVM semantics. In other words, redefining a class\n does not cause its initializers to be run. The values of static variables\n will remain as they were prior to the call.\n\n \u003cP\u003e\n Instances of the retransformed class are not affected.\n\n \u003cP\u003e\n The retransformation may change method bodies, the constant pool and attributes.\n The retransformation must not add, remove or rename fields or methods, change the\n signatures of methods, or change inheritance.  These restrictions maybe be\n lifted in future versions.  The class file bytes are not checked, verified and installed\n until after the transformations have been applied, if the resultant bytes are in\n error this method will throw an exception.\n\n \u003cP\u003e\n If this method throws an exception, no classes have been retransformed.\n \u003cP\u003e\n This method is intended for use in instrumentation, as described in the\n {@linkplain Instrumentation class specification}.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.lang.Class\u003c?\u003e...)","flatSignature":"(Class\u003c?\u003e...)","returnType":{"isPrimitive":true,"simpleName":"void","qualifiedName":"void","dimension":"","elementType":{}},"isAbstract":true,"isDefault":false,"isStatic":false,"parameters":[{"name":"classes","type":{"isPrimitive":false,"simpleName":"Class","qualifiedName":"java.lang.Class","dimension":"[]","elementType":{"isPrimitive":false,"simpleName":"Class","qualifiedName":"java.lang.Class","dimension":"","elementType":{}}}}],"typeParameters":[]},{"name":"isRedefineClassesSupported","comment":"Returns whether or not the current JVM configuration supports redefinition\n of classes.\n The ability to redefine an already loaded class is an optional capability\n of a JVM.\n Redefinition will only be supported if the\n \u003ccode\u003eCan-Redefine-Classes\u003c/code\u003e manifest attribute is set to\n \u003ccode\u003etrue\u003c/code\u003e in the agent JAR file (as described in the\n {@linkplain java.lang.instrument package specification}) and the JVM supports\n this capability.\n During a single instantiation of a single JVM, multiple calls to this\n method will always return the same answer.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":true,"simpleName":"boolean","qualifiedName":"boolean","dimension":"","elementType":{}},"isAbstract":true,"isDefault":false,"isStatic":false,"parameters":[],"typeParameters":[]},{"name":"redefineClasses","comment":"Redefine the supplied set of classes using the supplied class files.\n\n \u003cP\u003e\n This method is used to replace the definition of a class without reference\n to the existing class file bytes, as one might do when recompiling from source\n for fix-and-continue debugging.\n Where the existing class file bytes are to be transformed (for\n example in bytecode instrumentation)\n {@link #retransformClasses retransformClasses}\n should be used.\n\n \u003cP\u003e\n This method operates on\n a set in order to allow interdependent changes to more than one class at the same time\n (a redefinition of class A can require a redefinition of class B).\n\n \u003cP\u003e\n If a redefined method has active stack frames, those active frames continue to\n run the bytecodes of the original method.\n The redefined method will be used on new invokes.\n\n \u003cP\u003e\n This method does not cause any initialization except that which would occur\n under the customary JVM semantics. In other words, redefining a class\n does not cause its initializers to be run. The values of static variables\n will remain as they were prior to the call.\n\n \u003cP\u003e\n Instances of the redefined class are not affected.\n\n \u003cP\u003e\n The redefinition may change method bodies, the constant pool and attributes.\n The redefinition must not add, remove or rename fields or methods, change the\n signatures of methods, or change inheritance.  These restrictions maybe be\n lifted in future versions.  The class file bytes are not checked, verified and installed\n until after the transformations have been applied, if the resultant bytes are in\n error this method will throw an exception.\n\n \u003cP\u003e\n If this method throws an exception, no classes have been redefined.\n \u003cP\u003e\n This method is intended for use in instrumentation, as described in the\n {@linkplain Instrumentation class specification}.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.lang.instrument.ClassDefinition...)","flatSignature":"(ClassDefinition...)","returnType":{"isPrimitive":true,"simpleName":"void","qualifiedName":"void","dimension":"","elementType":{}},"isAbstract":true,"isDefault":false,"isStatic":false,"parameters":[{"name":"definitions","type":{"isPrimitive":false,"simpleName":"ClassDefinition","qualifiedName":"java.lang.instrument.ClassDefinition","dimension":"[]","elementType":{"isPrimitive":false,"simpleName":"ClassDefinition","qualifiedName":"java.lang.instrument.ClassDefinition","dimension":"","elementType":{}}}}],"typeParameters":[]},{"name":"isModifiableClass","comment":"Determines whether a class is modifiable by\n {@linkplain #retransformClasses retransformation}\n or {@linkplain #redefineClasses redefinition}.\n If a class is modifiable then this method returns \u003ccode\u003etrue\u003c/code\u003e.\n If a class is not modifiable then this method returns \u003ccode\u003efalse\u003c/code\u003e.\n \u003cP\u003e\n For a class to be retransformed, {@link #isRetransformClassesSupported} must also be true.\n But the value of \u003ccode\u003eisRetransformClassesSupported()\u003c/code\u003e does not influence the value\n returned by this function.\n For a class to be redefined, {@link #isRedefineClassesSupported} must also be true.\n But the value of \u003ccode\u003eisRedefineClassesSupported()\u003c/code\u003e does not influence the value\n returned by this function.\n \u003cP\u003e\n Primitive classes (for example, \u003ccode\u003ejava.lang.Integer.TYPE\u003c/code\u003e)\n and array classes are never modifiable.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.lang.Class\u003c?\u003e)","flatSignature":"(Class\u003c?\u003e)","returnType":{"isPrimitive":true,"simpleName":"boolean","qualifiedName":"boolean","dimension":"","elementType":{}},"isAbstract":true,"isDefault":false,"isStatic":false,"parameters":[{"name":"theClass","type":{"isPrimitive":false,"simpleName":"Class","qualifiedName":"java.lang.Class","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"getAllLoadedClasses","comment":"Returns an array of all classes currently loaded by the JVM.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":false,"simpleName":"Class","qualifiedName":"java.lang.Class","dimension":"[]","elementType":{"isPrimitive":false,"simpleName":"Class","qualifiedName":"java.lang.Class","dimension":"","elementType":{}}},"isAbstract":true,"isDefault":false,"isStatic":false,"parameters":[],"typeParameters":[]},{"name":"getInitiatedClasses","comment":"Returns an array of all classes for which \u003ccode\u003eloader\u003c/code\u003e is an initiating loader.\n If the supplied loader is \u003ccode\u003enull\u003c/code\u003e, classes initiated by the bootstrap class\n loader are returned.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.lang.ClassLoader)","flatSignature":"(ClassLoader)","returnType":{"isPrimitive":false,"simpleName":"Class","qualifiedName":"java.lang.Class","dimension":"[]","elementType":{"isPrimitive":false,"simpleName":"Class","qualifiedName":"java.lang.Class","dimension":"","elementType":{}}},"isAbstract":true,"isDefault":false,"isStatic":false,"parameters":[{"name":"loader","type":{"isPrimitive":false,"simpleName":"ClassLoader","qualifiedName":"java.lang.ClassLoader","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"getObjectSize","comment":"Returns an implementation-specific approximation of the amount of storage consumed by\n the specified object. The result may include some or all of the object\u0027s overhead,\n and thus is useful for comparison within an implementation but not between implementations.\n\n The estimate may change during a single invocation of the JVM.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.lang.Object)","flatSignature":"(Object)","returnType":{"isPrimitive":true,"simpleName":"long","qualifiedName":"long","dimension":"","elementType":{}},"isAbstract":true,"isDefault":false,"isStatic":false,"parameters":[{"name":"objectToSize","type":{"isPrimitive":false,"simpleName":"Object","qualifiedName":"java.lang.Object","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"appendToBootstrapClassLoaderSearch","comment":"Specifies a JAR file with instrumentation classes to be defined by the\n bootstrap class loader.\n\n \u003cp\u003e When the virtual machine\u0027s built-in class loader, known as the \"bootstrap\n class loader\", unsuccessfully searches for a class, the entries in the {@link\n java.util.jar.JarFile JAR file} will be searched as well.\n\n \u003cp\u003e This method may be used multiple times to add multiple JAR files to be\n searched in the order that this method was invoked.\n\n \u003cp\u003e The agent should take care to ensure that the JAR does not contain any\n classes or resources other than those to be defined by the bootstrap\n class loader for the purpose of instrumentation.\n Failure to observe this warning could result in unexpected\n behavior that is difficult to diagnose. For example, suppose there is a\n loader L, and L\u0027s parent for delegation is the bootstrap class loader.\n Furthermore, a method in class C, a class defined by L, makes reference to\n a non-public accessor class C$1. If the JAR file contains a class C$1 then\n the delegation to the bootstrap class loader will cause C$1 to be defined\n by the bootstrap class loader. In this example an \u003ccode\u003eIllegalAccessError\u003c/code\u003e\n will be thrown that may cause the application to fail. One approach to\n avoiding these types of issues, is to use a unique package name for the\n instrumentation classes.\n\n \u003cp\u003e\n \u003ccite\u003eThe Java\u0026trade; Virtual Machine Specification\u003c/cite\u003e\n specifies that a subsequent attempt to resolve a symbolic\n reference that the Java virtual machine has previously unsuccessfully attempted\n to resolve always fails with the same error that was thrown as a result of the\n initial resolution attempt. Consequently, if the JAR file contains an entry\n that corresponds to a class for which the Java virtual machine has\n unsuccessfully attempted to resolve a reference, then subsequent attempts to\n resolve that reference will fail with the same error as the initial attempt.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.util.jar.JarFile)","flatSignature":"(JarFile)","returnType":{"isPrimitive":true,"simpleName":"void","qualifiedName":"void","dimension":"","elementType":{}},"isAbstract":true,"isDefault":false,"isStatic":false,"parameters":[{"name":"jarfile","type":{"isPrimitive":false,"simpleName":"JarFile","qualifiedName":"java.util.jar.JarFile","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"appendToSystemClassLoaderSearch","comment":"Specifies a JAR file with instrumentation classes to be defined by the\n system class loader.\n\n When the system class loader for delegation (see\n {@link java.lang.ClassLoader#getSystemClassLoader getSystemClassLoader()})\n unsuccessfully searches for a class, the entries in the {@link\n java.util.jar.JarFile JarFile} will be searched as well.\n\n \u003cp\u003e This method may be used multiple times to add multiple JAR files to be\n searched in the order that this method was invoked.\n\n \u003cp\u003e The agent should take care to ensure that the JAR does not contain any\n classes or resources other than those to be defined by the system class\n loader for the purpose of instrumentation.\n Failure to observe this warning could result in unexpected\n behavior that is difficult to diagnose (see\n {@link #appendToBootstrapClassLoaderSearch\n appendToBootstrapClassLoaderSearch}).\n\n \u003cp\u003e The system class loader supports adding a JAR file to be searched if\n it implements a method named \u003ccode\u003eappendToClassPathForInstrumentation\u003c/code\u003e\n which takes a single parameter of type \u003ccode\u003ejava.lang.String\u003c/code\u003e. The\n method is not required to have \u003ccode\u003epublic\u003c/code\u003e access. The name of\n the JAR file is obtained by invoking the {@link java.util.zip.ZipFile#getName\n getName()} method on the \u003ccode\u003ejarfile\u003c/code\u003e and this is provided as the\n parameter to the \u003ccode\u003eappendToClassPathForInstrumentation\u003c/code\u003e method.\n\n \u003cp\u003e\n \u003ccite\u003eThe Java\u0026trade; Virtual Machine Specification\u003c/cite\u003e\n specifies that a subsequent attempt to resolve a symbolic\n reference that the Java virtual machine has previously unsuccessfully attempted\n to resolve always fails with the same error that was thrown as a result of the\n initial resolution attempt. Consequently, if the JAR file contains an entry\n that corresponds to a class for which the Java virtual machine has\n unsuccessfully attempted to resolve a reference, then subsequent attempts to\n resolve that reference will fail with the same error as the initial attempt.\n\n \u003cp\u003e This method does not change the value of \u003ccode\u003ejava.class.path\u003c/code\u003e\n {@link java.lang.System#getProperties system property}.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.util.jar.JarFile)","flatSignature":"(JarFile)","returnType":{"isPrimitive":true,"simpleName":"void","qualifiedName":"void","dimension":"","elementType":{}},"isAbstract":true,"isDefault":false,"isStatic":false,"parameters":[{"name":"jarfile","type":{"isPrimitive":false,"simpleName":"JarFile","qualifiedName":"java.util.jar.JarFile","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"isNativeMethodPrefixSupported","comment":"Returns whether the current JVM configuration supports\n {@linkplain #setNativeMethodPrefix(ClassFileTransformer,String)\n setting a native method prefix}.\n The ability to set a native method prefix is an optional\n capability of a JVM.\n Setting a native method prefix will only be supported if the\n \u003ccode\u003eCan-Set-Native-Method-Prefix\u003c/code\u003e manifest attribute is set to\n \u003ccode\u003etrue\u003c/code\u003e in the agent JAR file (as described in the\n {@linkplain java.lang.instrument package specification}) and the JVM supports\n this capability.\n During a single instantiation of a single JVM, multiple\n calls to this method will always return the same answer.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":true,"simpleName":"boolean","qualifiedName":"boolean","dimension":"","elementType":{}},"isAbstract":true,"isDefault":false,"isStatic":false,"parameters":[],"typeParameters":[]},{"name":"setNativeMethodPrefix","comment":"This method modifies the failure handling of\n native method resolution by allowing retry\n with a prefix applied to the name.\n When used with the\n {@link java.lang.instrument.ClassFileTransformer ClassFileTransformer},\n it enables native methods to be\n instrumented.\n \u003cp\u003e\n Since native methods cannot be directly instrumented\n (they have no bytecodes), they must be wrapped with\n a non-native method which can be instrumented.\n For example, if we had:\n \u003cpre\u003e\n   native boolean foo(int x);\u003c/pre\u003e\n \u003cp\u003e\n We could transform the class file (with the\n ClassFileTransformer during the initial definition\n of the class) so that this becomes:\n \u003cpre\u003e\n   boolean foo(int x) {\n     \u003ci\u003e... record entry to foo ...\u003c/i\u003e\n     return wrapped_foo(x);\n   }\n\n   native boolean wrapped_foo(int x);\u003c/pre\u003e\n \u003cp\u003e\n Where \u003ccode\u003efoo\u003c/code\u003e becomes a wrapper for the actual native\n method with the appended prefix \"wrapped_\".  Note that\n \"wrapped_\" would be a poor choice of prefix since it\n might conceivably form the name of an existing method\n thus something like \"$$$MyAgentWrapped$$$_\" would be\n better but would make these examples less readable.\n \u003cp\u003e\n The wrapper will allow data to be collected on the native\n method call, but now the problem becomes linking up the\n wrapped method with the native implementation.\n That is, the method \u003ccode\u003ewrapped_foo\u003c/code\u003e needs to be\n resolved to the native implementation of \u003ccode\u003efoo\u003c/code\u003e,\n which might be:\n \u003cpre\u003e\n   Java_somePackage_someClass_foo(JNIEnv* env, jint x)\u003c/pre\u003e\n \u003cp\u003e\n This function allows the prefix to be specified and the\n proper resolution to occur.\n Specifically, when the standard resolution fails, the\n resolution is retried taking the prefix into consideration.\n There are two ways that resolution occurs, explicit\n resolution with the JNI function \u003ccode\u003eRegisterNatives\u003c/code\u003e\n and the normal automatic resolution.  For\n \u003ccode\u003eRegisterNatives\u003c/code\u003e, the JVM will attempt this\n association:\n \u003cpre\u003e{@code\n   method(foo) -\u003e nativeImplementation(foo)\n }\u003c/pre\u003e\n \u003cp\u003e\n When this fails, the resolution will be retried with\n the specified prefix prepended to the method name,\n yielding the correct resolution:\n \u003cpre\u003e{@code\n   method(wrapped_foo) -\u003e nativeImplementation(foo)\n }\u003c/pre\u003e\n \u003cp\u003e\n For automatic resolution, the JVM will attempt:\n \u003cpre\u003e{@code\n   method(wrapped_foo) -\u003e nativeImplementation(wrapped_foo)\n }\u003c/pre\u003e\n \u003cp\u003e\n When this fails, the resolution will be retried with\n the specified prefix deleted from the implementation name,\n yielding the correct resolution:\n \u003cpre\u003e{@code\n   method(wrapped_foo) -\u003e nativeImplementation(foo)\n }\u003c/pre\u003e\n \u003cp\u003e\n Note that since the prefix is only used when standard\n resolution fails, native methods can be wrapped selectively.\n \u003cp\u003e\n Since each \u003ccode\u003eClassFileTransformer\u003c/code\u003e\n can do its own transformation of the bytecodes, more\n than one layer of wrappers may be applied. Thus each\n transformer needs its own prefix.  Since transformations\n are applied in order, the prefixes, if applied, will\n be applied in the same order\n (see {@link #addTransformer(ClassFileTransformer,boolean) addTransformer}).\n Thus if three transformers applied\n wrappers, \u003ccode\u003efoo\u003c/code\u003e might become\n \u003ccode\u003e$trans3_$trans2_$trans1_foo\u003c/code\u003e.  But if, say,\n the second transformer did not apply a wrapper to\n \u003ccode\u003efoo\u003c/code\u003e it would be just\n \u003ccode\u003e$trans3_$trans1_foo\u003c/code\u003e.  To be able to\n efficiently determine the sequence of prefixes,\n an intermediate prefix is only applied if its non-native\n wrapper exists.  Thus, in the last example, even though\n \u003ccode\u003e$trans1_foo\u003c/code\u003e is not a native method, the\n \u003ccode\u003e$trans1_\u003c/code\u003e prefix is applied since\n \u003ccode\u003e$trans1_foo\u003c/code\u003e exists.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.lang.instrument.ClassFileTransformer, java.lang.String)","flatSignature":"(ClassFileTransformer, String)","returnType":{"isPrimitive":true,"simpleName":"void","qualifiedName":"void","dimension":"","elementType":{}},"isAbstract":true,"isDefault":false,"isStatic":false,"parameters":[{"name":"transformer","type":{"isPrimitive":false,"simpleName":"ClassFileTransformer","qualifiedName":"java.lang.instrument.ClassFileTransformer","dimension":"","elementType":{}}},{"name":"prefix","type":{"isPrimitive":false,"simpleName":"String","qualifiedName":"java.lang.String","dimension":"","elementType":{}}}],"typeParameters":[]}],"typeParameters":[],"enumConstants":[]}