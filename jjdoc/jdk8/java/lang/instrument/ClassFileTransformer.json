{"name":"ClassFileTransformer","comment":"An agent provides an implementation of this interface in order\n to transform class files.\n The transformation occurs before the class is defined by the JVM.\n \u003cP\u003e\n Note the term \u003ci\u003eclass file\u003c/i\u003e is used as defined in section 3.1 of\n \u003ccite\u003eThe Java\u0026trade; Virtual Machine Specification\u003c/cite\u003e,\n to mean a sequence\n of bytes in class file format, whether or not they reside in a file.","isClass":false,"isInterface":true,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":false,"isOrdinaryClass":false,"isPrimitive":false,"simpleName":"ClassFileTransformer","qualifiedName":"java.lang.instrument.ClassFileTransformer","dimension":"","elementType":{},"package":"java.lang.instrument","interfaces":[],"isAbstract":true,"isStatic":false,"since":"1.5","innerClasses":[],"isInnerClass":false,"constructors":[],"fields":[],"methods":[{"name":"transform","comment":"The implementation of this method may transform the supplied class file and\n return a new replacement class file.\n\n \u003cP\u003e\n There are two kinds of transformers, determined by the \u003ccode\u003ecanRetransform\u003c/code\u003e\n parameter of\n {@link java.lang.instrument.Instrumentation#addTransformer(ClassFileTransformer,boolean)}:\n  \u003cul\u003e\n    \u003cli\u003e\u003ci\u003eretransformation capable\u003c/i\u003e transformers that were added with\n        \u003ccode\u003ecanRetransform\u003c/code\u003e as true\n    \u003c/li\u003e\n    \u003cli\u003e\u003ci\u003eretransformation incapable\u003c/i\u003e transformers that were added with\n        \u003ccode\u003ecanRetransform\u003c/code\u003e as false or where added with\n        {@link java.lang.instrument.Instrumentation#addTransformer(ClassFileTransformer)}\n    \u003c/li\u003e\n  \u003c/ul\u003e\n\n \u003cP\u003e\n Once a transformer has been registered with\n {@link java.lang.instrument.Instrumentation#addTransformer(ClassFileTransformer,boolean)\n addTransformer},\n the transformer will be called for every new class definition and every class redefinition.\n Retransformation capable transformers will also be called on every class retransformation.\n The request for a new class definition is made with\n {@link java.lang.ClassLoader#defineClass ClassLoader.defineClass}\n or its native equivalents.\n The request for a class redefinition is made with\n {@link java.lang.instrument.Instrumentation#redefineClasses Instrumentation.redefineClasses}\n or its native equivalents.\n The request for a class retransformation is made with\n {@link java.lang.instrument.Instrumentation#retransformClasses Instrumentation.retransformClasses}\n or its native equivalents.\n The transformer is called during the processing of the request, before the class file bytes\n have been verified or applied.\n When there are multiple transformers, transformations are composed by chaining the\n \u003ccode\u003etransform\u003c/code\u003e calls.\n That is, the byte array returned by one call to \u003ccode\u003etransform\u003c/code\u003e becomes the input\n (via the \u003ccode\u003eclassfileBuffer\u003c/code\u003e parameter) to the next call.\n\n \u003cP\u003e\n Transformations are applied in the following order:\n  \u003cul\u003e\n    \u003cli\u003eRetransformation incapable transformers\n    \u003c/li\u003e\n    \u003cli\u003eRetransformation incapable native transformers\n    \u003c/li\u003e\n    \u003cli\u003eRetransformation capable transformers\n    \u003c/li\u003e\n    \u003cli\u003eRetransformation capable native transformers\n    \u003c/li\u003e\n  \u003c/ul\u003e\n\n \u003cP\u003e\n For retransformations, the retransformation incapable transformers are not\n called, instead the result of the previous transformation is reused.\n In all other cases, this method is called.\n Within each of these groupings, transformers are called in the order registered.\n Native transformers are provided by the \u003ccode\u003eClassFileLoadHook\u003c/code\u003e event\n in the Java Virtual Machine Tool Interface).\n\n \u003cP\u003e\n The input (via the \u003ccode\u003eclassfileBuffer\u003c/code\u003e parameter) to the first\n transformer is:\n  \u003cul\u003e\n    \u003cli\u003efor new class definition,\n        the bytes passed to \u003ccode\u003eClassLoader.defineClass\u003c/code\u003e\n    \u003c/li\u003e\n    \u003cli\u003efor class redefinition,\n        \u003ccode\u003edefinitions.getDefinitionClassFile()\u003c/code\u003e where\n        \u003ccode\u003edefinitions\u003c/code\u003e is the parameter to\n        {@link java.lang.instrument.Instrumentation#redefineClasses\n         Instrumentation.redefineClasses}\n    \u003c/li\u003e\n    \u003cli\u003efor class retransformation,\n         the bytes passed to the new class definition or, if redefined,\n         the last redefinition, with all transformations made by retransformation\n         incapable transformers reapplied automatically and unaltered;\n         for details see\n         {@link java.lang.instrument.Instrumentation#retransformClasses\n          Instrumentation.retransformClasses}\n    \u003c/li\u003e\n  \u003c/ul\u003e\n\n \u003cP\u003e\n If the implementing method determines that no transformations are needed,\n it should return \u003ccode\u003enull\u003c/code\u003e.\n Otherwise, it should create a new \u003ccode\u003ebyte[]\u003c/code\u003e array,\n copy the input \u003ccode\u003eclassfileBuffer\u003c/code\u003e into it,\n along with all desired transformations, and return the new array.\n The input \u003ccode\u003eclassfileBuffer\u003c/code\u003e must not be modified.\n\n \u003cP\u003e\n In the retransform and redefine cases,\n the transformer must support the redefinition semantics:\n if a class that the transformer changed during initial definition is later\n retransformed or redefined, the\n transformer must insure that the second class output class file is a legal\n redefinition of the first output class file.\n\n \u003cP\u003e\n If the transformer throws an exception (which it doesn\u0027t catch),\n subsequent transformers will still be called and the load, redefine\n or retransform will still be attempted.\n Thus, throwing an exception has the same effect as returning \u003ccode\u003enull\u003c/code\u003e.\n To prevent unexpected behavior when unchecked exceptions are generated\n in transformer code, a transformer can catch \u003ccode\u003eThrowable\u003c/code\u003e.\n If the transformer believes the \u003ccode\u003eclassFileBuffer\u003c/code\u003e does not\n represent a validly formatted class file, it should throw\n an \u003ccode\u003eIllegalClassFormatException\u003c/code\u003e;\n while this has the same effect as returning null. it facilitates the\n logging or debugging of format corruptions.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.lang.ClassLoader, java.lang.String, java.lang.Class\u003c?\u003e, java.security.ProtectionDomain, byte[])","flatSignature":"(ClassLoader, String, Class\u003c?\u003e, ProtectionDomain, byte[])","returnType":{"isPrimitive":true,"simpleName":"byte","qualifiedName":"byte","dimension":"[]","elementType":{"isPrimitive":true,"simpleName":"byte","qualifiedName":"byte","dimension":"","elementType":{}}},"isAbstract":true,"isDefault":false,"isStatic":false,"parameters":[{"name":"loader","type":{"isPrimitive":false,"simpleName":"ClassLoader","qualifiedName":"java.lang.ClassLoader","dimension":"","elementType":{}}},{"name":"className","type":{"isPrimitive":false,"simpleName":"String","qualifiedName":"java.lang.String","dimension":"","elementType":{}}},{"name":"classBeingRedefined","type":{"isPrimitive":false,"simpleName":"Class","qualifiedName":"java.lang.Class","dimension":"","elementType":{}}},{"name":"protectionDomain","type":{"isPrimitive":false,"simpleName":"ProtectionDomain","qualifiedName":"java.security.ProtectionDomain","dimension":"","elementType":{}}},{"name":"classfileBuffer","type":{"isPrimitive":true,"simpleName":"byte","qualifiedName":"byte","dimension":"[]","elementType":{"isPrimitive":true,"simpleName":"byte","qualifiedName":"byte","dimension":"","elementType":{}}}}],"typeParameters":[]}],"typeParameters":[],"enumConstants":[]}