{"name":"MemoryMXBean","comment":"The management interface for the memory system of\n the Java virtual machine.\n\n \u003cp\u003e A Java virtual machine has a single instance of the implementation\n class of this interface.  This instance implementing this interface is\n an \u003ca href\u003d\"ManagementFactory.html#MXBean\"\u003eMXBean\u003c/a\u003e\n that can be obtained by calling\n the {@link ManagementFactory#getMemoryMXBean} method or\n from the {@link ManagementFactory#getPlatformMBeanServer\n platform \u003ctt\u003eMBeanServer\u003c/tt\u003e} method.\n\n \u003cp\u003eThe \u003ctt\u003eObjectName\u003c/tt\u003e for uniquely identifying the MXBean for\n the memory system within an MBeanServer is:\n \u003cblockquote\u003e\n    {@link ManagementFactory#MEMORY_MXBEAN_NAME\n           \u003ctt\u003ejava.lang:type\u003dMemory\u003c/tt\u003e}\n \u003c/blockquote\u003e\n\n It can be obtained by calling the\n {@link PlatformManagedObject#getObjectName} method.\n\n \u003ch3\u003e Memory \u003c/h3\u003e\n The memory system of the Java virtual machine manages\n the following kinds of memory:\n\n \u003ch3\u003e 1. Heap \u003c/h3\u003e\n The Java virtual machine has a \u003ci\u003eheap\u003c/i\u003e that is the runtime\n data area from which memory for all class instances and arrays\n are allocated.  It is created at the Java virtual machine start-up.\n Heap memory for objects is reclaimed by an automatic memory management\n system which is known as a \u003ci\u003egarbage collector\u003c/i\u003e.\n\n \u003cp\u003eThe heap may be of a fixed size or may be expanded and shrunk.\n The memory for the heap does not need to be contiguous.\n\n \u003ch3\u003e 2. Non-Heap Memory\u003c/h3\u003e\n The Java virtual machine manages memory other than the heap\n (referred as \u003ci\u003enon-heap memory\u003c/i\u003e).\n\n \u003cp\u003e The Java virtual machine has a \u003ci\u003emethod area\u003c/i\u003e that is shared\n among all threads.\n The method area belongs to non-heap memory.  It stores per-class structures\n such as a runtime constant pool, field and method data, and the code for\n methods and constructors.  It is created at the Java virtual machine\n start-up.\n\n \u003cp\u003e The method area is logically part of the heap but a Java virtual\n machine implementation may choose not to either garbage collect\n or compact it.  Similar to the heap, the method area may be of a\n fixed size or may be expanded and shrunk.  The memory for the\n method area does not need to be contiguous.\n\n \u003cp\u003eIn addition to the method area, a Java virtual machine\n implementation may require memory for internal processing or\n optimization which also belongs to non-heap memory.\n For example, the JIT compiler requires memory for storing the native\n machine code translated from the Java virtual machine code for\n high performance.\n\n \u003ch3\u003eMemory Pools and Memory Managers\u003c/h3\u003e\n {@link MemoryPoolMXBean Memory pools} and\n {@link MemoryManagerMXBean memory managers} are the abstract entities\n that monitor and manage the memory system\n of the Java virtual machine.\n\n \u003cp\u003eA memory pool represents a memory area that the Java virtual machine\n manages.  The Java virtual machine has at least one memory pool\n and it may create or remove memory pools during execution.\n A memory pool can belong to either the heap or the non-heap memory.\n\n \u003cp\u003eA memory manager is responsible for managing one or more memory pools.\n The garbage collector is one type of memory manager responsible\n for reclaiming memory occupied by unreachable objects.  A Java virtual\n machine may have one or more memory managers.   It may\n add or remove memory managers during execution.\n A memory pool can be managed by more than one memory manager.\n\n \u003ch3\u003eMemory Usage Monitoring\u003c/h3\u003e\n\n Memory usage is a very important monitoring attribute for the memory system.\n The memory usage, for example, could indicate:\n \u003cul\u003e\n   \u003cli\u003ethe memory usage of an application,\u003c/li\u003e\n   \u003cli\u003ethe workload being imposed on the automatic memory management system,\u003c/li\u003e\n   \u003cli\u003epotential memory leakage.\u003c/li\u003e\n \u003c/ul\u003e\n\n \u003cp\u003e\n The memory usage can be monitored in three ways:\n \u003cul\u003e\n   \u003cli\u003ePolling\u003c/li\u003e\n   \u003cli\u003eUsage Threshold Notification\u003c/li\u003e\n   \u003cli\u003eCollection Usage Threshold Notification\u003c/li\u003e\n \u003c/ul\u003e\n\n Details are specified in the {@link MemoryPoolMXBean} interface.\n\n \u003cp\u003eThe memory usage monitoring mechanism is intended for load-balancing\n or workload distribution use.  For example, an application would stop\n receiving any new workload when its memory usage exceeds a\n certain threshold. It is not intended for an application to detect\n and recover from a low memory condition.\n\n \u003ch3\u003eNotifications\u003c/h3\u003e\n\n \u003cp\u003eThis \u003ctt\u003eMemoryMXBean\u003c/tt\u003e is a\n {@link javax.management.NotificationEmitter NotificationEmitter}\n that emits two types of memory {@link javax.management.Notification\n notifications} if any one of the memory pools\n supports a \u003ca href\u003d\"MemoryPoolMXBean.html#UsageThreshold\"\u003eusage threshold\u003c/a\u003e\n or a \u003ca href\u003d\"MemoryPoolMXBean.html#CollectionThreshold\"\u003ecollection usage\n threshold\u003c/a\u003e which can be determined by calling the\n {@link MemoryPoolMXBean#isUsageThresholdSupported} and\n {@link MemoryPoolMXBean#isCollectionUsageThresholdSupported} methods.\n \u003cul\u003e\n   \u003cli\u003e{@link MemoryNotificationInfo#MEMORY_THRESHOLD_EXCEEDED\n       usage threshold exceeded notification} - for notifying that\n       the memory usage of a memory pool is increased and has reached\n       or exceeded its\n       \u003ca href\u003d\"MemoryPoolMXBean.html#UsageThreshold\"\u003e usage threshold\u003c/a\u003e value.\n       \u003c/li\u003e\n   \u003cli\u003e{@link MemoryNotificationInfo#MEMORY_COLLECTION_THRESHOLD_EXCEEDED\n       collection usage threshold exceeded notification} - for notifying that\n       the memory usage of a memory pool is greater than or equal to its\n       \u003ca href\u003d\"MemoryPoolMXBean.html#CollectionThreshold\"\u003e\n       collection usage threshold\u003c/a\u003e after the Java virtual machine\n       has expended effort in recycling unused objects in that\n       memory pool.\u003c/li\u003e\n \u003c/ul\u003e\n\n \u003cp\u003e\n The notification emitted is a {@link javax.management.Notification}\n instance whose {@link javax.management.Notification#setUserData\n user data} is set to a {@link CompositeData CompositeData}\n that represents a {@link MemoryNotificationInfo} object\n containing information about the memory pool when the notification\n was constructed. The \u003ctt\u003eCompositeData\u003c/tt\u003e contains the attributes\n as described in {@link MemoryNotificationInfo#from\n MemoryNotificationInfo}.\n\n \u003chr\u003e\n \u003ch3\u003eNotificationEmitter\u003c/h3\u003e\n The \u003ctt\u003eMemoryMXBean\u003c/tt\u003e object returned by\n {@link ManagementFactory#getMemoryMXBean} implements\n the {@link javax.management.NotificationEmitter NotificationEmitter}\n interface that allows a listener to be registered within the\n \u003ctt\u003eMemoryMXBean\u003c/tt\u003e as a notification listener.\n\n Below is an example code that registers a \u003ctt\u003eMyListener\u003c/tt\u003e to handle\n notification emitted by the \u003ctt\u003eMemoryMXBean\u003c/tt\u003e.\n\n \u003cblockquote\u003e\u003cpre\u003e\n class MyListener implements javax.management.NotificationListener {\n     public void handleNotification(Notification notif, Object handback) {\n         // handle notification\n         ....\n     }\n }\n\n MemoryMXBean mbean \u003d ManagementFactory.getMemoryMXBean();\n NotificationEmitter emitter \u003d (NotificationEmitter) mbean;\n MyListener listener \u003d new MyListener();\n emitter.addNotificationListener(listener, null, null);\n \u003c/pre\u003e\u003c/blockquote\u003e","isClass":false,"isInterface":true,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":false,"isOrdinaryClass":false,"isPrimitive":false,"simpleName":"MemoryMXBean","qualifiedName":"java.lang.management.MemoryMXBean","dimension":"","elementType":{},"package":"java.lang.management","interfaces":["java.lang.management.PlatformManagedObject"],"isAbstract":true,"isStatic":false,"since":"1.5","innerClasses":[],"isInnerClass":false,"constructors":[],"fields":[],"methods":[{"name":"getObjectPendingFinalizationCount","comment":"Returns the approximate number of objects for which\n finalization is pending.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}},"isAbstract":true,"isDefault":false,"isStatic":false,"parameters":[],"typeParameters":[]},{"name":"getHeapMemoryUsage","comment":"Returns the current memory usage of the heap that\n is used for object allocation.  The heap consists\n of one or more memory pools.  The \u003ctt\u003eused\u003c/tt\u003e\n and \u003ctt\u003ecommitted\u003c/tt\u003e size of the returned memory\n usage is the sum of those values of all heap memory pools\n whereas the \u003ctt\u003einit\u003c/tt\u003e and \u003ctt\u003emax\u003c/tt\u003e size of the\n returned memory usage represents the setting of the heap\n memory which may not be the sum of those of all heap\n memory pools.\n \u003cp\u003e\n The amount of used memory in the returned memory usage\n is the amount of memory occupied by both live objects\n and garbage objects that have not been collected, if any.\n\n \u003cp\u003e\n \u003cb\u003eMBeanServer access\u003c/b\u003e:\u003cbr\u003e\n The mapped type of \u003ctt\u003eMemoryUsage\u003c/tt\u003e is\n \u003ctt\u003eCompositeData\u003c/tt\u003e with attributes as specified in\n {@link MemoryUsage#from MemoryUsage}.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":false,"simpleName":"MemoryUsage","qualifiedName":"java.lang.management.MemoryUsage","dimension":"","elementType":{}},"isAbstract":true,"isDefault":false,"isStatic":false,"parameters":[],"typeParameters":[]},{"name":"getNonHeapMemoryUsage","comment":"Returns the current memory usage of non-heap memory that\n is used by the Java virtual machine.\n The non-heap memory consists of one or more memory pools.\n The \u003ctt\u003eused\u003c/tt\u003e and \u003ctt\u003ecommitted\u003c/tt\u003e size of the\n returned memory usage is the sum of those values of\n all non-heap memory pools whereas the \u003ctt\u003einit\u003c/tt\u003e\n and \u003ctt\u003emax\u003c/tt\u003e size of the returned memory usage\n represents the setting of the non-heap\n memory which may not be the sum of those of all non-heap\n memory pools.\n\n \u003cp\u003e\n \u003cb\u003eMBeanServer access\u003c/b\u003e:\u003cbr\u003e\n The mapped type of \u003ctt\u003eMemoryUsage\u003c/tt\u003e is\n \u003ctt\u003eCompositeData\u003c/tt\u003e with attributes as specified in\n {@link MemoryUsage#from MemoryUsage}.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":false,"simpleName":"MemoryUsage","qualifiedName":"java.lang.management.MemoryUsage","dimension":"","elementType":{}},"isAbstract":true,"isDefault":false,"isStatic":false,"parameters":[],"typeParameters":[]},{"name":"isVerbose","comment":"Tests if verbose output for the memory system is enabled.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":true,"simpleName":"boolean","qualifiedName":"boolean","dimension":"","elementType":{}},"isAbstract":true,"isDefault":false,"isStatic":false,"parameters":[],"typeParameters":[]},{"name":"setVerbose","comment":"Enables or disables verbose output for the memory\n system.  The verbose output information and the output stream\n to which the verbose information is emitted are implementation\n dependent.  Typically, a Java virtual machine implementation\n prints a message whenever it frees memory at garbage collection.\n\n \u003cp\u003e\n Each invocation of this method enables or disables verbose\n output globally.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(boolean)","flatSignature":"(boolean)","returnType":{"isPrimitive":true,"simpleName":"void","qualifiedName":"void","dimension":"","elementType":{}},"isAbstract":true,"isDefault":false,"isStatic":false,"parameters":[{"name":"value","type":{"isPrimitive":true,"simpleName":"boolean","qualifiedName":"boolean","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"gc","comment":"Runs the garbage collector.\n The call \u003ccode\u003egc()\u003c/code\u003e is effectively equivalent to the\n call:\n \u003cblockquote\u003e\u003cpre\u003e\n System.gc()\n \u003c/pre\u003e\u003c/blockquote\u003e","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":true,"simpleName":"void","qualifiedName":"void","dimension":"","elementType":{}},"isAbstract":true,"isDefault":false,"isStatic":false,"parameters":[],"typeParameters":[]}],"typeParameters":[],"enumConstants":[]}