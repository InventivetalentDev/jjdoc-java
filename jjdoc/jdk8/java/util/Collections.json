{"name":"Collections","comment":"This class consists exclusively of static methods that operate on or return\n collections.  It contains polymorphic algorithms that operate on\n collections, \"wrappers\", which return a new collection backed by a\n specified collection, and a few other odds and ends.\n\n \u003cp\u003eThe methods of this class all throw a \u003ctt\u003eNullPointerException\u003c/tt\u003e\n if the collections or class objects provided to them are null.\n\n \u003cp\u003eThe documentation for the polymorphic algorithms contained in this class\n generally includes a brief description of the \u003ci\u003eimplementation\u003c/i\u003e.  Such\n descriptions should be regarded as \u003ci\u003eimplementation notes\u003c/i\u003e, rather than\n parts of the \u003ci\u003especification\u003c/i\u003e.  Implementors should feel free to\n substitute other algorithms, so long as the specification itself is adhered\n to.  (For example, the algorithm used by \u003ctt\u003esort\u003c/tt\u003e does not have to be\n a mergesort, but it does have to be \u003ci\u003estable\u003c/i\u003e.)\n\n \u003cp\u003eThe \"destructive\" algorithms contained in this class, that is, the\n algorithms that modify the collection on which they operate, are specified\n to throw \u003ctt\u003eUnsupportedOperationException\u003c/tt\u003e if the collection does not\n support the appropriate mutation primitive(s), such as the \u003ctt\u003eset\u003c/tt\u003e\n method.  These algorithms may, but are not required to, throw this\n exception if an invocation would have no effect on the collection.  For\n example, invoking the \u003ctt\u003esort\u003c/tt\u003e method on an unmodifiable list that is\n already sorted may or may not throw \u003ctt\u003eUnsupportedOperationException\u003c/tt\u003e.\n\n \u003cp\u003eThis class is a member of the\n \u003ca href\u003d\"{@docRoot}/../technotes/guides/collections/index.html\"\u003e\n Java Collections Framework\u003c/a\u003e.","isClass":true,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":false,"isOrdinaryClass":true,"isPrimitive":false,"simpleName":"Collections","qualifiedName":"java.util.Collections","dimension":"","elementType":{},"package":"java.util","superclass":"java.lang.Object","interfaces":[],"isAbstract":false,"isStatic":false,"since":"1.2","innerClasses":[],"isInnerClass":false,"constructors":[],"fields":[{"name":"EMPTY_SET","comment":"The empty set (immutable).  This set is serializable.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":true,"isMethod":false,"isOrdinaryClass":false,"type":{"isPrimitive":false,"simpleName":"Set","qualifiedName":"java.util.Set","dimension":"","elementType":{}},"isStatic":true},{"name":"EMPTY_LIST","comment":"The empty list (immutable).  This list is serializable.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":true,"isMethod":false,"isOrdinaryClass":false,"type":{"isPrimitive":false,"simpleName":"List","qualifiedName":"java.util.List","dimension":"","elementType":{}},"isStatic":true},{"name":"EMPTY_MAP","comment":"The empty map (immutable).  This map is serializable.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":true,"isMethod":false,"isOrdinaryClass":false,"type":{"isPrimitive":false,"simpleName":"Map","qualifiedName":"java.util.Map","dimension":"","elementType":{}},"isStatic":true}],"methods":[{"name":"sort","comment":"Sorts the specified list into ascending order, according to the\n {@linkplain Comparable natural ordering} of its elements.\n All elements in the list must implement the {@link Comparable}\n interface.  Furthermore, all elements in the list must be\n \u003ci\u003emutually comparable\u003c/i\u003e (that is, {@code e1.compareTo(e2)}\n must not throw a {@code ClassCastException} for any elements\n {@code e1} and {@code e2} in the list).\n\n \u003cp\u003eThis sort is guaranteed to be \u003ci\u003estable\u003c/i\u003e:  equal elements will\n not be reordered as a result of the sort.\n\n \u003cp\u003eThe specified list must be modifiable, but need not be resizable.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.util.List\u003cT\u003e)","flatSignature":"(List\u003cT\u003e)","returnType":{"isPrimitive":true,"simpleName":"void","qualifiedName":"void","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"list","type":{"isPrimitive":false,"simpleName":"List","qualifiedName":"java.util.List","dimension":"","elementType":{}}}],"typeParameters":[{"name":"T","bounds":["java.lang.Comparable"]}]},{"name":"sort","comment":"Sorts the specified list according to the order induced by the\n specified comparator.  All elements in the list must be \u003ci\u003emutually\n comparable\u003c/i\u003e using the specified comparator (that is,\n {@code c.compare(e1, e2)} must not throw a {@code ClassCastException}\n for any elements {@code e1} and {@code e2} in the list).\n\n \u003cp\u003eThis sort is guaranteed to be \u003ci\u003estable\u003c/i\u003e:  equal elements will\n not be reordered as a result of the sort.\n\n \u003cp\u003eThe specified list must be modifiable, but need not be resizable.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.util.List\u003cT\u003e, java.util.Comparator\u003c? super T\u003e)","flatSignature":"(List\u003cT\u003e, Comparator\u003c? super T\u003e)","returnType":{"isPrimitive":true,"simpleName":"void","qualifiedName":"void","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"list","type":{"isPrimitive":false,"simpleName":"List","qualifiedName":"java.util.List","dimension":"","elementType":{}}},{"name":"c","type":{"isPrimitive":false,"simpleName":"Comparator","qualifiedName":"java.util.Comparator","dimension":"","elementType":{}}}],"typeParameters":[{"name":"T","bounds":[]}]},{"name":"binarySearch","comment":"Searches the specified list for the specified object using the binary\n search algorithm.  The list must be sorted into ascending order\n according to the {@linkplain Comparable natural ordering} of its\n elements (as by the {@link #sort(List)} method) prior to making this\n call.  If it is not sorted, the results are undefined.  If the list\n contains multiple elements equal to the specified object, there is no\n guarantee which one will be found.\n\n \u003cp\u003eThis method runs in log(n) time for a \"random access\" list (which\n provides near-constant-time positional access).  If the specified list\n does not implement the {@link RandomAccess} interface and is large,\n this method will do an iterator-based binary search that performs\n O(n) link traversals and O(log n) element comparisons.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.util.List\u003c? extends java.lang.Comparable\u003c? super T\u003e\u003e, T)","flatSignature":"(List\u003c? extends Comparable\u003c? super T\u003e\u003e, T)","returnType":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"list","type":{"isPrimitive":false,"simpleName":"List","qualifiedName":"java.util.List","dimension":"","elementType":{}}},{"name":"key","type":{"isPrimitive":false,"simpleName":"T","qualifiedName":"T","dimension":"","elementType":{},"typeVariable":{"name":"T","bounds":[]}}}],"typeParameters":[{"name":"T","bounds":[]}]},{"name":"binarySearch","comment":"Searches the specified list for the specified object using the binary\n search algorithm.  The list must be sorted into ascending order\n according to the specified comparator (as by the\n {@link #sort(List, Comparator) sort(List, Comparator)}\n method), prior to making this call.  If it is\n not sorted, the results are undefined.  If the list contains multiple\n elements equal to the specified object, there is no guarantee which one\n will be found.\n\n \u003cp\u003eThis method runs in log(n) time for a \"random access\" list (which\n provides near-constant-time positional access).  If the specified list\n does not implement the {@link RandomAccess} interface and is large,\n this method will do an iterator-based binary search that performs\n O(n) link traversals and O(log n) element comparisons.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.util.List\u003c? extends T\u003e, T, java.util.Comparator\u003c? super T\u003e)","flatSignature":"(List\u003c? extends T\u003e, T, Comparator\u003c? super T\u003e)","returnType":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"list","type":{"isPrimitive":false,"simpleName":"List","qualifiedName":"java.util.List","dimension":"","elementType":{}}},{"name":"key","type":{"isPrimitive":false,"simpleName":"T","qualifiedName":"T","dimension":"","elementType":{},"typeVariable":{"name":"T","bounds":[]}}},{"name":"c","type":{"isPrimitive":false,"simpleName":"Comparator","qualifiedName":"java.util.Comparator","dimension":"","elementType":{}}}],"typeParameters":[{"name":"T","bounds":[]}]},{"name":"reverse","comment":"Reverses the order of the elements in the specified list.\u003cp\u003e\n\n This method runs in linear time.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.util.List\u003c?\u003e)","flatSignature":"(List\u003c?\u003e)","returnType":{"isPrimitive":true,"simpleName":"void","qualifiedName":"void","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"list","type":{"isPrimitive":false,"simpleName":"List","qualifiedName":"java.util.List","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"shuffle","comment":"Randomly permutes the specified list using a default source of\n randomness.  All permutations occur with approximately equal\n likelihood.\n\n \u003cp\u003eThe hedge \"approximately\" is used in the foregoing description because\n default source of randomness is only approximately an unbiased source\n of independently chosen bits. If it were a perfect source of randomly\n chosen bits, then the algorithm would choose permutations with perfect\n uniformity.\n\n \u003cp\u003eThis implementation traverses the list backwards, from the last\n element up to the second, repeatedly swapping a randomly selected element\n into the \"current position\".  Elements are randomly selected from the\n portion of the list that runs from the first element to the current\n position, inclusive.\n\n \u003cp\u003eThis method runs in linear time.  If the specified list does not\n implement the {@link RandomAccess} interface and is large, this\n implementation dumps the specified list into an array before shuffling\n it, and dumps the shuffled array back into the list.  This avoids the\n quadratic behavior that would result from shuffling a \"sequential\n access\" list in place.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.util.List\u003c?\u003e)","flatSignature":"(List\u003c?\u003e)","returnType":{"isPrimitive":true,"simpleName":"void","qualifiedName":"void","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"list","type":{"isPrimitive":false,"simpleName":"List","qualifiedName":"java.util.List","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"shuffle","comment":"Randomly permute the specified list using the specified source of\n randomness.  All permutations occur with equal likelihood\n assuming that the source of randomness is fair.\u003cp\u003e\n\n This implementation traverses the list backwards, from the last element\n up to the second, repeatedly swapping a randomly selected element into\n the \"current position\".  Elements are randomly selected from the\n portion of the list that runs from the first element to the current\n position, inclusive.\u003cp\u003e\n\n This method runs in linear time.  If the specified list does not\n implement the {@link RandomAccess} interface and is large, this\n implementation dumps the specified list into an array before shuffling\n it, and dumps the shuffled array back into the list.  This avoids the\n quadratic behavior that would result from shuffling a \"sequential\n access\" list in place.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.util.List\u003c?\u003e, java.util.Random)","flatSignature":"(List\u003c?\u003e, Random)","returnType":{"isPrimitive":true,"simpleName":"void","qualifiedName":"void","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"list","type":{"isPrimitive":false,"simpleName":"List","qualifiedName":"java.util.List","dimension":"","elementType":{}}},{"name":"rnd","type":{"isPrimitive":false,"simpleName":"Random","qualifiedName":"java.util.Random","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"swap","comment":"Swaps the elements at the specified positions in the specified list.\n (If the specified positions are equal, invoking this method leaves\n the list unchanged.)","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.util.List\u003c?\u003e, int, int)","flatSignature":"(List\u003c?\u003e, int, int)","returnType":{"isPrimitive":true,"simpleName":"void","qualifiedName":"void","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"list","type":{"isPrimitive":false,"simpleName":"List","qualifiedName":"java.util.List","dimension":"","elementType":{}}},{"name":"i","type":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}}},{"name":"j","type":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"fill","comment":"Replaces all of the elements of the specified list with the specified\n element. \u003cp\u003e\n\n This method runs in linear time.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.util.List\u003c? super T\u003e, T)","flatSignature":"(List\u003c? super T\u003e, T)","returnType":{"isPrimitive":true,"simpleName":"void","qualifiedName":"void","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"list","type":{"isPrimitive":false,"simpleName":"List","qualifiedName":"java.util.List","dimension":"","elementType":{}}},{"name":"obj","type":{"isPrimitive":false,"simpleName":"T","qualifiedName":"T","dimension":"","elementType":{},"typeVariable":{"name":"T","bounds":[]}}}],"typeParameters":[{"name":"T","bounds":[]}]},{"name":"copy","comment":"Copies all of the elements from one list into another.  After the\n operation, the index of each copied element in the destination list\n will be identical to its index in the source list.  The destination\n list must be at least as long as the source list.  If it is longer, the\n remaining elements in the destination list are unaffected. \u003cp\u003e\n\n This method runs in linear time.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.util.List\u003c? super T\u003e, java.util.List\u003c? extends T\u003e)","flatSignature":"(List\u003c? super T\u003e, List\u003c? extends T\u003e)","returnType":{"isPrimitive":true,"simpleName":"void","qualifiedName":"void","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"dest","type":{"isPrimitive":false,"simpleName":"List","qualifiedName":"java.util.List","dimension":"","elementType":{}}},{"name":"src","type":{"isPrimitive":false,"simpleName":"List","qualifiedName":"java.util.List","dimension":"","elementType":{}}}],"typeParameters":[{"name":"T","bounds":[]}]},{"name":"min","comment":"Returns the minimum element of the given collection, according to the\n \u003ci\u003enatural ordering\u003c/i\u003e of its elements.  All elements in the\n collection must implement the \u003ctt\u003eComparable\u003c/tt\u003e interface.\n Furthermore, all elements in the collection must be \u003ci\u003emutually\n comparable\u003c/i\u003e (that is, \u003ctt\u003ee1.compareTo(e2)\u003c/tt\u003e must not throw a\n \u003ctt\u003eClassCastException\u003c/tt\u003e for any elements \u003ctt\u003ee1\u003c/tt\u003e and\n \u003ctt\u003ee2\u003c/tt\u003e in the collection).\u003cp\u003e\n\n This method iterates over the entire collection, hence it requires\n time proportional to the size of the collection.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.util.Collection\u003c? extends T\u003e)","flatSignature":"(Collection\u003c? extends T\u003e)","returnType":{"isPrimitive":false,"simpleName":"T","qualifiedName":"T","dimension":"","elementType":{},"typeVariable":{"name":"T","bounds":["java.lang.Object","java.lang.Comparable"]}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"coll","type":{"isPrimitive":false,"simpleName":"Collection","qualifiedName":"java.util.Collection","dimension":"","elementType":{}}}],"typeParameters":[{"name":"T","bounds":["java.lang.Object","java.lang.Comparable"]}]},{"name":"min","comment":"Returns the minimum element of the given collection, according to the\n order induced by the specified comparator.  All elements in the\n collection must be \u003ci\u003emutually comparable\u003c/i\u003e by the specified\n comparator (that is, \u003ctt\u003ecomp.compare(e1, e2)\u003c/tt\u003e must not throw a\n \u003ctt\u003eClassCastException\u003c/tt\u003e for any elements \u003ctt\u003ee1\u003c/tt\u003e and\n \u003ctt\u003ee2\u003c/tt\u003e in the collection).\u003cp\u003e\n\n This method iterates over the entire collection, hence it requires\n time proportional to the size of the collection.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.util.Collection\u003c? extends T\u003e, java.util.Comparator\u003c? super T\u003e)","flatSignature":"(Collection\u003c? extends T\u003e, Comparator\u003c? super T\u003e)","returnType":{"isPrimitive":false,"simpleName":"T","qualifiedName":"T","dimension":"","elementType":{},"typeVariable":{"name":"T","bounds":[]}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"coll","type":{"isPrimitive":false,"simpleName":"Collection","qualifiedName":"java.util.Collection","dimension":"","elementType":{}}},{"name":"comp","type":{"isPrimitive":false,"simpleName":"Comparator","qualifiedName":"java.util.Comparator","dimension":"","elementType":{}}}],"typeParameters":[{"name":"T","bounds":[]}]},{"name":"max","comment":"Returns the maximum element of the given collection, according to the\n \u003ci\u003enatural ordering\u003c/i\u003e of its elements.  All elements in the\n collection must implement the \u003ctt\u003eComparable\u003c/tt\u003e interface.\n Furthermore, all elements in the collection must be \u003ci\u003emutually\n comparable\u003c/i\u003e (that is, \u003ctt\u003ee1.compareTo(e2)\u003c/tt\u003e must not throw a\n \u003ctt\u003eClassCastException\u003c/tt\u003e for any elements \u003ctt\u003ee1\u003c/tt\u003e and\n \u003ctt\u003ee2\u003c/tt\u003e in the collection).\u003cp\u003e\n\n This method iterates over the entire collection, hence it requires\n time proportional to the size of the collection.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.util.Collection\u003c? extends T\u003e)","flatSignature":"(Collection\u003c? extends T\u003e)","returnType":{"isPrimitive":false,"simpleName":"T","qualifiedName":"T","dimension":"","elementType":{},"typeVariable":{"name":"T","bounds":["java.lang.Object","java.lang.Comparable"]}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"coll","type":{"isPrimitive":false,"simpleName":"Collection","qualifiedName":"java.util.Collection","dimension":"","elementType":{}}}],"typeParameters":[{"name":"T","bounds":["java.lang.Object","java.lang.Comparable"]}]},{"name":"max","comment":"Returns the maximum element of the given collection, according to the\n order induced by the specified comparator.  All elements in the\n collection must be \u003ci\u003emutually comparable\u003c/i\u003e by the specified\n comparator (that is, \u003ctt\u003ecomp.compare(e1, e2)\u003c/tt\u003e must not throw a\n \u003ctt\u003eClassCastException\u003c/tt\u003e for any elements \u003ctt\u003ee1\u003c/tt\u003e and\n \u003ctt\u003ee2\u003c/tt\u003e in the collection).\u003cp\u003e\n\n This method iterates over the entire collection, hence it requires\n time proportional to the size of the collection.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.util.Collection\u003c? extends T\u003e, java.util.Comparator\u003c? super T\u003e)","flatSignature":"(Collection\u003c? extends T\u003e, Comparator\u003c? super T\u003e)","returnType":{"isPrimitive":false,"simpleName":"T","qualifiedName":"T","dimension":"","elementType":{},"typeVariable":{"name":"T","bounds":[]}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"coll","type":{"isPrimitive":false,"simpleName":"Collection","qualifiedName":"java.util.Collection","dimension":"","elementType":{}}},{"name":"comp","type":{"isPrimitive":false,"simpleName":"Comparator","qualifiedName":"java.util.Comparator","dimension":"","elementType":{}}}],"typeParameters":[{"name":"T","bounds":[]}]},{"name":"rotate","comment":"Rotates the elements in the specified list by the specified distance.\n After calling this method, the element at index \u003ctt\u003ei\u003c/tt\u003e will be\n the element previously at index \u003ctt\u003e(i - distance)\u003c/tt\u003e mod\n \u003ctt\u003elist.size()\u003c/tt\u003e, for all values of \u003ctt\u003ei\u003c/tt\u003e between \u003ctt\u003e0\u003c/tt\u003e\n and \u003ctt\u003elist.size()-1\u003c/tt\u003e, inclusive.  (This method has no effect on\n the size of the list.)\n\n \u003cp\u003eFor example, suppose \u003ctt\u003elist\u003c/tt\u003e comprises\u003ctt\u003e [t, a, n, k, s]\u003c/tt\u003e.\n After invoking \u003ctt\u003eCollections.rotate(list, 1)\u003c/tt\u003e (or\n \u003ctt\u003eCollections.rotate(list, -4)\u003c/tt\u003e), \u003ctt\u003elist\u003c/tt\u003e will comprise\n \u003ctt\u003e[s, t, a, n, k]\u003c/tt\u003e.\n\n \u003cp\u003eNote that this method can usefully be applied to sublists to\n move one or more elements within a list while preserving the\n order of the remaining elements.  For example, the following idiom\n moves the element at index \u003ctt\u003ej\u003c/tt\u003e forward to position\n \u003ctt\u003ek\u003c/tt\u003e (which must be greater than or equal to \u003ctt\u003ej\u003c/tt\u003e):\n \u003cpre\u003e\n     Collections.rotate(list.subList(j, k+1), -1);\n \u003c/pre\u003e\n To make this concrete, suppose \u003ctt\u003elist\u003c/tt\u003e comprises\n \u003ctt\u003e[a, b, c, d, e]\u003c/tt\u003e.  To move the element at index \u003ctt\u003e1\u003c/tt\u003e\n (\u003ctt\u003eb\u003c/tt\u003e) forward two positions, perform the following invocation:\n \u003cpre\u003e\n     Collections.rotate(l.subList(1, 4), -1);\n \u003c/pre\u003e\n The resulting list is \u003ctt\u003e[a, c, d, b, e]\u003c/tt\u003e.\n\n \u003cp\u003eTo move more than one element forward, increase the absolute value\n of the rotation distance.  To move elements backward, use a positive\n shift distance.\n\n \u003cp\u003eIf the specified list is small or implements the {@link\n RandomAccess} interface, this implementation exchanges the first\n element into the location it should go, and then repeatedly exchanges\n the displaced element into the location it should go until a displaced\n element is swapped into the first element.  If necessary, the process\n is repeated on the second and successive elements, until the rotation\n is complete.  If the specified list is large and doesn\u0027t implement the\n \u003ctt\u003eRandomAccess\u003c/tt\u003e interface, this implementation breaks the\n list into two sublist views around index \u003ctt\u003e-distance mod size\u003c/tt\u003e.\n Then the {@link #reverse(List)} method is invoked on each sublist view,\n and finally it is invoked on the entire list.  For a more complete\n description of both algorithms, see Section 2.3 of Jon Bentley\u0027s\n \u003ci\u003eProgramming Pearls\u003c/i\u003e (Addison-Wesley, 1986).","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.util.List\u003c?\u003e, int)","flatSignature":"(List\u003c?\u003e, int)","returnType":{"isPrimitive":true,"simpleName":"void","qualifiedName":"void","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"list","type":{"isPrimitive":false,"simpleName":"List","qualifiedName":"java.util.List","dimension":"","elementType":{}}},{"name":"distance","type":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"replaceAll","comment":"Replaces all occurrences of one specified value in a list with another.\n More formally, replaces with \u003ctt\u003enewVal\u003c/tt\u003e each element \u003ctt\u003ee\u003c/tt\u003e\n in \u003ctt\u003elist\u003c/tt\u003e such that\n \u003ctt\u003e(oldVal\u003d\u003dnull ? e\u003d\u003dnull : oldVal.equals(e))\u003c/tt\u003e.\n (This method has no effect on the size of the list.)","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.util.List\u003cT\u003e, T, T)","flatSignature":"(List\u003cT\u003e, T, T)","returnType":{"isPrimitive":true,"simpleName":"boolean","qualifiedName":"boolean","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"list","type":{"isPrimitive":false,"simpleName":"List","qualifiedName":"java.util.List","dimension":"","elementType":{}}},{"name":"oldVal","type":{"isPrimitive":false,"simpleName":"T","qualifiedName":"T","dimension":"","elementType":{},"typeVariable":{"name":"T","bounds":[]}}},{"name":"newVal","type":{"isPrimitive":false,"simpleName":"T","qualifiedName":"T","dimension":"","elementType":{},"typeVariable":{"name":"T","bounds":[]}}}],"typeParameters":[{"name":"T","bounds":[]}]},{"name":"indexOfSubList","comment":"Returns the starting position of the first occurrence of the specified\n target list within the specified source list, or -1 if there is no\n such occurrence.  More formally, returns the lowest index \u003ctt\u003ei\u003c/tt\u003e\n such that {@code source.subList(i, i+target.size()).equals(target)},\n or -1 if there is no such index.  (Returns -1 if\n {@code target.size() \u003e source.size()})\n\n \u003cp\u003eThis implementation uses the \"brute force\" technique of scanning\n over the source list, looking for a match with the target at each\n location in turn.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.util.List\u003c?\u003e, java.util.List\u003c?\u003e)","flatSignature":"(List\u003c?\u003e, List\u003c?\u003e)","returnType":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"source","type":{"isPrimitive":false,"simpleName":"List","qualifiedName":"java.util.List","dimension":"","elementType":{}}},{"name":"target","type":{"isPrimitive":false,"simpleName":"List","qualifiedName":"java.util.List","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"lastIndexOfSubList","comment":"Returns the starting position of the last occurrence of the specified\n target list within the specified source list, or -1 if there is no such\n occurrence.  More formally, returns the highest index \u003ctt\u003ei\u003c/tt\u003e\n such that {@code source.subList(i, i+target.size()).equals(target)},\n or -1 if there is no such index.  (Returns -1 if\n {@code target.size() \u003e source.size()})\n\n \u003cp\u003eThis implementation uses the \"brute force\" technique of iterating\n over the source list, looking for a match with the target at each\n location in turn.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.util.List\u003c?\u003e, java.util.List\u003c?\u003e)","flatSignature":"(List\u003c?\u003e, List\u003c?\u003e)","returnType":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"source","type":{"isPrimitive":false,"simpleName":"List","qualifiedName":"java.util.List","dimension":"","elementType":{}}},{"name":"target","type":{"isPrimitive":false,"simpleName":"List","qualifiedName":"java.util.List","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"unmodifiableCollection","comment":"Returns an unmodifiable view of the specified collection.  This method\n allows modules to provide users with \"read-only\" access to internal\n collections.  Query operations on the returned collection \"read through\"\n to the specified collection, and attempts to modify the returned\n collection, whether direct or via its iterator, result in an\n \u003ctt\u003eUnsupportedOperationException\u003c/tt\u003e.\u003cp\u003e\n\n The returned collection does \u003ci\u003enot\u003c/i\u003e pass the hashCode and equals\n operations through to the backing collection, but relies on\n \u003ctt\u003eObject\u003c/tt\u003e\u0027s \u003ctt\u003eequals\u003c/tt\u003e and \u003ctt\u003ehashCode\u003c/tt\u003e methods.  This\n is necessary to preserve the contracts of these operations in the case\n that the backing collection is a set or a list.\u003cp\u003e\n\n The returned collection will be serializable if the specified collection\n is serializable.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.util.Collection\u003c? extends T\u003e)","flatSignature":"(Collection\u003c? extends T\u003e)","returnType":{"isPrimitive":false,"simpleName":"Collection","qualifiedName":"java.util.Collection","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"c","type":{"isPrimitive":false,"simpleName":"Collection","qualifiedName":"java.util.Collection","dimension":"","elementType":{}}}],"typeParameters":[{"name":"T","bounds":[]}]},{"name":"unmodifiableSet","comment":"Returns an unmodifiable view of the specified set.  This method allows\n modules to provide users with \"read-only\" access to internal sets.\n Query operations on the returned set \"read through\" to the specified\n set, and attempts to modify the returned set, whether direct or via its\n iterator, result in an \u003ctt\u003eUnsupportedOperationException\u003c/tt\u003e.\u003cp\u003e\n\n The returned set will be serializable if the specified set\n is serializable.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.util.Set\u003c? extends T\u003e)","flatSignature":"(Set\u003c? extends T\u003e)","returnType":{"isPrimitive":false,"simpleName":"Set","qualifiedName":"java.util.Set","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"s","type":{"isPrimitive":false,"simpleName":"Set","qualifiedName":"java.util.Set","dimension":"","elementType":{}}}],"typeParameters":[{"name":"T","bounds":[]}]},{"name":"unmodifiableSortedSet","comment":"Returns an unmodifiable view of the specified sorted set.  This method\n allows modules to provide users with \"read-only\" access to internal\n sorted sets.  Query operations on the returned sorted set \"read\n through\" to the specified sorted set.  Attempts to modify the returned\n sorted set, whether direct, via its iterator, or via its\n \u003ctt\u003esubSet\u003c/tt\u003e, \u003ctt\u003eheadSet\u003c/tt\u003e, or \u003ctt\u003etailSet\u003c/tt\u003e views, result in\n an \u003ctt\u003eUnsupportedOperationException\u003c/tt\u003e.\u003cp\u003e\n\n The returned sorted set will be serializable if the specified sorted set\n is serializable.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.util.SortedSet\u003cT\u003e)","flatSignature":"(SortedSet\u003cT\u003e)","returnType":{"isPrimitive":false,"simpleName":"SortedSet","qualifiedName":"java.util.SortedSet","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"s","type":{"isPrimitive":false,"simpleName":"SortedSet","qualifiedName":"java.util.SortedSet","dimension":"","elementType":{}}}],"typeParameters":[{"name":"T","bounds":[]}]},{"name":"unmodifiableNavigableSet","comment":"Returns an unmodifiable view of the specified navigable set.  This method\n allows modules to provide users with \"read-only\" access to internal\n navigable sets.  Query operations on the returned navigable set \"read\n through\" to the specified navigable set.  Attempts to modify the returned\n navigable set, whether direct, via its iterator, or via its\n {@code subSet}, {@code headSet}, or {@code tailSet} views, result in\n an {@code UnsupportedOperationException}.\u003cp\u003e\n\n The returned navigable set will be serializable if the specified\n navigable set is serializable.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.util.NavigableSet\u003cT\u003e)","flatSignature":"(NavigableSet\u003cT\u003e)","returnType":{"isPrimitive":false,"simpleName":"NavigableSet","qualifiedName":"java.util.NavigableSet","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"s","type":{"isPrimitive":false,"simpleName":"NavigableSet","qualifiedName":"java.util.NavigableSet","dimension":"","elementType":{}}}],"typeParameters":[{"name":"T","bounds":[]}]},{"name":"unmodifiableList","comment":"Returns an unmodifiable view of the specified list.  This method allows\n modules to provide users with \"read-only\" access to internal\n lists.  Query operations on the returned list \"read through\" to the\n specified list, and attempts to modify the returned list, whether\n direct or via its iterator, result in an\n \u003ctt\u003eUnsupportedOperationException\u003c/tt\u003e.\u003cp\u003e\n\n The returned list will be serializable if the specified list\n is serializable. Similarly, the returned list will implement\n {@link RandomAccess} if the specified list does.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.util.List\u003c? extends T\u003e)","flatSignature":"(List\u003c? extends T\u003e)","returnType":{"isPrimitive":false,"simpleName":"List","qualifiedName":"java.util.List","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"list","type":{"isPrimitive":false,"simpleName":"List","qualifiedName":"java.util.List","dimension":"","elementType":{}}}],"typeParameters":[{"name":"T","bounds":[]}]},{"name":"unmodifiableMap","comment":"Returns an unmodifiable view of the specified map.  This method\n allows modules to provide users with \"read-only\" access to internal\n maps.  Query operations on the returned map \"read through\"\n to the specified map, and attempts to modify the returned\n map, whether direct or via its collection views, result in an\n \u003ctt\u003eUnsupportedOperationException\u003c/tt\u003e.\u003cp\u003e\n\n The returned map will be serializable if the specified map\n is serializable.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.util.Map\u003c? extends K, ? extends V\u003e)","flatSignature":"(Map\u003c? extends K, ? extends V\u003e)","returnType":{"isPrimitive":false,"simpleName":"Map","qualifiedName":"java.util.Map","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"m","type":{"isPrimitive":false,"simpleName":"Map","qualifiedName":"java.util.Map","dimension":"","elementType":{}}}],"typeParameters":[{"name":"K","bounds":[]},{"name":"V","bounds":[]}]},{"name":"unmodifiableSortedMap","comment":"Returns an unmodifiable view of the specified sorted map.  This method\n allows modules to provide users with \"read-only\" access to internal\n sorted maps.  Query operations on the returned sorted map \"read through\"\n to the specified sorted map.  Attempts to modify the returned\n sorted map, whether direct, via its collection views, or via its\n \u003ctt\u003esubMap\u003c/tt\u003e, \u003ctt\u003eheadMap\u003c/tt\u003e, or \u003ctt\u003etailMap\u003c/tt\u003e views, result in\n an \u003ctt\u003eUnsupportedOperationException\u003c/tt\u003e.\u003cp\u003e\n\n The returned sorted map will be serializable if the specified sorted map\n is serializable.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.util.SortedMap\u003cK, ? extends V\u003e)","flatSignature":"(SortedMap\u003cK, ? extends V\u003e)","returnType":{"isPrimitive":false,"simpleName":"SortedMap","qualifiedName":"java.util.SortedMap","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"m","type":{"isPrimitive":false,"simpleName":"SortedMap","qualifiedName":"java.util.SortedMap","dimension":"","elementType":{}}}],"typeParameters":[{"name":"K","bounds":[]},{"name":"V","bounds":[]}]},{"name":"unmodifiableNavigableMap","comment":"Returns an unmodifiable view of the specified navigable map.  This method\n allows modules to provide users with \"read-only\" access to internal\n navigable maps.  Query operations on the returned navigable map \"read\n through\" to the specified navigable map.  Attempts to modify the returned\n navigable map, whether direct, via its collection views, or via its\n {@code subMap}, {@code headMap}, or {@code tailMap} views, result in\n an {@code UnsupportedOperationException}.\u003cp\u003e\n\n The returned navigable map will be serializable if the specified\n navigable map is serializable.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.util.NavigableMap\u003cK, ? extends V\u003e)","flatSignature":"(NavigableMap\u003cK, ? extends V\u003e)","returnType":{"isPrimitive":false,"simpleName":"NavigableMap","qualifiedName":"java.util.NavigableMap","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"m","type":{"isPrimitive":false,"simpleName":"NavigableMap","qualifiedName":"java.util.NavigableMap","dimension":"","elementType":{}}}],"typeParameters":[{"name":"K","bounds":[]},{"name":"V","bounds":[]}]},{"name":"synchronizedCollection","comment":"Returns a synchronized (thread-safe) collection backed by the specified\n collection.  In order to guarantee serial access, it is critical that\n \u003cstrong\u003eall\u003c/strong\u003e access to the backing collection is accomplished\n through the returned collection.\u003cp\u003e\n\n It is imperative that the user manually synchronize on the returned\n collection when traversing it via {@link Iterator}, {@link Spliterator}\n or {@link Stream}:\n \u003cpre\u003e\n  Collection c \u003d Collections.synchronizedCollection(myCollection);\n     ...\n  synchronized (c) {\n      Iterator i \u003d c.iterator(); // Must be in the synchronized block\n      while (i.hasNext())\n         foo(i.next());\n  }\n \u003c/pre\u003e\n Failure to follow this advice may result in non-deterministic behavior.\n\n \u003cp\u003eThe returned collection does \u003ci\u003enot\u003c/i\u003e pass the {@code hashCode}\n and {@code equals} operations through to the backing collection, but\n relies on {@code Object}\u0027s equals and hashCode methods.  This is\n necessary to preserve the contracts of these operations in the case\n that the backing collection is a set or a list.\u003cp\u003e\n\n The returned collection will be serializable if the specified collection\n is serializable.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.util.Collection\u003cT\u003e)","flatSignature":"(Collection\u003cT\u003e)","returnType":{"isPrimitive":false,"simpleName":"Collection","qualifiedName":"java.util.Collection","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"c","type":{"isPrimitive":false,"simpleName":"Collection","qualifiedName":"java.util.Collection","dimension":"","elementType":{}}}],"typeParameters":[{"name":"T","bounds":[]}]},{"name":"synchronizedSet","comment":"Returns a synchronized (thread-safe) set backed by the specified\n set.  In order to guarantee serial access, it is critical that\n \u003cstrong\u003eall\u003c/strong\u003e access to the backing set is accomplished\n through the returned set.\u003cp\u003e\n\n It is imperative that the user manually synchronize on the returned\n set when iterating over it:\n \u003cpre\u003e\n  Set s \u003d Collections.synchronizedSet(new HashSet());\n      ...\n  synchronized (s) {\n      Iterator i \u003d s.iterator(); // Must be in the synchronized block\n      while (i.hasNext())\n          foo(i.next());\n  }\n \u003c/pre\u003e\n Failure to follow this advice may result in non-deterministic behavior.\n\n \u003cp\u003eThe returned set will be serializable if the specified set is\n serializable.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.util.Set\u003cT\u003e)","flatSignature":"(Set\u003cT\u003e)","returnType":{"isPrimitive":false,"simpleName":"Set","qualifiedName":"java.util.Set","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"s","type":{"isPrimitive":false,"simpleName":"Set","qualifiedName":"java.util.Set","dimension":"","elementType":{}}}],"typeParameters":[{"name":"T","bounds":[]}]},{"name":"synchronizedSortedSet","comment":"Returns a synchronized (thread-safe) sorted set backed by the specified\n sorted set.  In order to guarantee serial access, it is critical that\n \u003cstrong\u003eall\u003c/strong\u003e access to the backing sorted set is accomplished\n through the returned sorted set (or its views).\u003cp\u003e\n\n It is imperative that the user manually synchronize on the returned\n sorted set when iterating over it or any of its \u003ctt\u003esubSet\u003c/tt\u003e,\n \u003ctt\u003eheadSet\u003c/tt\u003e, or \u003ctt\u003etailSet\u003c/tt\u003e views.\n \u003cpre\u003e\n  SortedSet s \u003d Collections.synchronizedSortedSet(new TreeSet());\n      ...\n  synchronized (s) {\n      Iterator i \u003d s.iterator(); // Must be in the synchronized block\n      while (i.hasNext())\n          foo(i.next());\n  }\n \u003c/pre\u003e\n or:\n \u003cpre\u003e\n  SortedSet s \u003d Collections.synchronizedSortedSet(new TreeSet());\n  SortedSet s2 \u003d s.headSet(foo);\n      ...\n  synchronized (s) {  // Note: s, not s2!!!\n      Iterator i \u003d s2.iterator(); // Must be in the synchronized block\n      while (i.hasNext())\n          foo(i.next());\n  }\n \u003c/pre\u003e\n Failure to follow this advice may result in non-deterministic behavior.\n\n \u003cp\u003eThe returned sorted set will be serializable if the specified\n sorted set is serializable.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.util.SortedSet\u003cT\u003e)","flatSignature":"(SortedSet\u003cT\u003e)","returnType":{"isPrimitive":false,"simpleName":"SortedSet","qualifiedName":"java.util.SortedSet","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"s","type":{"isPrimitive":false,"simpleName":"SortedSet","qualifiedName":"java.util.SortedSet","dimension":"","elementType":{}}}],"typeParameters":[{"name":"T","bounds":[]}]},{"name":"synchronizedNavigableSet","comment":"Returns a synchronized (thread-safe) navigable set backed by the\n specified navigable set.  In order to guarantee serial access, it is\n critical that \u003cstrong\u003eall\u003c/strong\u003e access to the backing navigable set is\n accomplished through the returned navigable set (or its views).\u003cp\u003e\n\n It is imperative that the user manually synchronize on the returned\n navigable set when iterating over it or any of its {@code subSet},\n {@code headSet}, or {@code tailSet} views.\n \u003cpre\u003e\n  NavigableSet s \u003d Collections.synchronizedNavigableSet(new TreeSet());\n      ...\n  synchronized (s) {\n      Iterator i \u003d s.iterator(); // Must be in the synchronized block\n      while (i.hasNext())\n          foo(i.next());\n  }\n \u003c/pre\u003e\n or:\n \u003cpre\u003e\n  NavigableSet s \u003d Collections.synchronizedNavigableSet(new TreeSet());\n  NavigableSet s2 \u003d s.headSet(foo, true);\n      ...\n  synchronized (s) {  // Note: s, not s2!!!\n      Iterator i \u003d s2.iterator(); // Must be in the synchronized block\n      while (i.hasNext())\n          foo(i.next());\n  }\n \u003c/pre\u003e\n Failure to follow this advice may result in non-deterministic behavior.\n\n \u003cp\u003eThe returned navigable set will be serializable if the specified\n navigable set is serializable.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.util.NavigableSet\u003cT\u003e)","flatSignature":"(NavigableSet\u003cT\u003e)","returnType":{"isPrimitive":false,"simpleName":"NavigableSet","qualifiedName":"java.util.NavigableSet","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"s","type":{"isPrimitive":false,"simpleName":"NavigableSet","qualifiedName":"java.util.NavigableSet","dimension":"","elementType":{}}}],"typeParameters":[{"name":"T","bounds":[]}]},{"name":"synchronizedList","comment":"Returns a synchronized (thread-safe) list backed by the specified\n list.  In order to guarantee serial access, it is critical that\n \u003cstrong\u003eall\u003c/strong\u003e access to the backing list is accomplished\n through the returned list.\u003cp\u003e\n\n It is imperative that the user manually synchronize on the returned\n list when iterating over it:\n \u003cpre\u003e\n  List list \u003d Collections.synchronizedList(new ArrayList());\n      ...\n  synchronized (list) {\n      Iterator i \u003d list.iterator(); // Must be in synchronized block\n      while (i.hasNext())\n          foo(i.next());\n  }\n \u003c/pre\u003e\n Failure to follow this advice may result in non-deterministic behavior.\n\n \u003cp\u003eThe returned list will be serializable if the specified list is\n serializable.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.util.List\u003cT\u003e)","flatSignature":"(List\u003cT\u003e)","returnType":{"isPrimitive":false,"simpleName":"List","qualifiedName":"java.util.List","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"list","type":{"isPrimitive":false,"simpleName":"List","qualifiedName":"java.util.List","dimension":"","elementType":{}}}],"typeParameters":[{"name":"T","bounds":[]}]},{"name":"synchronizedMap","comment":"Returns a synchronized (thread-safe) map backed by the specified\n map.  In order to guarantee serial access, it is critical that\n \u003cstrong\u003eall\u003c/strong\u003e access to the backing map is accomplished\n through the returned map.\u003cp\u003e\n\n It is imperative that the user manually synchronize on the returned\n map when iterating over any of its collection views:\n \u003cpre\u003e\n  Map m \u003d Collections.synchronizedMap(new HashMap());\n      ...\n  Set s \u003d m.keySet();  // Needn\u0027t be in synchronized block\n      ...\n  synchronized (m) {  // Synchronizing on m, not s!\n      Iterator i \u003d s.iterator(); // Must be in synchronized block\n      while (i.hasNext())\n          foo(i.next());\n  }\n \u003c/pre\u003e\n Failure to follow this advice may result in non-deterministic behavior.\n\n \u003cp\u003eThe returned map will be serializable if the specified map is\n serializable.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.util.Map\u003cK, V\u003e)","flatSignature":"(Map\u003cK, V\u003e)","returnType":{"isPrimitive":false,"simpleName":"Map","qualifiedName":"java.util.Map","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"m","type":{"isPrimitive":false,"simpleName":"Map","qualifiedName":"java.util.Map","dimension":"","elementType":{}}}],"typeParameters":[{"name":"K","bounds":[]},{"name":"V","bounds":[]}]},{"name":"synchronizedSortedMap","comment":"Returns a synchronized (thread-safe) sorted map backed by the specified\n sorted map.  In order to guarantee serial access, it is critical that\n \u003cstrong\u003eall\u003c/strong\u003e access to the backing sorted map is accomplished\n through the returned sorted map (or its views).\u003cp\u003e\n\n It is imperative that the user manually synchronize on the returned\n sorted map when iterating over any of its collection views, or the\n collections views of any of its \u003ctt\u003esubMap\u003c/tt\u003e, \u003ctt\u003eheadMap\u003c/tt\u003e or\n \u003ctt\u003etailMap\u003c/tt\u003e views.\n \u003cpre\u003e\n  SortedMap m \u003d Collections.synchronizedSortedMap(new TreeMap());\n      ...\n  Set s \u003d m.keySet();  // Needn\u0027t be in synchronized block\n      ...\n  synchronized (m) {  // Synchronizing on m, not s!\n      Iterator i \u003d s.iterator(); // Must be in synchronized block\n      while (i.hasNext())\n          foo(i.next());\n  }\n \u003c/pre\u003e\n or:\n \u003cpre\u003e\n  SortedMap m \u003d Collections.synchronizedSortedMap(new TreeMap());\n  SortedMap m2 \u003d m.subMap(foo, bar);\n      ...\n  Set s2 \u003d m2.keySet();  // Needn\u0027t be in synchronized block\n      ...\n  synchronized (m) {  // Synchronizing on m, not m2 or s2!\n      Iterator i \u003d s.iterator(); // Must be in synchronized block\n      while (i.hasNext())\n          foo(i.next());\n  }\n \u003c/pre\u003e\n Failure to follow this advice may result in non-deterministic behavior.\n\n \u003cp\u003eThe returned sorted map will be serializable if the specified\n sorted map is serializable.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.util.SortedMap\u003cK, V\u003e)","flatSignature":"(SortedMap\u003cK, V\u003e)","returnType":{"isPrimitive":false,"simpleName":"SortedMap","qualifiedName":"java.util.SortedMap","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"m","type":{"isPrimitive":false,"simpleName":"SortedMap","qualifiedName":"java.util.SortedMap","dimension":"","elementType":{}}}],"typeParameters":[{"name":"K","bounds":[]},{"name":"V","bounds":[]}]},{"name":"synchronizedNavigableMap","comment":"Returns a synchronized (thread-safe) navigable map backed by the\n specified navigable map.  In order to guarantee serial access, it is\n critical that \u003cstrong\u003eall\u003c/strong\u003e access to the backing navigable map is\n accomplished through the returned navigable map (or its views).\u003cp\u003e\n\n It is imperative that the user manually synchronize on the returned\n navigable map when iterating over any of its collection views, or the\n collections views of any of its {@code subMap}, {@code headMap} or\n {@code tailMap} views.\n \u003cpre\u003e\n  NavigableMap m \u003d Collections.synchronizedNavigableMap(new TreeMap());\n      ...\n  Set s \u003d m.keySet();  // Needn\u0027t be in synchronized block\n      ...\n  synchronized (m) {  // Synchronizing on m, not s!\n      Iterator i \u003d s.iterator(); // Must be in synchronized block\n      while (i.hasNext())\n          foo(i.next());\n  }\n \u003c/pre\u003e\n or:\n \u003cpre\u003e\n  NavigableMap m \u003d Collections.synchronizedNavigableMap(new TreeMap());\n  NavigableMap m2 \u003d m.subMap(foo, true, bar, false);\n      ...\n  Set s2 \u003d m2.keySet();  // Needn\u0027t be in synchronized block\n      ...\n  synchronized (m) {  // Synchronizing on m, not m2 or s2!\n      Iterator i \u003d s.iterator(); // Must be in synchronized block\n      while (i.hasNext())\n          foo(i.next());\n  }\n \u003c/pre\u003e\n Failure to follow this advice may result in non-deterministic behavior.\n\n \u003cp\u003eThe returned navigable map will be serializable if the specified\n navigable map is serializable.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.util.NavigableMap\u003cK, V\u003e)","flatSignature":"(NavigableMap\u003cK, V\u003e)","returnType":{"isPrimitive":false,"simpleName":"NavigableMap","qualifiedName":"java.util.NavigableMap","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"m","type":{"isPrimitive":false,"simpleName":"NavigableMap","qualifiedName":"java.util.NavigableMap","dimension":"","elementType":{}}}],"typeParameters":[{"name":"K","bounds":[]},{"name":"V","bounds":[]}]},{"name":"checkedCollection","comment":"Returns a dynamically typesafe view of the specified collection.\n Any attempt to insert an element of the wrong type will result in an\n immediate {@link ClassCastException}.  Assuming a collection\n contains no incorrectly typed elements prior to the time a\n dynamically typesafe view is generated, and that all subsequent\n access to the collection takes place through the view, it is\n \u003ci\u003eguaranteed\u003c/i\u003e that the collection cannot contain an incorrectly\n typed element.\n\n \u003cp\u003eThe generics mechanism in the language provides compile-time\n (static) type checking, but it is possible to defeat this mechanism\n with unchecked casts.  Usually this is not a problem, as the compiler\n issues warnings on all such unchecked operations.  There are, however,\n times when static type checking alone is not sufficient.  For example,\n suppose a collection is passed to a third-party library and it is\n imperative that the library code not corrupt the collection by\n inserting an element of the wrong type.\n\n \u003cp\u003eAnother use of dynamically typesafe views is debugging.  Suppose a\n program fails with a {@code ClassCastException}, indicating that an\n incorrectly typed element was put into a parameterized collection.\n Unfortunately, the exception can occur at any time after the erroneous\n element is inserted, so it typically provides little or no information\n as to the real source of the problem.  If the problem is reproducible,\n one can quickly determine its source by temporarily modifying the\n program to wrap the collection with a dynamically typesafe view.\n For example, this declaration:\n  \u003cpre\u003e {@code\n     Collection\u003cString\u003e c \u003d new HashSet\u003c\u003e();\n }\u003c/pre\u003e\n may be replaced temporarily by this one:\n  \u003cpre\u003e {@code\n     Collection\u003cString\u003e c \u003d Collections.checkedCollection(\n         new HashSet\u003c\u003e(), String.class);\n }\u003c/pre\u003e\n Running the program again will cause it to fail at the point where\n an incorrectly typed element is inserted into the collection, clearly\n identifying the source of the problem.  Once the problem is fixed, the\n modified declaration may be reverted back to the original.\n\n \u003cp\u003eThe returned collection does \u003ci\u003enot\u003c/i\u003e pass the hashCode and equals\n operations through to the backing collection, but relies on\n {@code Object}\u0027s {@code equals} and {@code hashCode} methods.  This\n is necessary to preserve the contracts of these operations in the case\n that the backing collection is a set or a list.\n\n \u003cp\u003eThe returned collection will be serializable if the specified\n collection is serializable.\n\n \u003cp\u003eSince {@code null} is considered to be a value of any reference\n type, the returned collection permits insertion of null elements\n whenever the backing collection does.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.util.Collection\u003cE\u003e, java.lang.Class\u003cE\u003e)","flatSignature":"(Collection\u003cE\u003e, Class\u003cE\u003e)","returnType":{"isPrimitive":false,"simpleName":"Collection","qualifiedName":"java.util.Collection","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"c","type":{"isPrimitive":false,"simpleName":"Collection","qualifiedName":"java.util.Collection","dimension":"","elementType":{}}},{"name":"type","type":{"isPrimitive":false,"simpleName":"Class","qualifiedName":"java.lang.Class","dimension":"","elementType":{}}}],"typeParameters":[{"name":"E","bounds":[]}]},{"name":"checkedQueue","comment":"Returns a dynamically typesafe view of the specified queue.\n Any attempt to insert an element of the wrong type will result in\n an immediate {@link ClassCastException}.  Assuming a queue contains\n no incorrectly typed elements prior to the time a dynamically typesafe\n view is generated, and that all subsequent access to the queue\n takes place through the view, it is \u003ci\u003eguaranteed\u003c/i\u003e that the\n queue cannot contain an incorrectly typed element.\n\n \u003cp\u003eA discussion of the use of dynamically typesafe views may be\n found in the documentation for the {@link #checkedCollection\n checkedCollection} method.\n\n \u003cp\u003eThe returned queue will be serializable if the specified queue\n is serializable.\n\n \u003cp\u003eSince {@code null} is considered to be a value of any reference\n type, the returned queue permits insertion of {@code null} elements\n whenever the backing queue does.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.util.Queue\u003cE\u003e, java.lang.Class\u003cE\u003e)","flatSignature":"(Queue\u003cE\u003e, Class\u003cE\u003e)","returnType":{"isPrimitive":false,"simpleName":"Queue","qualifiedName":"java.util.Queue","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"queue","type":{"isPrimitive":false,"simpleName":"Queue","qualifiedName":"java.util.Queue","dimension":"","elementType":{}}},{"name":"type","type":{"isPrimitive":false,"simpleName":"Class","qualifiedName":"java.lang.Class","dimension":"","elementType":{}}}],"typeParameters":[{"name":"E","bounds":[]}]},{"name":"checkedSet","comment":"Returns a dynamically typesafe view of the specified set.\n Any attempt to insert an element of the wrong type will result in\n an immediate {@link ClassCastException}.  Assuming a set contains\n no incorrectly typed elements prior to the time a dynamically typesafe\n view is generated, and that all subsequent access to the set\n takes place through the view, it is \u003ci\u003eguaranteed\u003c/i\u003e that the\n set cannot contain an incorrectly typed element.\n\n \u003cp\u003eA discussion of the use of dynamically typesafe views may be\n found in the documentation for the {@link #checkedCollection\n checkedCollection} method.\n\n \u003cp\u003eThe returned set will be serializable if the specified set is\n serializable.\n\n \u003cp\u003eSince {@code null} is considered to be a value of any reference\n type, the returned set permits insertion of null elements whenever\n the backing set does.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.util.Set\u003cE\u003e, java.lang.Class\u003cE\u003e)","flatSignature":"(Set\u003cE\u003e, Class\u003cE\u003e)","returnType":{"isPrimitive":false,"simpleName":"Set","qualifiedName":"java.util.Set","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"s","type":{"isPrimitive":false,"simpleName":"Set","qualifiedName":"java.util.Set","dimension":"","elementType":{}}},{"name":"type","type":{"isPrimitive":false,"simpleName":"Class","qualifiedName":"java.lang.Class","dimension":"","elementType":{}}}],"typeParameters":[{"name":"E","bounds":[]}]},{"name":"checkedSortedSet","comment":"Returns a dynamically typesafe view of the specified sorted set.\n Any attempt to insert an element of the wrong type will result in an\n immediate {@link ClassCastException}.  Assuming a sorted set\n contains no incorrectly typed elements prior to the time a\n dynamically typesafe view is generated, and that all subsequent\n access to the sorted set takes place through the view, it is\n \u003ci\u003eguaranteed\u003c/i\u003e that the sorted set cannot contain an incorrectly\n typed element.\n\n \u003cp\u003eA discussion of the use of dynamically typesafe views may be\n found in the documentation for the {@link #checkedCollection\n checkedCollection} method.\n\n \u003cp\u003eThe returned sorted set will be serializable if the specified sorted\n set is serializable.\n\n \u003cp\u003eSince {@code null} is considered to be a value of any reference\n type, the returned sorted set permits insertion of null elements\n whenever the backing sorted set does.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.util.SortedSet\u003cE\u003e, java.lang.Class\u003cE\u003e)","flatSignature":"(SortedSet\u003cE\u003e, Class\u003cE\u003e)","returnType":{"isPrimitive":false,"simpleName":"SortedSet","qualifiedName":"java.util.SortedSet","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"s","type":{"isPrimitive":false,"simpleName":"SortedSet","qualifiedName":"java.util.SortedSet","dimension":"","elementType":{}}},{"name":"type","type":{"isPrimitive":false,"simpleName":"Class","qualifiedName":"java.lang.Class","dimension":"","elementType":{}}}],"typeParameters":[{"name":"E","bounds":[]}]},{"name":"checkedNavigableSet","comment":"Returns a dynamically typesafe view of the specified navigable set.\n Any attempt to insert an element of the wrong type will result in an\n immediate {@link ClassCastException}.  Assuming a navigable set\n contains no incorrectly typed elements prior to the time a\n dynamically typesafe view is generated, and that all subsequent\n access to the navigable set takes place through the view, it is\n \u003cem\u003eguaranteed\u003c/em\u003e that the navigable set cannot contain an incorrectly\n typed element.\n\n \u003cp\u003eA discussion of the use of dynamically typesafe views may be\n found in the documentation for the {@link #checkedCollection\n checkedCollection} method.\n\n \u003cp\u003eThe returned navigable set will be serializable if the specified\n navigable set is serializable.\n\n \u003cp\u003eSince {@code null} is considered to be a value of any reference\n type, the returned navigable set permits insertion of null elements\n whenever the backing sorted set does.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.util.NavigableSet\u003cE\u003e, java.lang.Class\u003cE\u003e)","flatSignature":"(NavigableSet\u003cE\u003e, Class\u003cE\u003e)","returnType":{"isPrimitive":false,"simpleName":"NavigableSet","qualifiedName":"java.util.NavigableSet","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"s","type":{"isPrimitive":false,"simpleName":"NavigableSet","qualifiedName":"java.util.NavigableSet","dimension":"","elementType":{}}},{"name":"type","type":{"isPrimitive":false,"simpleName":"Class","qualifiedName":"java.lang.Class","dimension":"","elementType":{}}}],"typeParameters":[{"name":"E","bounds":[]}]},{"name":"checkedList","comment":"Returns a dynamically typesafe view of the specified list.\n Any attempt to insert an element of the wrong type will result in\n an immediate {@link ClassCastException}.  Assuming a list contains\n no incorrectly typed elements prior to the time a dynamically typesafe\n view is generated, and that all subsequent access to the list\n takes place through the view, it is \u003ci\u003eguaranteed\u003c/i\u003e that the\n list cannot contain an incorrectly typed element.\n\n \u003cp\u003eA discussion of the use of dynamically typesafe views may be\n found in the documentation for the {@link #checkedCollection\n checkedCollection} method.\n\n \u003cp\u003eThe returned list will be serializable if the specified list\n is serializable.\n\n \u003cp\u003eSince {@code null} is considered to be a value of any reference\n type, the returned list permits insertion of null elements whenever\n the backing list does.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.util.List\u003cE\u003e, java.lang.Class\u003cE\u003e)","flatSignature":"(List\u003cE\u003e, Class\u003cE\u003e)","returnType":{"isPrimitive":false,"simpleName":"List","qualifiedName":"java.util.List","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"list","type":{"isPrimitive":false,"simpleName":"List","qualifiedName":"java.util.List","dimension":"","elementType":{}}},{"name":"type","type":{"isPrimitive":false,"simpleName":"Class","qualifiedName":"java.lang.Class","dimension":"","elementType":{}}}],"typeParameters":[{"name":"E","bounds":[]}]},{"name":"checkedMap","comment":"Returns a dynamically typesafe view of the specified map.\n Any attempt to insert a mapping whose key or value have the wrong\n type will result in an immediate {@link ClassCastException}.\n Similarly, any attempt to modify the value currently associated with\n a key will result in an immediate {@link ClassCastException},\n whether the modification is attempted directly through the map\n itself, or through a {@link Map.Entry} instance obtained from the\n map\u0027s {@link Map#entrySet() entry set} view.\n\n \u003cp\u003eAssuming a map contains no incorrectly typed keys or values\n prior to the time a dynamically typesafe view is generated, and\n that all subsequent access to the map takes place through the view\n (or one of its collection views), it is \u003ci\u003eguaranteed\u003c/i\u003e that the\n map cannot contain an incorrectly typed key or value.\n\n \u003cp\u003eA discussion of the use of dynamically typesafe views may be\n found in the documentation for the {@link #checkedCollection\n checkedCollection} method.\n\n \u003cp\u003eThe returned map will be serializable if the specified map is\n serializable.\n\n \u003cp\u003eSince {@code null} is considered to be a value of any reference\n type, the returned map permits insertion of null keys or values\n whenever the backing map does.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.util.Map\u003cK, V\u003e, java.lang.Class\u003cK\u003e, java.lang.Class\u003cV\u003e)","flatSignature":"(Map\u003cK, V\u003e, Class\u003cK\u003e, Class\u003cV\u003e)","returnType":{"isPrimitive":false,"simpleName":"Map","qualifiedName":"java.util.Map","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"m","type":{"isPrimitive":false,"simpleName":"Map","qualifiedName":"java.util.Map","dimension":"","elementType":{}}},{"name":"keyType","type":{"isPrimitive":false,"simpleName":"Class","qualifiedName":"java.lang.Class","dimension":"","elementType":{}}},{"name":"valueType","type":{"isPrimitive":false,"simpleName":"Class","qualifiedName":"java.lang.Class","dimension":"","elementType":{}}}],"typeParameters":[{"name":"K","bounds":[]},{"name":"V","bounds":[]}]},{"name":"checkedSortedMap","comment":"Returns a dynamically typesafe view of the specified sorted map.\n Any attempt to insert a mapping whose key or value have the wrong\n type will result in an immediate {@link ClassCastException}.\n Similarly, any attempt to modify the value currently associated with\n a key will result in an immediate {@link ClassCastException},\n whether the modification is attempted directly through the map\n itself, or through a {@link Map.Entry} instance obtained from the\n map\u0027s {@link Map#entrySet() entry set} view.\n\n \u003cp\u003eAssuming a map contains no incorrectly typed keys or values\n prior to the time a dynamically typesafe view is generated, and\n that all subsequent access to the map takes place through the view\n (or one of its collection views), it is \u003ci\u003eguaranteed\u003c/i\u003e that the\n map cannot contain an incorrectly typed key or value.\n\n \u003cp\u003eA discussion of the use of dynamically typesafe views may be\n found in the documentation for the {@link #checkedCollection\n checkedCollection} method.\n\n \u003cp\u003eThe returned map will be serializable if the specified map is\n serializable.\n\n \u003cp\u003eSince {@code null} is considered to be a value of any reference\n type, the returned map permits insertion of null keys or values\n whenever the backing map does.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.util.SortedMap\u003cK, V\u003e, java.lang.Class\u003cK\u003e, java.lang.Class\u003cV\u003e)","flatSignature":"(SortedMap\u003cK, V\u003e, Class\u003cK\u003e, Class\u003cV\u003e)","returnType":{"isPrimitive":false,"simpleName":"SortedMap","qualifiedName":"java.util.SortedMap","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"m","type":{"isPrimitive":false,"simpleName":"SortedMap","qualifiedName":"java.util.SortedMap","dimension":"","elementType":{}}},{"name":"keyType","type":{"isPrimitive":false,"simpleName":"Class","qualifiedName":"java.lang.Class","dimension":"","elementType":{}}},{"name":"valueType","type":{"isPrimitive":false,"simpleName":"Class","qualifiedName":"java.lang.Class","dimension":"","elementType":{}}}],"typeParameters":[{"name":"K","bounds":[]},{"name":"V","bounds":[]}]},{"name":"checkedNavigableMap","comment":"Returns a dynamically typesafe view of the specified navigable map.\n Any attempt to insert a mapping whose key or value have the wrong\n type will result in an immediate {@link ClassCastException}.\n Similarly, any attempt to modify the value currently associated with\n a key will result in an immediate {@link ClassCastException},\n whether the modification is attempted directly through the map\n itself, or through a {@link Map.Entry} instance obtained from the\n map\u0027s {@link Map#entrySet() entry set} view.\n\n \u003cp\u003eAssuming a map contains no incorrectly typed keys or values\n prior to the time a dynamically typesafe view is generated, and\n that all subsequent access to the map takes place through the view\n (or one of its collection views), it is \u003cem\u003eguaranteed\u003c/em\u003e that the\n map cannot contain an incorrectly typed key or value.\n\n \u003cp\u003eA discussion of the use of dynamically typesafe views may be\n found in the documentation for the {@link #checkedCollection\n checkedCollection} method.\n\n \u003cp\u003eThe returned map will be serializable if the specified map is\n serializable.\n\n \u003cp\u003eSince {@code null} is considered to be a value of any reference\n type, the returned map permits insertion of null keys or values\n whenever the backing map does.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.util.NavigableMap\u003cK, V\u003e, java.lang.Class\u003cK\u003e, java.lang.Class\u003cV\u003e)","flatSignature":"(NavigableMap\u003cK, V\u003e, Class\u003cK\u003e, Class\u003cV\u003e)","returnType":{"isPrimitive":false,"simpleName":"NavigableMap","qualifiedName":"java.util.NavigableMap","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"m","type":{"isPrimitive":false,"simpleName":"NavigableMap","qualifiedName":"java.util.NavigableMap","dimension":"","elementType":{}}},{"name":"keyType","type":{"isPrimitive":false,"simpleName":"Class","qualifiedName":"java.lang.Class","dimension":"","elementType":{}}},{"name":"valueType","type":{"isPrimitive":false,"simpleName":"Class","qualifiedName":"java.lang.Class","dimension":"","elementType":{}}}],"typeParameters":[{"name":"K","bounds":[]},{"name":"V","bounds":[]}]},{"name":"emptyIterator","comment":"Returns an iterator that has no elements.  More precisely,\n\n \u003cul\u003e\n \u003cli\u003e{@link Iterator#hasNext hasNext} always returns {@code\n false}.\u003c/li\u003e\n \u003cli\u003e{@link Iterator#next next} always throws {@link\n NoSuchElementException}.\u003c/li\u003e\n \u003cli\u003e{@link Iterator#remove remove} always throws {@link\n IllegalStateException}.\u003c/li\u003e\n \u003c/ul\u003e\n\n \u003cp\u003eImplementations of this method are permitted, but not\n required, to return the same object from multiple invocations.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":false,"simpleName":"Iterator","qualifiedName":"java.util.Iterator","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[],"typeParameters":[{"name":"T","bounds":[]}]},{"name":"emptyListIterator","comment":"Returns a list iterator that has no elements.  More precisely,\n\n \u003cul\u003e\n \u003cli\u003e{@link Iterator#hasNext hasNext} and {@link\n ListIterator#hasPrevious hasPrevious} always return {@code\n false}.\u003c/li\u003e\n \u003cli\u003e{@link Iterator#next next} and {@link ListIterator#previous\n previous} always throw {@link NoSuchElementException}.\u003c/li\u003e\n \u003cli\u003e{@link Iterator#remove remove} and {@link ListIterator#set\n set} always throw {@link IllegalStateException}.\u003c/li\u003e\n \u003cli\u003e{@link ListIterator#add add} always throws {@link\n UnsupportedOperationException}.\u003c/li\u003e\n \u003cli\u003e{@link ListIterator#nextIndex nextIndex} always returns\n {@code 0}.\u003c/li\u003e\n \u003cli\u003e{@link ListIterator#previousIndex previousIndex} always\n returns {@code -1}.\u003c/li\u003e\n \u003c/ul\u003e\n\n \u003cp\u003eImplementations of this method are permitted, but not\n required, to return the same object from multiple invocations.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":false,"simpleName":"ListIterator","qualifiedName":"java.util.ListIterator","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[],"typeParameters":[{"name":"T","bounds":[]}]},{"name":"emptyEnumeration","comment":"Returns an enumeration that has no elements.  More precisely,\n\n \u003cul\u003e\n \u003cli\u003e{@link Enumeration#hasMoreElements hasMoreElements} always\n returns {@code false}.\u003c/li\u003e\n \u003cli\u003e {@link Enumeration#nextElement nextElement} always throws\n {@link NoSuchElementException}.\u003c/li\u003e\n \u003c/ul\u003e\n\n \u003cp\u003eImplementations of this method are permitted, but not\n required, to return the same object from multiple invocations.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":false,"simpleName":"Enumeration","qualifiedName":"java.util.Enumeration","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[],"typeParameters":[{"name":"T","bounds":[]}]},{"name":"emptySet","comment":"Returns an empty set (immutable).  This set is serializable.\n Unlike the like-named field, this method is parameterized.\n\n \u003cp\u003eThis example illustrates the type-safe way to obtain an empty set:\n \u003cpre\u003e\n     Set\u0026lt;String\u0026gt; s \u003d Collections.emptySet();\n \u003c/pre\u003e","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":false,"simpleName":"Set","qualifiedName":"java.util.Set","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[],"typeParameters":[{"name":"T","bounds":[]}]},{"name":"emptySortedSet","comment":"Returns an empty sorted set (immutable).  This set is serializable.\n\n \u003cp\u003eThis example illustrates the type-safe way to obtain an empty\n sorted set:\n \u003cpre\u003e {@code\n     SortedSet\u003cString\u003e s \u003d Collections.emptySortedSet();\n }\u003c/pre\u003e","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":false,"simpleName":"SortedSet","qualifiedName":"java.util.SortedSet","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[],"typeParameters":[{"name":"E","bounds":[]}]},{"name":"emptyNavigableSet","comment":"Returns an empty navigable set (immutable).  This set is serializable.\n\n \u003cp\u003eThis example illustrates the type-safe way to obtain an empty\n navigable set:\n \u003cpre\u003e {@code\n     NavigableSet\u003cString\u003e s \u003d Collections.emptyNavigableSet();\n }\u003c/pre\u003e","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":false,"simpleName":"NavigableSet","qualifiedName":"java.util.NavigableSet","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[],"typeParameters":[{"name":"E","bounds":[]}]},{"name":"emptyList","comment":"Returns an empty list (immutable).  This list is serializable.\n\n \u003cp\u003eThis example illustrates the type-safe way to obtain an empty list:\n \u003cpre\u003e\n     List\u0026lt;String\u0026gt; s \u003d Collections.emptyList();\n \u003c/pre\u003e","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":false,"simpleName":"List","qualifiedName":"java.util.List","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[],"typeParameters":[{"name":"T","bounds":[]}]},{"name":"emptyMap","comment":"Returns an empty map (immutable).  This map is serializable.\n\n \u003cp\u003eThis example illustrates the type-safe way to obtain an empty map:\n \u003cpre\u003e\n     Map\u0026lt;String, Date\u0026gt; s \u003d Collections.emptyMap();\n \u003c/pre\u003e","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":false,"simpleName":"Map","qualifiedName":"java.util.Map","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[],"typeParameters":[{"name":"K","bounds":[]},{"name":"V","bounds":[]}]},{"name":"emptySortedMap","comment":"Returns an empty sorted map (immutable).  This map is serializable.\n\n \u003cp\u003eThis example illustrates the type-safe way to obtain an empty map:\n \u003cpre\u003e {@code\n     SortedMap\u003cString, Date\u003e s \u003d Collections.emptySortedMap();\n }\u003c/pre\u003e","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":false,"simpleName":"SortedMap","qualifiedName":"java.util.SortedMap","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[],"typeParameters":[{"name":"K","bounds":[]},{"name":"V","bounds":[]}]},{"name":"emptyNavigableMap","comment":"Returns an empty navigable map (immutable).  This map is serializable.\n\n \u003cp\u003eThis example illustrates the type-safe way to obtain an empty map:\n \u003cpre\u003e {@code\n     NavigableMap\u003cString, Date\u003e s \u003d Collections.emptyNavigableMap();\n }\u003c/pre\u003e","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":false,"simpleName":"NavigableMap","qualifiedName":"java.util.NavigableMap","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[],"typeParameters":[{"name":"K","bounds":[]},{"name":"V","bounds":[]}]},{"name":"singleton","comment":"Returns an immutable set containing only the specified object.\n The returned set is serializable.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(T)","flatSignature":"(T)","returnType":{"isPrimitive":false,"simpleName":"Set","qualifiedName":"java.util.Set","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"o","type":{"isPrimitive":false,"simpleName":"T","qualifiedName":"T","dimension":"","elementType":{},"typeVariable":{"name":"T","bounds":[]}}}],"typeParameters":[{"name":"T","bounds":[]}]},{"name":"singletonList","comment":"Returns an immutable list containing only the specified object.\n The returned list is serializable.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(T)","flatSignature":"(T)","returnType":{"isPrimitive":false,"simpleName":"List","qualifiedName":"java.util.List","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"o","type":{"isPrimitive":false,"simpleName":"T","qualifiedName":"T","dimension":"","elementType":{},"typeVariable":{"name":"T","bounds":[]}}}],"typeParameters":[{"name":"T","bounds":[]}]},{"name":"singletonMap","comment":"Returns an immutable map, mapping only the specified key to the\n specified value.  The returned map is serializable.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(K, V)","flatSignature":"(K, V)","returnType":{"isPrimitive":false,"simpleName":"Map","qualifiedName":"java.util.Map","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"key","type":{"isPrimitive":false,"simpleName":"K","qualifiedName":"K","dimension":"","elementType":{},"typeVariable":{"name":"K","bounds":[]}}},{"name":"value","type":{"isPrimitive":false,"simpleName":"V","qualifiedName":"V","dimension":"","elementType":{},"typeVariable":{"name":"V","bounds":[]}}}],"typeParameters":[{"name":"K","bounds":[]},{"name":"V","bounds":[]}]},{"name":"nCopies","comment":"Returns an immutable list consisting of \u003ctt\u003en\u003c/tt\u003e copies of the\n specified object.  The newly allocated data object is tiny (it contains\n a single reference to the data object).  This method is useful in\n combination with the \u003ctt\u003eList.addAll\u003c/tt\u003e method to grow lists.\n The returned list is serializable.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(int, T)","flatSignature":"(int, T)","returnType":{"isPrimitive":false,"simpleName":"List","qualifiedName":"java.util.List","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"n","type":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}}},{"name":"o","type":{"isPrimitive":false,"simpleName":"T","qualifiedName":"T","dimension":"","elementType":{},"typeVariable":{"name":"T","bounds":[]}}}],"typeParameters":[{"name":"T","bounds":[]}]},{"name":"reverseOrder","comment":"Returns a comparator that imposes the reverse of the \u003cem\u003enatural\n ordering\u003c/em\u003e on a collection of objects that implement the\n {@code Comparable} interface.  (The natural ordering is the ordering\n imposed by the objects\u0027 own {@code compareTo} method.)  This enables a\n simple idiom for sorting (or maintaining) collections (or arrays) of\n objects that implement the {@code Comparable} interface in\n reverse-natural-order.  For example, suppose {@code a} is an array of\n strings. Then: \u003cpre\u003e\n          Arrays.sort(a, Collections.reverseOrder());\n \u003c/pre\u003e sorts the array in reverse-lexicographic (alphabetical) order.\u003cp\u003e\n\n The returned comparator is serializable.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":false,"simpleName":"Comparator","qualifiedName":"java.util.Comparator","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[],"typeParameters":[{"name":"T","bounds":[]}]},{"name":"reverseOrder","comment":"Returns a comparator that imposes the reverse ordering of the specified\n comparator.  If the specified comparator is {@code null}, this method is\n equivalent to {@link #reverseOrder()} (in other words, it returns a\n comparator that imposes the reverse of the \u003cem\u003enatural ordering\u003c/em\u003e on\n a collection of objects that implement the Comparable interface).\n\n \u003cp\u003eThe returned comparator is serializable (assuming the specified\n comparator is also serializable or {@code null}).","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.util.Comparator\u003cT\u003e)","flatSignature":"(Comparator\u003cT\u003e)","returnType":{"isPrimitive":false,"simpleName":"Comparator","qualifiedName":"java.util.Comparator","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"cmp","type":{"isPrimitive":false,"simpleName":"Comparator","qualifiedName":"java.util.Comparator","dimension":"","elementType":{}}}],"typeParameters":[{"name":"T","bounds":[]}]},{"name":"enumeration","comment":"Returns an enumeration over the specified collection.  This provides\n interoperability with legacy APIs that require an enumeration\n as input.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.util.Collection\u003cT\u003e)","flatSignature":"(Collection\u003cT\u003e)","returnType":{"isPrimitive":false,"simpleName":"Enumeration","qualifiedName":"java.util.Enumeration","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"c","type":{"isPrimitive":false,"simpleName":"Collection","qualifiedName":"java.util.Collection","dimension":"","elementType":{}}}],"typeParameters":[{"name":"T","bounds":[]}]},{"name":"list","comment":"Returns an array list containing the elements returned by the\n specified enumeration in the order they are returned by the\n enumeration.  This method provides interoperability between\n legacy APIs that return enumerations and new APIs that require\n collections.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.util.Enumeration\u003cT\u003e)","flatSignature":"(Enumeration\u003cT\u003e)","returnType":{"isPrimitive":false,"simpleName":"ArrayList","qualifiedName":"java.util.ArrayList","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"e","type":{"isPrimitive":false,"simpleName":"Enumeration","qualifiedName":"java.util.Enumeration","dimension":"","elementType":{}}}],"typeParameters":[{"name":"T","bounds":[]}]},{"name":"frequency","comment":"Returns the number of elements in the specified collection equal to the\n specified object.  More formally, returns the number of elements\n \u003ctt\u003ee\u003c/tt\u003e in the collection such that\n \u003ctt\u003e(o \u003d\u003d null ? e \u003d\u003d null : o.equals(e))\u003c/tt\u003e.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.util.Collection\u003c?\u003e, java.lang.Object)","flatSignature":"(Collection\u003c?\u003e, Object)","returnType":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"c","type":{"isPrimitive":false,"simpleName":"Collection","qualifiedName":"java.util.Collection","dimension":"","elementType":{}}},{"name":"o","type":{"isPrimitive":false,"simpleName":"Object","qualifiedName":"java.lang.Object","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"disjoint","comment":"Returns {@code true} if the two specified collections have no\n elements in common.\n\n \u003cp\u003eCare must be exercised if this method is used on collections that\n do not comply with the general contract for {@code Collection}.\n Implementations may elect to iterate over either collection and test\n for containment in the other collection (or to perform any equivalent\n computation).  If either collection uses a nonstandard equality test\n (as does a {@link SortedSet} whose ordering is not \u003cem\u003ecompatible with\n equals\u003c/em\u003e, or the key set of an {@link IdentityHashMap}), both\n collections must use the same nonstandard equality test, or the\n result of this method is undefined.\n\n \u003cp\u003eCare must also be exercised when using collections that have\n restrictions on the elements that they may contain. Collection\n implementations are allowed to throw exceptions for any operation\n involving elements they deem ineligible. For absolute safety the\n specified collections should contain only elements which are\n eligible elements for both collections.\n\n \u003cp\u003eNote that it is permissible to pass the same collection in both\n parameters, in which case the method will return {@code true} if and\n only if the collection is empty.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.util.Collection\u003c?\u003e, java.util.Collection\u003c?\u003e)","flatSignature":"(Collection\u003c?\u003e, Collection\u003c?\u003e)","returnType":{"isPrimitive":true,"simpleName":"boolean","qualifiedName":"boolean","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"c1","type":{"isPrimitive":false,"simpleName":"Collection","qualifiedName":"java.util.Collection","dimension":"","elementType":{}}},{"name":"c2","type":{"isPrimitive":false,"simpleName":"Collection","qualifiedName":"java.util.Collection","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"addAll","comment":"Adds all of the specified elements to the specified collection.\n Elements to be added may be specified individually or as an array.\n The behavior of this convenience method is identical to that of\n \u003ctt\u003ec.addAll(Arrays.asList(elements))\u003c/tt\u003e, but this method is likely\n to run significantly faster under most implementations.\n\n \u003cp\u003eWhen elements are specified individually, this method provides a\n convenient way to add a few elements to an existing collection:\n \u003cpre\u003e\n     Collections.addAll(flavors, \"Peaches \u0027n Plutonium\", \"Rocky Racoon\");\n \u003c/pre\u003e","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.util.Collection\u003c? super T\u003e, T...)","flatSignature":"(Collection\u003c? super T\u003e, T...)","returnType":{"isPrimitive":true,"simpleName":"boolean","qualifiedName":"boolean","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"c","type":{"isPrimitive":false,"simpleName":"Collection","qualifiedName":"java.util.Collection","dimension":"","elementType":{}}},{"name":"elements","type":{"isPrimitive":false,"simpleName":"T","qualifiedName":"T","dimension":"[]","elementType":{"isPrimitive":false,"simpleName":"T","qualifiedName":"T","dimension":"","elementType":{},"typeVariable":{"name":"T","bounds":[]}},"typeVariable":{"name":"T","bounds":[]}}}],"typeParameters":[{"name":"T","bounds":[]}]},{"name":"newSetFromMap","comment":"Returns a set backed by the specified map.  The resulting set displays\n the same ordering, concurrency, and performance characteristics as the\n backing map.  In essence, this factory method provides a {@link Set}\n implementation corresponding to any {@link Map} implementation.  There\n is no need to use this method on a {@link Map} implementation that\n already has a corresponding {@link Set} implementation (such as {@link\n HashMap} or {@link TreeMap}).\n\n \u003cp\u003eEach method invocation on the set returned by this method results in\n exactly one method invocation on the backing map or its \u003ctt\u003ekeySet\u003c/tt\u003e\n view, with one exception.  The \u003ctt\u003eaddAll\u003c/tt\u003e method is implemented\n as a sequence of \u003ctt\u003eput\u003c/tt\u003e invocations on the backing map.\n\n \u003cp\u003eThe specified map must be empty at the time this method is invoked,\n and should not be accessed directly after this method returns.  These\n conditions are ensured if the map is created empty, passed directly\n to this method, and no reference to the map is retained, as illustrated\n in the following code fragment:\n \u003cpre\u003e\n    Set\u0026lt;Object\u0026gt; weakHashSet \u003d Collections.newSetFromMap(\n        new WeakHashMap\u0026lt;Object, Boolean\u0026gt;());\n \u003c/pre\u003e","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.util.Map\u003cE, java.lang.Boolean\u003e)","flatSignature":"(Map\u003cE, Boolean\u003e)","returnType":{"isPrimitive":false,"simpleName":"Set","qualifiedName":"java.util.Set","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"map","type":{"isPrimitive":false,"simpleName":"Map","qualifiedName":"java.util.Map","dimension":"","elementType":{}}}],"typeParameters":[{"name":"E","bounds":[]}]},{"name":"asLifoQueue","comment":"Returns a view of a {@link Deque} as a Last-in-first-out (Lifo)\n {@link Queue}. Method \u003ctt\u003eadd\u003c/tt\u003e is mapped to \u003ctt\u003epush\u003c/tt\u003e,\n \u003ctt\u003eremove\u003c/tt\u003e is mapped to \u003ctt\u003epop\u003c/tt\u003e and so on. This\n view can be useful when you would like to use a method\n requiring a \u003ctt\u003eQueue\u003c/tt\u003e but you need Lifo ordering.\n\n \u003cp\u003eEach method invocation on the queue returned by this method\n results in exactly one method invocation on the backing deque, with\n one exception.  The {@link Queue#addAll addAll} method is\n implemented as a sequence of {@link Deque#addFirst addFirst}\n invocations on the backing deque.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.util.Deque\u003cT\u003e)","flatSignature":"(Deque\u003cT\u003e)","returnType":{"isPrimitive":false,"simpleName":"Queue","qualifiedName":"java.util.Queue","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"deque","type":{"isPrimitive":false,"simpleName":"Deque","qualifiedName":"java.util.Deque","dimension":"","elementType":{}}}],"typeParameters":[{"name":"T","bounds":[]}]}],"typeParameters":[],"enumConstants":[]}