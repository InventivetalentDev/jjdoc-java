{"name":"Spliterator","comment":"An object for traversing and partitioning elements of a source.  The source\n of elements covered by a Spliterator could be, for example, an array, a\n {@link Collection}, an IO channel, or a generator function.\n\n \u003cp\u003eA Spliterator may traverse elements individually ({@link\n #tryAdvance tryAdvance()}) or sequentially in bulk\n ({@link #forEachRemaining forEachRemaining()}).\n\n \u003cp\u003eA Spliterator may also partition off some of its elements (using\n {@link #trySplit}) as another Spliterator, to be used in\n possibly-parallel operations.  Operations using a Spliterator that\n cannot split, or does so in a highly imbalanced or inefficient\n manner, are unlikely to benefit from parallelism.  Traversal\n and splitting exhaust elements; each Spliterator is useful for only a single\n bulk computation.\n\n \u003cp\u003eA Spliterator also reports a set of {@link #characteristics()} of its\n structure, source, and elements from among {@link #ORDERED},\n {@link #DISTINCT}, {@link #SORTED}, {@link #SIZED}, {@link #NONNULL},\n {@link #IMMUTABLE}, {@link #CONCURRENT}, and {@link #SUBSIZED}. These may\n be employed by Spliterator clients to control, specialize or simplify\n computation.  For example, a Spliterator for a {@link Collection} would\n report {@code SIZED}, a Spliterator for a {@link Set} would report\n {@code DISTINCT}, and a Spliterator for a {@link SortedSet} would also\n report {@code SORTED}.  Characteristics are reported as a simple unioned bit\n set.\n\n Some characteristics additionally constrain method behavior; for example if\n {@code ORDERED}, traversal methods must conform to their documented ordering.\n New characteristics may be defined in the future, so implementors should not\n assign meanings to unlisted values.\n\n \u003cp\u003e\u003ca name\u003d\"binding\"\u003eA Spliterator that does not report {@code IMMUTABLE} or\n {@code CONCURRENT} is expected to have a documented policy concerning:\n when the spliterator \u003cem\u003ebinds\u003c/em\u003e to the element source; and detection of\n structural interference of the element source detected after binding.\u003c/a\u003e  A\n \u003cem\u003elate-binding\u003c/em\u003e Spliterator binds to the source of elements at the\n point of first traversal, first split, or first query for estimated size,\n rather than at the time the Spliterator is created.  A Spliterator that is\n not \u003cem\u003elate-binding\u003c/em\u003e binds to the source of elements at the point of\n construction or first invocation of any method.  Modifications made to the\n source prior to binding are reflected when the Spliterator is traversed.\n After binding a Spliterator should, on a best-effort basis, throw\n {@link ConcurrentModificationException} if structural interference is\n detected.  Spliterators that do this are called \u003cem\u003efail-fast\u003c/em\u003e.  The\n bulk traversal method ({@link #forEachRemaining forEachRemaining()}) of a\n Spliterator may optimize traversal and check for structural interference\n after all elements have been traversed, rather than checking per-element and\n failing immediately.\n\n \u003cp\u003eSpliterators can provide an estimate of the number of remaining elements\n via the {@link #estimateSize} method.  Ideally, as reflected in characteristic\n {@link #SIZED}, this value corresponds exactly to the number of elements\n that would be encountered in a successful traversal.  However, even when not\n exactly known, an estimated value value may still be useful to operations\n being performed on the source, such as helping to determine whether it is\n preferable to split further or traverse the remaining elements sequentially.\n\n \u003cp\u003eDespite their obvious utility in parallel algorithms, spliterators are not\n expected to be thread-safe; instead, implementations of parallel algorithms\n using spliterators should ensure that the spliterator is only used by one\n thread at a time.  This is generally easy to attain via \u003cem\u003eserial\n thread-confinement\u003c/em\u003e, which often is a natural consequence of typical\n parallel algorithms that work by recursive decomposition.  A thread calling\n {@link #trySplit()} may hand over the returned Spliterator to another thread,\n which in turn may traverse or further split that Spliterator.  The behaviour\n of splitting and traversal is undefined if two or more threads operate\n concurrently on the same spliterator.  If the original thread hands a\n spliterator off to another thread for processing, it is best if that handoff\n occurs before any elements are consumed with {@link #tryAdvance(Consumer)\n tryAdvance()}, as certain guarantees (such as the accuracy of\n {@link #estimateSize()} for {@code SIZED} spliterators) are only valid before\n traversal has begun.\n\n \u003cp\u003ePrimitive subtype specializations of {@code Spliterator} are provided for\n {@link OfInt int}, {@link OfLong long}, and {@link OfDouble double} values.\n The subtype default implementations of\n {@link Spliterator#tryAdvance(java.util.function.Consumer)}\n and {@link Spliterator#forEachRemaining(java.util.function.Consumer)} box\n primitive values to instances of their corresponding wrapper class.  Such\n boxing may undermine any performance advantages gained by using the primitive\n specializations.  To avoid boxing, the corresponding primitive-based methods\n should be used.  For example,\n {@link Spliterator.OfInt#tryAdvance(java.util.function.IntConsumer)}\n and {@link Spliterator.OfInt#forEachRemaining(java.util.function.IntConsumer)}\n should be used in preference to\n {@link Spliterator.OfInt#tryAdvance(java.util.function.Consumer)} and\n {@link Spliterator.OfInt#forEachRemaining(java.util.function.Consumer)}.\n Traversal of primitive values using boxing-based methods\n {@link #tryAdvance tryAdvance()} and\n {@link #forEachRemaining(java.util.function.Consumer) forEachRemaining()}\n does not affect the order in which the values, transformed to boxed values,\n are encountered.","isClass":false,"isInterface":true,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":false,"isOrdinaryClass":false,"isPrimitive":false,"simpleName":"Spliterator","qualifiedName":"java.util.Spliterator","dimension":"","elementType":{},"package":"java.util","interfaces":[],"isAbstract":true,"isStatic":false,"since":"1.8","innerClasses":["java.util.Spliterator.OfPrimitive","java.util.Spliterator.OfInt","java.util.Spliterator.OfLong","java.util.Spliterator.OfDouble"],"isInnerClass":false,"constructors":[],"fields":[{"name":"ORDERED","comment":"Characteristic value signifying that an encounter order is defined for\n elements. If so, this Spliterator guarantees that method\n {@link #trySplit} splits a strict prefix of elements, that method\n {@link #tryAdvance} steps by one element in prefix order, and that\n {@link #forEachRemaining} performs actions in encounter order.\n\n \u003cp\u003eA {@link Collection} has an encounter order if the corresponding\n {@link Collection#iterator} documents an order. If so, the encounter\n order is the same as the documented order. Otherwise, a collection does\n not have an encounter order.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":true,"isMethod":false,"isOrdinaryClass":false,"type":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}},"isStatic":true,"constantValue":"16"},{"name":"DISTINCT","comment":"Characteristic value signifying that, for each pair of\n encountered elements {@code x, y}, {@code !x.equals(y)}. This\n applies for example, to a Spliterator based on a {@link Set}.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":true,"isMethod":false,"isOrdinaryClass":false,"type":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}},"isStatic":true,"constantValue":"1"},{"name":"SORTED","comment":"Characteristic value signifying that encounter order follows a defined\n sort order. If so, method {@link #getComparator()} returns the associated\n Comparator, or {@code null} if all elements are {@link Comparable} and\n are sorted by their natural ordering.\n\n \u003cp\u003eA Spliterator that reports {@code SORTED} must also report\n {@code ORDERED}.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":true,"isMethod":false,"isOrdinaryClass":false,"type":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}},"isStatic":true,"constantValue":"4"},{"name":"SIZED","comment":"Characteristic value signifying that the value returned from\n {@code estimateSize()} prior to traversal or splitting represents a\n finite size that, in the absence of structural source modification,\n represents an exact count of the number of elements that would be\n encountered by a complete traversal.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":true,"isMethod":false,"isOrdinaryClass":false,"type":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}},"isStatic":true,"constantValue":"64"},{"name":"NONNULL","comment":"Characteristic value signifying that the source guarantees that\n encountered elements will not be {@code null}. (This applies,\n for example, to most concurrent collections, queues, and maps.)","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":true,"isMethod":false,"isOrdinaryClass":false,"type":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}},"isStatic":true,"constantValue":"256"},{"name":"IMMUTABLE","comment":"Characteristic value signifying that the element source cannot be\n structurally modified; that is, elements cannot be added, replaced, or\n removed, so such changes cannot occur during traversal. A Spliterator\n that does not report {@code IMMUTABLE} or {@code CONCURRENT} is expected\n to have a documented policy (for example throwing\n {@link ConcurrentModificationException}) concerning structural\n interference detected during traversal.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":true,"isMethod":false,"isOrdinaryClass":false,"type":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}},"isStatic":true,"constantValue":"1024"},{"name":"CONCURRENT","comment":"Characteristic value signifying that the element source may be safely\n concurrently modified (allowing additions, replacements, and/or removals)\n by multiple threads without external synchronization. If so, the\n Spliterator is expected to have a documented policy concerning the impact\n of modifications during traversal.\n\n \u003cp\u003eA top-level Spliterator should not report both {@code CONCURRENT} and\n {@code SIZED}, since the finite size, if known, may change if the source\n is concurrently modified during traversal. Such a Spliterator is\n inconsistent and no guarantees can be made about any computation using\n that Spliterator. Sub-spliterators may report {@code SIZED} if the\n sub-split size is known and additions or removals to the source are not\n reflected when traversing.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":true,"isMethod":false,"isOrdinaryClass":false,"type":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}},"isStatic":true,"constantValue":"4096"},{"name":"SUBSIZED","comment":"Characteristic value signifying that all Spliterators resulting from\n {@code trySplit()} will be both {@link #SIZED} and {@link #SUBSIZED}.\n (This means that all child Spliterators, whether direct or indirect, will\n be {@code SIZED}.)\n\n \u003cp\u003eA Spliterator that does not report {@code SIZED} as required by\n {@code SUBSIZED} is inconsistent and no guarantees can be made about any\n computation using that Spliterator.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":true,"isMethod":false,"isOrdinaryClass":false,"type":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}},"isStatic":true,"constantValue":"16384"}],"methods":[{"name":"tryAdvance","comment":"If a remaining element exists, performs the given action on it,\n returning {@code true}; else returns {@code false}.  If this\n Spliterator is {@link #ORDERED} the action is performed on the\n next element in encounter order.  Exceptions thrown by the\n action are relayed to the caller.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.util.function.Consumer\u003c? super T\u003e)","flatSignature":"(Consumer\u003c? super T\u003e)","returnType":{"isPrimitive":true,"simpleName":"boolean","qualifiedName":"boolean","dimension":"","elementType":{}},"isAbstract":true,"isDefault":false,"isStatic":false,"parameters":[{"name":"action","type":{"isPrimitive":false,"simpleName":"Consumer","qualifiedName":"java.util.function.Consumer","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"forEachRemaining","comment":"Performs the given action for each remaining element, sequentially in\n the current thread, until all elements have been processed or the action\n throws an exception.  If this Spliterator is {@link #ORDERED}, actions\n are performed in encounter order.  Exceptions thrown by the action\n are relayed to the caller.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.util.function.Consumer\u003c? super T\u003e)","flatSignature":"(Consumer\u003c? super T\u003e)","returnType":{"isPrimitive":true,"simpleName":"void","qualifiedName":"void","dimension":"","elementType":{}},"isAbstract":false,"isDefault":true,"isStatic":false,"parameters":[{"name":"action","type":{"isPrimitive":false,"simpleName":"Consumer","qualifiedName":"java.util.function.Consumer","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"trySplit","comment":"If this spliterator can be partitioned, returns a Spliterator\n covering elements, that will, upon return from this method, not\n be covered by this Spliterator.\n\n \u003cp\u003eIf this Spliterator is {@link #ORDERED}, the returned Spliterator\n must cover a strict prefix of the elements.\n\n \u003cp\u003eUnless this Spliterator covers an infinite number of elements,\n repeated calls to {@code trySplit()} must eventually return {@code null}.\n Upon non-null return:\n \u003cul\u003e\n \u003cli\u003ethe value reported for {@code estimateSize()} before splitting,\n must, after splitting, be greater than or equal to {@code estimateSize()}\n for this and the returned Spliterator; and\u003c/li\u003e\n \u003cli\u003eif this Spliterator is {@code SUBSIZED}, then {@code estimateSize()}\n for this spliterator before splitting must be equal to the sum of\n {@code estimateSize()} for this and the returned Spliterator after\n splitting.\u003c/li\u003e\n \u003c/ul\u003e\n\n \u003cp\u003eThis method may return {@code null} for any reason,\n including emptiness, inability to split after traversal has\n commenced, data structure constraints, and efficiency\n considerations.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":false,"simpleName":"Spliterator","qualifiedName":"java.util.Spliterator","dimension":"","elementType":{}},"isAbstract":true,"isDefault":false,"isStatic":false,"parameters":[],"typeParameters":[]},{"name":"estimateSize","comment":"Returns an estimate of the number of elements that would be\n encountered by a {@link #forEachRemaining} traversal, or returns {@link\n Long#MAX_VALUE} if infinite, unknown, or too expensive to compute.\n\n \u003cp\u003eIf this Spliterator is {@link #SIZED} and has not yet been partially\n traversed or split, or this Spliterator is {@link #SUBSIZED} and has\n not yet been partially traversed, this estimate must be an accurate\n count of elements that would be encountered by a complete traversal.\n Otherwise, this estimate may be arbitrarily inaccurate, but must decrease\n as specified across invocations of {@link #trySplit}.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":true,"simpleName":"long","qualifiedName":"long","dimension":"","elementType":{}},"isAbstract":true,"isDefault":false,"isStatic":false,"parameters":[],"typeParameters":[]},{"name":"getExactSizeIfKnown","comment":"Convenience method that returns {@link #estimateSize()} if this\n Spliterator is {@link #SIZED}, else {@code -1}.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":true,"simpleName":"long","qualifiedName":"long","dimension":"","elementType":{}},"isAbstract":false,"isDefault":true,"isStatic":false,"parameters":[],"typeParameters":[]},{"name":"characteristics","comment":"Returns a set of characteristics of this Spliterator and its\n elements. The result is represented as ORed values from {@link\n #ORDERED}, {@link #DISTINCT}, {@link #SORTED}, {@link #SIZED},\n {@link #NONNULL}, {@link #IMMUTABLE}, {@link #CONCURRENT},\n {@link #SUBSIZED}.  Repeated calls to {@code characteristics()} on\n a given spliterator, prior to or in-between calls to {@code trySplit},\n should always return the same result.\n\n \u003cp\u003eIf a Spliterator reports an inconsistent set of\n characteristics (either those returned from a single invocation\n or across multiple invocations), no guarantees can be made\n about any computation using this Spliterator.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}},"isAbstract":true,"isDefault":false,"isStatic":false,"parameters":[],"typeParameters":[]},{"name":"hasCharacteristics","comment":"Returns {@code true} if this Spliterator\u0027s {@link\n #characteristics} contain all of the given characteristics.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(int)","flatSignature":"(int)","returnType":{"isPrimitive":true,"simpleName":"boolean","qualifiedName":"boolean","dimension":"","elementType":{}},"isAbstract":false,"isDefault":true,"isStatic":false,"parameters":[{"name":"characteristics","type":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"getComparator","comment":"If this Spliterator\u0027s source is {@link #SORTED} by a {@link Comparator},\n returns that {@code Comparator}. If the source is {@code SORTED} in\n {@linkplain Comparable natural order}, returns {@code null}.  Otherwise,\n if the source is not {@code SORTED}, throws {@link IllegalStateException}.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":false,"simpleName":"Comparator","qualifiedName":"java.util.Comparator","dimension":"","elementType":{}},"isAbstract":false,"isDefault":true,"isStatic":false,"parameters":[],"typeParameters":[]}],"typeParameters":[{"name":"T","bounds":[]}],"subInterfaces":["java.util.Spliterators.AbstractSpliterator","java.util.Spliterator.OfPrimitive"],"enumConstants":[]}