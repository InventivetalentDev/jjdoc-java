{"name":"Map","comment":"An object that maps keys to values.  A map cannot contain duplicate keys;\n each key can map to at most one value.\n\n \u003cp\u003eThis interface takes the place of the \u003ctt\u003eDictionary\u003c/tt\u003e class, which\n was a totally abstract class rather than an interface.\n\n \u003cp\u003eThe \u003ctt\u003eMap\u003c/tt\u003e interface provides three \u003ci\u003ecollection views\u003c/i\u003e, which\n allow a map\u0027s contents to be viewed as a set of keys, collection of values,\n or set of key-value mappings.  The \u003ci\u003eorder\u003c/i\u003e of a map is defined as\n the order in which the iterators on the map\u0027s collection views return their\n elements.  Some map implementations, like the \u003ctt\u003eTreeMap\u003c/tt\u003e class, make\n specific guarantees as to their order; others, like the \u003ctt\u003eHashMap\u003c/tt\u003e\n class, do not.\n\n \u003cp\u003eNote: great care must be exercised if mutable objects are used as map\n keys.  The behavior of a map is not specified if the value of an object is\n changed in a manner that affects \u003ctt\u003eequals\u003c/tt\u003e comparisons while the\n object is a key in the map.  A special case of this prohibition is that it\n is not permissible for a map to contain itself as a key.  While it is\n permissible for a map to contain itself as a value, extreme caution is\n advised: the \u003ctt\u003eequals\u003c/tt\u003e and \u003ctt\u003ehashCode\u003c/tt\u003e methods are no longer\n well defined on such a map.\n\n \u003cp\u003eAll general-purpose map implementation classes should provide two\n \"standard\" constructors: a void (no arguments) constructor which creates an\n empty map, and a constructor with a single argument of type \u003ctt\u003eMap\u003c/tt\u003e,\n which creates a new map with the same key-value mappings as its argument.\n In effect, the latter constructor allows the user to copy any map,\n producing an equivalent map of the desired class.  There is no way to\n enforce this recommendation (as interfaces cannot contain constructors) but\n all of the general-purpose map implementations in the JDK comply.\n\n \u003cp\u003eThe \"destructive\" methods contained in this interface, that is, the\n methods that modify the map on which they operate, are specified to throw\n \u003ctt\u003eUnsupportedOperationException\u003c/tt\u003e if this map does not support the\n operation.  If this is the case, these methods may, but are not required\n to, throw an \u003ctt\u003eUnsupportedOperationException\u003c/tt\u003e if the invocation would\n have no effect on the map.  For example, invoking the {@link #putAll(Map)}\n method on an unmodifiable map may, but is not required to, throw the\n exception if the map whose mappings are to be \"superimposed\" is empty.\n\n \u003cp\u003eSome map implementations have restrictions on the keys and values they\n may contain.  For example, some implementations prohibit null keys and\n values, and some have restrictions on the types of their keys.  Attempting\n to insert an ineligible key or value throws an unchecked exception,\n typically \u003ctt\u003eNullPointerException\u003c/tt\u003e or \u003ctt\u003eClassCastException\u003c/tt\u003e.\n Attempting to query the presence of an ineligible key or value may throw an\n exception, or it may simply return false; some implementations will exhibit\n the former behavior and some will exhibit the latter.  More generally,\n attempting an operation on an ineligible key or value whose completion\n would not result in the insertion of an ineligible element into the map may\n throw an exception or it may succeed, at the option of the implementation.\n Such exceptions are marked as \"optional\" in the specification for this\n interface.\n\n \u003cp\u003eMany methods in Collections Framework interfaces are defined\n in terms of the {@link Object#equals(Object) equals} method.  For\n example, the specification for the {@link #containsKey(Object)\n containsKey(Object key)} method says: \"returns \u003ctt\u003etrue\u003c/tt\u003e if and\n only if this map contains a mapping for a key \u003ctt\u003ek\u003c/tt\u003e such that\n \u003ctt\u003e(key\u003d\u003dnull ? k\u003d\u003dnull : key.equals(k))\u003c/tt\u003e.\" This specification should\n \u003ci\u003enot\u003c/i\u003e be construed to imply that invoking \u003ctt\u003eMap.containsKey\u003c/tt\u003e\n with a non-null argument \u003ctt\u003ekey\u003c/tt\u003e will cause \u003ctt\u003ekey.equals(k)\u003c/tt\u003e to\n be invoked for any key \u003ctt\u003ek\u003c/tt\u003e.  Implementations are free to\n implement optimizations whereby the \u003ctt\u003eequals\u003c/tt\u003e invocation is avoided,\n for example, by first comparing the hash codes of the two keys.  (The\n {@link Object#hashCode()} specification guarantees that two objects with\n unequal hash codes cannot be equal.)  More generally, implementations of\n the various Collections Framework interfaces are free to take advantage of\n the specified behavior of underlying {@link Object} methods wherever the\n implementor deems it appropriate.\n\n \u003cp\u003eSome map operations which perform recursive traversal of the map may fail\n with an exception for self-referential instances where the map directly or\n indirectly contains itself. This includes the {@code clone()},\n {@code equals()}, {@code hashCode()} and {@code toString()} methods.\n Implementations may optionally handle the self-referential scenario, however\n most current implementations do not do so.\n\n \u003cp\u003eThis interface is a member of the\n \u003ca href\u003d\"{@docRoot}/../technotes/guides/collections/index.html\"\u003e\n Java Collections Framework\u003c/a\u003e.","isClass":false,"isInterface":true,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":false,"isOrdinaryClass":false,"isPrimitive":false,"simpleName":"Map","qualifiedName":"java.util.Map","dimension":"","elementType":{},"package":"java.util","interfaces":[],"isAbstract":true,"isStatic":false,"since":"1.2","innerClasses":["java.util.Map.Entry"],"isInnerClass":false,"constructors":[],"fields":[],"methods":[{"name":"size","comment":"Returns the number of key-value mappings in this map.  If the\n map contains more than \u003ctt\u003eInteger.MAX_VALUE\u003c/tt\u003e elements, returns\n \u003ctt\u003eInteger.MAX_VALUE\u003c/tt\u003e.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}},"isAbstract":true,"isDefault":false,"isStatic":false,"parameters":[],"typeParameters":[]},{"name":"isEmpty","comment":"Returns \u003ctt\u003etrue\u003c/tt\u003e if this map contains no key-value mappings.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":true,"simpleName":"boolean","qualifiedName":"boolean","dimension":"","elementType":{}},"isAbstract":true,"isDefault":false,"isStatic":false,"parameters":[],"typeParameters":[]},{"name":"containsKey","comment":"Returns \u003ctt\u003etrue\u003c/tt\u003e if this map contains a mapping for the specified\n key.  More formally, returns \u003ctt\u003etrue\u003c/tt\u003e if and only if\n this map contains a mapping for a key \u003ctt\u003ek\u003c/tt\u003e such that\n \u003ctt\u003e(key\u003d\u003dnull ? k\u003d\u003dnull : key.equals(k))\u003c/tt\u003e.  (There can be\n at most one such mapping.)","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.lang.Object)","flatSignature":"(Object)","returnType":{"isPrimitive":true,"simpleName":"boolean","qualifiedName":"boolean","dimension":"","elementType":{}},"isAbstract":true,"isDefault":false,"isStatic":false,"parameters":[{"name":"key","type":{"isPrimitive":false,"simpleName":"Object","qualifiedName":"java.lang.Object","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"containsValue","comment":"Returns \u003ctt\u003etrue\u003c/tt\u003e if this map maps one or more keys to the\n specified value.  More formally, returns \u003ctt\u003etrue\u003c/tt\u003e if and only if\n this map contains at least one mapping to a value \u003ctt\u003ev\u003c/tt\u003e such that\n \u003ctt\u003e(value\u003d\u003dnull ? v\u003d\u003dnull : value.equals(v))\u003c/tt\u003e.  This operation\n will probably require time linear in the map size for most\n implementations of the \u003ctt\u003eMap\u003c/tt\u003e interface.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.lang.Object)","flatSignature":"(Object)","returnType":{"isPrimitive":true,"simpleName":"boolean","qualifiedName":"boolean","dimension":"","elementType":{}},"isAbstract":true,"isDefault":false,"isStatic":false,"parameters":[{"name":"value","type":{"isPrimitive":false,"simpleName":"Object","qualifiedName":"java.lang.Object","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"get","comment":"Returns the value to which the specified key is mapped,\n or {@code null} if this map contains no mapping for the key.\n\n \u003cp\u003eMore formally, if this map contains a mapping from a key\n {@code k} to a value {@code v} such that {@code (key\u003d\u003dnull ? k\u003d\u003dnull :\n key.equals(k))}, then this method returns {@code v}; otherwise\n it returns {@code null}.  (There can be at most one such mapping.)\n\n \u003cp\u003eIf this map permits null values, then a return value of\n {@code null} does not \u003ci\u003enecessarily\u003c/i\u003e indicate that the map\n contains no mapping for the key; it\u0027s also possible that the map\n explicitly maps the key to {@code null}.  The {@link #containsKey\n containsKey} operation may be used to distinguish these two cases.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.lang.Object)","flatSignature":"(Object)","returnType":{"isPrimitive":false,"simpleName":"V","qualifiedName":"V","dimension":"","elementType":{},"typeVariable":{"name":"V","bounds":[]}},"isAbstract":true,"isDefault":false,"isStatic":false,"parameters":[{"name":"key","type":{"isPrimitive":false,"simpleName":"Object","qualifiedName":"java.lang.Object","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"put","comment":"Associates the specified value with the specified key in this map\n (optional operation).  If the map previously contained a mapping for\n the key, the old value is replaced by the specified value.  (A map\n \u003ctt\u003em\u003c/tt\u003e is said to contain a mapping for a key \u003ctt\u003ek\u003c/tt\u003e if and only\n if {@link #containsKey(Object) m.containsKey(k)} would return\n \u003ctt\u003etrue\u003c/tt\u003e.)","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(K, V)","flatSignature":"(K, V)","returnType":{"isPrimitive":false,"simpleName":"V","qualifiedName":"V","dimension":"","elementType":{},"typeVariable":{"name":"V","bounds":[]}},"isAbstract":true,"isDefault":false,"isStatic":false,"parameters":[{"name":"key","type":{"isPrimitive":false,"simpleName":"K","qualifiedName":"K","dimension":"","elementType":{},"typeVariable":{"name":"K","bounds":[]}}},{"name":"value","type":{"isPrimitive":false,"simpleName":"V","qualifiedName":"V","dimension":"","elementType":{},"typeVariable":{"name":"V","bounds":[]}}}],"typeParameters":[]},{"name":"remove","comment":"Removes the mapping for a key from this map if it is present\n (optional operation).   More formally, if this map contains a mapping\n from key \u003ctt\u003ek\u003c/tt\u003e to value \u003ctt\u003ev\u003c/tt\u003e such that\n \u003ccode\u003e(key\u003d\u003dnull ?  k\u003d\u003dnull : key.equals(k))\u003c/code\u003e, that mapping\n is removed.  (The map can contain at most one such mapping.)\n\n \u003cp\u003eReturns the value to which this map previously associated the key,\n or \u003ctt\u003enull\u003c/tt\u003e if the map contained no mapping for the key.\n\n \u003cp\u003eIf this map permits null values, then a return value of\n \u003ctt\u003enull\u003c/tt\u003e does not \u003ci\u003enecessarily\u003c/i\u003e indicate that the map\n contained no mapping for the key; it\u0027s also possible that the map\n explicitly mapped the key to \u003ctt\u003enull\u003c/tt\u003e.\n\n \u003cp\u003eThe map will not contain a mapping for the specified key once the\n call returns.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.lang.Object)","flatSignature":"(Object)","returnType":{"isPrimitive":false,"simpleName":"V","qualifiedName":"V","dimension":"","elementType":{},"typeVariable":{"name":"V","bounds":[]}},"isAbstract":true,"isDefault":false,"isStatic":false,"parameters":[{"name":"key","type":{"isPrimitive":false,"simpleName":"Object","qualifiedName":"java.lang.Object","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"putAll","comment":"Copies all of the mappings from the specified map to this map\n (optional operation).  The effect of this call is equivalent to that\n of calling {@link #put(Object,Object) put(k, v)} on this map once\n for each mapping from key \u003ctt\u003ek\u003c/tt\u003e to value \u003ctt\u003ev\u003c/tt\u003e in the\n specified map.  The behavior of this operation is undefined if the\n specified map is modified while the operation is in progress.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.util.Map\u003c? extends K, ? extends V\u003e)","flatSignature":"(Map\u003c? extends K, ? extends V\u003e)","returnType":{"isPrimitive":true,"simpleName":"void","qualifiedName":"void","dimension":"","elementType":{}},"isAbstract":true,"isDefault":false,"isStatic":false,"parameters":[{"name":"m","type":{"isPrimitive":false,"simpleName":"Map","qualifiedName":"java.util.Map","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"clear","comment":"Removes all of the mappings from this map (optional operation).\n The map will be empty after this call returns.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":true,"simpleName":"void","qualifiedName":"void","dimension":"","elementType":{}},"isAbstract":true,"isDefault":false,"isStatic":false,"parameters":[],"typeParameters":[]},{"name":"keySet","comment":"Returns a {@link Set} view of the keys contained in this map.\n The set is backed by the map, so changes to the map are\n reflected in the set, and vice-versa.  If the map is modified\n while an iteration over the set is in progress (except through\n the iterator\u0027s own \u003ctt\u003eremove\u003c/tt\u003e operation), the results of\n the iteration are undefined.  The set supports element removal,\n which removes the corresponding mapping from the map, via the\n \u003ctt\u003eIterator.remove\u003c/tt\u003e, \u003ctt\u003eSet.remove\u003c/tt\u003e,\n \u003ctt\u003eremoveAll\u003c/tt\u003e, \u003ctt\u003eretainAll\u003c/tt\u003e, and \u003ctt\u003eclear\u003c/tt\u003e\n operations.  It does not support the \u003ctt\u003eadd\u003c/tt\u003e or \u003ctt\u003eaddAll\u003c/tt\u003e\n operations.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":false,"simpleName":"Set","qualifiedName":"java.util.Set","dimension":"","elementType":{}},"isAbstract":true,"isDefault":false,"isStatic":false,"parameters":[],"typeParameters":[]},{"name":"values","comment":"Returns a {@link Collection} view of the values contained in this map.\n The collection is backed by the map, so changes to the map are\n reflected in the collection, and vice-versa.  If the map is\n modified while an iteration over the collection is in progress\n (except through the iterator\u0027s own \u003ctt\u003eremove\u003c/tt\u003e operation),\n the results of the iteration are undefined.  The collection\n supports element removal, which removes the corresponding\n mapping from the map, via the \u003ctt\u003eIterator.remove\u003c/tt\u003e,\n \u003ctt\u003eCollection.remove\u003c/tt\u003e, \u003ctt\u003eremoveAll\u003c/tt\u003e,\n \u003ctt\u003eretainAll\u003c/tt\u003e and \u003ctt\u003eclear\u003c/tt\u003e operations.  It does not\n support the \u003ctt\u003eadd\u003c/tt\u003e or \u003ctt\u003eaddAll\u003c/tt\u003e operations.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":false,"simpleName":"Collection","qualifiedName":"java.util.Collection","dimension":"","elementType":{}},"isAbstract":true,"isDefault":false,"isStatic":false,"parameters":[],"typeParameters":[]},{"name":"entrySet","comment":"Returns a {@link Set} view of the mappings contained in this map.\n The set is backed by the map, so changes to the map are\n reflected in the set, and vice-versa.  If the map is modified\n while an iteration over the set is in progress (except through\n the iterator\u0027s own \u003ctt\u003eremove\u003c/tt\u003e operation, or through the\n \u003ctt\u003esetValue\u003c/tt\u003e operation on a map entry returned by the\n iterator) the results of the iteration are undefined.  The set\n supports element removal, which removes the corresponding\n mapping from the map, via the \u003ctt\u003eIterator.remove\u003c/tt\u003e,\n \u003ctt\u003eSet.remove\u003c/tt\u003e, \u003ctt\u003eremoveAll\u003c/tt\u003e, \u003ctt\u003eretainAll\u003c/tt\u003e and\n \u003ctt\u003eclear\u003c/tt\u003e operations.  It does not support the\n \u003ctt\u003eadd\u003c/tt\u003e or \u003ctt\u003eaddAll\u003c/tt\u003e operations.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":false,"simpleName":"Set","qualifiedName":"java.util.Set","dimension":"","elementType":{}},"isAbstract":true,"isDefault":false,"isStatic":false,"parameters":[],"typeParameters":[]},{"name":"equals","comment":"Compares the specified object with this map for equality.  Returns\n \u003ctt\u003etrue\u003c/tt\u003e if the given object is also a map and the two maps\n represent the same mappings.  More formally, two maps \u003ctt\u003em1\u003c/tt\u003e and\n \u003ctt\u003em2\u003c/tt\u003e represent the same mappings if\n \u003ctt\u003em1.entrySet().equals(m2.entrySet())\u003c/tt\u003e.  This ensures that the\n \u003ctt\u003eequals\u003c/tt\u003e method works properly across different implementations\n of the \u003ctt\u003eMap\u003c/tt\u003e interface.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.lang.Object)","flatSignature":"(Object)","returnType":{"isPrimitive":true,"simpleName":"boolean","qualifiedName":"boolean","dimension":"","elementType":{}},"isAbstract":true,"isDefault":false,"isStatic":false,"parameters":[{"name":"o","type":{"isPrimitive":false,"simpleName":"Object","qualifiedName":"java.lang.Object","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"hashCode","comment":"Returns the hash code value for this map.  The hash code of a map is\n defined to be the sum of the hash codes of each entry in the map\u0027s\n \u003ctt\u003eentrySet()\u003c/tt\u003e view.  This ensures that \u003ctt\u003em1.equals(m2)\u003c/tt\u003e\n implies that \u003ctt\u003em1.hashCode()\u003d\u003dm2.hashCode()\u003c/tt\u003e for any two maps\n \u003ctt\u003em1\u003c/tt\u003e and \u003ctt\u003em2\u003c/tt\u003e, as required by the general contract of\n {@link Object#hashCode}.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}},"isAbstract":true,"isDefault":false,"isStatic":false,"parameters":[],"typeParameters":[]},{"name":"getOrDefault","comment":"Returns the value to which the specified key is mapped, or\n {@code defaultValue} if this map contains no mapping for the key.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.lang.Object, V)","flatSignature":"(Object, V)","returnType":{"isPrimitive":false,"simpleName":"V","qualifiedName":"V","dimension":"","elementType":{},"typeVariable":{"name":"V","bounds":[]}},"isAbstract":false,"isDefault":true,"isStatic":false,"parameters":[{"name":"key","type":{"isPrimitive":false,"simpleName":"Object","qualifiedName":"java.lang.Object","dimension":"","elementType":{}}},{"name":"defaultValue","type":{"isPrimitive":false,"simpleName":"V","qualifiedName":"V","dimension":"","elementType":{},"typeVariable":{"name":"V","bounds":[]}}}],"typeParameters":[]},{"name":"forEach","comment":"Performs the given action for each entry in this map until all entries\n have been processed or the action throws an exception.   Unless\n otherwise specified by the implementing class, actions are performed in\n the order of entry set iteration (if an iteration order is specified.)\n Exceptions thrown by the action are relayed to the caller.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.util.function.BiConsumer\u003c? super K, ? super V\u003e)","flatSignature":"(BiConsumer\u003c? super K, ? super V\u003e)","returnType":{"isPrimitive":true,"simpleName":"void","qualifiedName":"void","dimension":"","elementType":{}},"isAbstract":false,"isDefault":true,"isStatic":false,"parameters":[{"name":"action","type":{"isPrimitive":false,"simpleName":"BiConsumer","qualifiedName":"java.util.function.BiConsumer","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"replaceAll","comment":"Replaces each entry\u0027s value with the result of invoking the given\n function on that entry until all entries have been processed or the\n function throws an exception.  Exceptions thrown by the function are\n relayed to the caller.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.util.function.BiFunction\u003c? super K, ? super V, ? extends V\u003e)","flatSignature":"(BiFunction\u003c? super K, ? super V, ? extends V\u003e)","returnType":{"isPrimitive":true,"simpleName":"void","qualifiedName":"void","dimension":"","elementType":{}},"isAbstract":false,"isDefault":true,"isStatic":false,"parameters":[{"name":"function","type":{"isPrimitive":false,"simpleName":"BiFunction","qualifiedName":"java.util.function.BiFunction","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"putIfAbsent","comment":"If the specified key is not already associated with a value (or is mapped\n to {@code null}) associates it with the given value and returns\n {@code null}, else returns the current value.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(K, V)","flatSignature":"(K, V)","returnType":{"isPrimitive":false,"simpleName":"V","qualifiedName":"V","dimension":"","elementType":{},"typeVariable":{"name":"V","bounds":[]}},"isAbstract":false,"isDefault":true,"isStatic":false,"parameters":[{"name":"key","type":{"isPrimitive":false,"simpleName":"K","qualifiedName":"K","dimension":"","elementType":{},"typeVariable":{"name":"K","bounds":[]}}},{"name":"value","type":{"isPrimitive":false,"simpleName":"V","qualifiedName":"V","dimension":"","elementType":{},"typeVariable":{"name":"V","bounds":[]}}}],"typeParameters":[]},{"name":"remove","comment":"Removes the entry for the specified key only if it is currently\n mapped to the specified value.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.lang.Object, java.lang.Object)","flatSignature":"(Object, Object)","returnType":{"isPrimitive":true,"simpleName":"boolean","qualifiedName":"boolean","dimension":"","elementType":{}},"isAbstract":false,"isDefault":true,"isStatic":false,"parameters":[{"name":"key","type":{"isPrimitive":false,"simpleName":"Object","qualifiedName":"java.lang.Object","dimension":"","elementType":{}}},{"name":"value","type":{"isPrimitive":false,"simpleName":"Object","qualifiedName":"java.lang.Object","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"replace","comment":"Replaces the entry for the specified key only if currently\n mapped to the specified value.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(K, V, V)","flatSignature":"(K, V, V)","returnType":{"isPrimitive":true,"simpleName":"boolean","qualifiedName":"boolean","dimension":"","elementType":{}},"isAbstract":false,"isDefault":true,"isStatic":false,"parameters":[{"name":"key","type":{"isPrimitive":false,"simpleName":"K","qualifiedName":"K","dimension":"","elementType":{},"typeVariable":{"name":"K","bounds":[]}}},{"name":"oldValue","type":{"isPrimitive":false,"simpleName":"V","qualifiedName":"V","dimension":"","elementType":{},"typeVariable":{"name":"V","bounds":[]}}},{"name":"newValue","type":{"isPrimitive":false,"simpleName":"V","qualifiedName":"V","dimension":"","elementType":{},"typeVariable":{"name":"V","bounds":[]}}}],"typeParameters":[]},{"name":"replace","comment":"Replaces the entry for the specified key only if it is\n currently mapped to some value.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(K, V)","flatSignature":"(K, V)","returnType":{"isPrimitive":false,"simpleName":"V","qualifiedName":"V","dimension":"","elementType":{},"typeVariable":{"name":"V","bounds":[]}},"isAbstract":false,"isDefault":true,"isStatic":false,"parameters":[{"name":"key","type":{"isPrimitive":false,"simpleName":"K","qualifiedName":"K","dimension":"","elementType":{},"typeVariable":{"name":"K","bounds":[]}}},{"name":"value","type":{"isPrimitive":false,"simpleName":"V","qualifiedName":"V","dimension":"","elementType":{},"typeVariable":{"name":"V","bounds":[]}}}],"typeParameters":[]},{"name":"computeIfAbsent","comment":"If the specified key is not already associated with a value (or is mapped\n to {@code null}), attempts to compute its value using the given mapping\n function and enters it into this map unless {@code null}.\n\n \u003cp\u003eIf the function returns {@code null} no mapping is recorded. If\n the function itself throws an (unchecked) exception, the\n exception is rethrown, and no mapping is recorded.  The most\n common usage is to construct a new object serving as an initial\n mapped value or memoized result, as in:\n\n \u003cpre\u003e {@code\n map.computeIfAbsent(key, k -\u003e new Value(f(k)));\n }\u003c/pre\u003e\n\n \u003cp\u003eOr to implement a multi-value map, {@code Map\u003cK,Collection\u003cV\u003e\u003e},\n supporting multiple values per key:\n\n \u003cpre\u003e {@code\n map.computeIfAbsent(key, k -\u003e new HashSet\u003cV\u003e()).add(v);\n }\u003c/pre\u003e","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(K, java.util.function.Function\u003c? super K, ? extends V\u003e)","flatSignature":"(K, Function\u003c? super K, ? extends V\u003e)","returnType":{"isPrimitive":false,"simpleName":"V","qualifiedName":"V","dimension":"","elementType":{},"typeVariable":{"name":"V","bounds":[]}},"isAbstract":false,"isDefault":true,"isStatic":false,"parameters":[{"name":"key","type":{"isPrimitive":false,"simpleName":"K","qualifiedName":"K","dimension":"","elementType":{},"typeVariable":{"name":"K","bounds":[]}}},{"name":"mappingFunction","type":{"isPrimitive":false,"simpleName":"Function","qualifiedName":"java.util.function.Function","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"computeIfPresent","comment":"If the value for the specified key is present and non-null, attempts to\n compute a new mapping given the key and its current mapped value.\n\n \u003cp\u003eIf the function returns {@code null}, the mapping is removed.  If the\n function itself throws an (unchecked) exception, the exception is\n rethrown, and the current mapping is left unchanged.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(K, java.util.function.BiFunction\u003c? super K, ? super V, ? extends V\u003e)","flatSignature":"(K, BiFunction\u003c? super K, ? super V, ? extends V\u003e)","returnType":{"isPrimitive":false,"simpleName":"V","qualifiedName":"V","dimension":"","elementType":{},"typeVariable":{"name":"V","bounds":[]}},"isAbstract":false,"isDefault":true,"isStatic":false,"parameters":[{"name":"key","type":{"isPrimitive":false,"simpleName":"K","qualifiedName":"K","dimension":"","elementType":{},"typeVariable":{"name":"K","bounds":[]}}},{"name":"remappingFunction","type":{"isPrimitive":false,"simpleName":"BiFunction","qualifiedName":"java.util.function.BiFunction","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"compute","comment":"Attempts to compute a mapping for the specified key and its current\n mapped value (or {@code null} if there is no current mapping). For\n example, to either create or append a {@code String} msg to a value\n mapping:\n\n \u003cpre\u003e {@code\n map.compute(key, (k, v) -\u003e (v \u003d\u003d null) ? msg : v.concat(msg))}\u003c/pre\u003e\n (Method {@link #merge merge()} is often simpler to use for such purposes.)\n\n \u003cp\u003eIf the function returns {@code null}, the mapping is removed (or\n remains absent if initially absent).  If the function itself throws an\n (unchecked) exception, the exception is rethrown, and the current mapping\n is left unchanged.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(K, java.util.function.BiFunction\u003c? super K, ? super V, ? extends V\u003e)","flatSignature":"(K, BiFunction\u003c? super K, ? super V, ? extends V\u003e)","returnType":{"isPrimitive":false,"simpleName":"V","qualifiedName":"V","dimension":"","elementType":{},"typeVariable":{"name":"V","bounds":[]}},"isAbstract":false,"isDefault":true,"isStatic":false,"parameters":[{"name":"key","type":{"isPrimitive":false,"simpleName":"K","qualifiedName":"K","dimension":"","elementType":{},"typeVariable":{"name":"K","bounds":[]}}},{"name":"remappingFunction","type":{"isPrimitive":false,"simpleName":"BiFunction","qualifiedName":"java.util.function.BiFunction","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"merge","comment":"If the specified key is not already associated with a value or is\n associated with null, associates it with the given non-null value.\n Otherwise, replaces the associated value with the results of the given\n remapping function, or removes if the result is {@code null}. This\n method may be of use when combining multiple mapped values for a key.\n For example, to either create or append a {@code String msg} to a\n value mapping:\n\n \u003cpre\u003e {@code\n map.merge(key, msg, String::concat)\n }\u003c/pre\u003e\n\n \u003cp\u003eIf the function returns {@code null} the mapping is removed.  If the\n function itself throws an (unchecked) exception, the exception is\n rethrown, and the current mapping is left unchanged.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(K, V, java.util.function.BiFunction\u003c? super V, ? super V, ? extends V\u003e)","flatSignature":"(K, V, BiFunction\u003c? super V, ? super V, ? extends V\u003e)","returnType":{"isPrimitive":false,"simpleName":"V","qualifiedName":"V","dimension":"","elementType":{},"typeVariable":{"name":"V","bounds":[]}},"isAbstract":false,"isDefault":true,"isStatic":false,"parameters":[{"name":"key","type":{"isPrimitive":false,"simpleName":"K","qualifiedName":"K","dimension":"","elementType":{},"typeVariable":{"name":"K","bounds":[]}}},{"name":"value","type":{"isPrimitive":false,"simpleName":"V","qualifiedName":"V","dimension":"","elementType":{},"typeVariable":{"name":"V","bounds":[]}}},{"name":"remappingFunction","type":{"isPrimitive":false,"simpleName":"BiFunction","qualifiedName":"java.util.function.BiFunction","dimension":"","elementType":{}}}],"typeParameters":[]}],"typeParameters":[{"name":"K","bounds":[]},{"name":"V","bounds":[]}],"subInterfaces":["java.util.WeakHashMap","java.util.SortedMap","java.util.LinkedHashMap","java.util.IdentityHashMap","java.util.Hashtable","java.util.HashMap","java.util.AbstractMap","java.util.concurrent.ConcurrentMap","java.util.jar.Attributes"],"enumConstants":[]}