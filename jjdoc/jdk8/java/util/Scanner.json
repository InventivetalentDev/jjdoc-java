{"name":"Scanner","comment":"A simple text scanner which can parse primitive types and strings using\n regular expressions.\n\n \u003cp\u003eA \u003ccode\u003eScanner\u003c/code\u003e breaks its input into tokens using a\n delimiter pattern, which by default matches whitespace. The resulting\n tokens may then be converted into values of different types using the\n various \u003ctt\u003enext\u003c/tt\u003e methods.\n\n \u003cp\u003eFor example, this code allows a user to read a number from\n \u003ctt\u003eSystem.in\u003c/tt\u003e:\n \u003cblockquote\u003e\u003cpre\u003e{@code\n     Scanner sc \u003d new Scanner(System.in);\n     int i \u003d sc.nextInt();\n }\u003c/pre\u003e\u003c/blockquote\u003e\n\n \u003cp\u003eAs another example, this code allows \u003ccode\u003elong\u003c/code\u003e types to be\n assigned from entries in a file \u003ccode\u003emyNumbers\u003c/code\u003e:\n \u003cblockquote\u003e\u003cpre\u003e{@code\n      Scanner sc \u003d new Scanner(new File(\"myNumbers\"));\n      while (sc.hasNextLong()) {\n          long aLong \u003d sc.nextLong();\n      }\n }\u003c/pre\u003e\u003c/blockquote\u003e\n\n \u003cp\u003eThe scanner can also use delimiters other than whitespace. This\n example reads several items in from a string:\n \u003cblockquote\u003e\u003cpre\u003e{@code\n     String input \u003d \"1 fish 2 fish red fish blue fish\";\n     Scanner s \u003d new Scanner(input).useDelimiter(\"\\\\s*fish\\\\s*\");\n     System.out.println(s.nextInt());\n     System.out.println(s.nextInt());\n     System.out.println(s.next());\n     System.out.println(s.next());\n     s.close();\n }\u003c/pre\u003e\u003c/blockquote\u003e\n \u003cp\u003e\n prints the following output:\n \u003cblockquote\u003e\u003cpre\u003e{@code\n     1\n     2\n     red\n     blue\n }\u003c/pre\u003e\u003c/blockquote\u003e\n\n \u003cp\u003eThe same output can be generated with this code, which uses a regular\n expression to parse all four tokens at once:\n \u003cblockquote\u003e\u003cpre\u003e{@code\n     String input \u003d \"1 fish 2 fish red fish blue fish\";\n     Scanner s \u003d new Scanner(input);\n     s.findInLine(\"(\\\\d+) fish (\\\\d+) fish (\\\\w+) fish (\\\\w+)\");\n     MatchResult result \u003d s.match();\n     for (int i\u003d1; i\u003c\u003dresult.groupCount(); i++)\n         System.out.println(result.group(i));\n     s.close();\n }\u003c/pre\u003e\u003c/blockquote\u003e\n\n \u003cp\u003eThe \u003ca name\u003d\"default-delimiter\"\u003edefault whitespace delimiter\u003c/a\u003e used\n by a scanner is as recognized by {@link java.lang.Character}.{@link\n java.lang.Character#isWhitespace(char) isWhitespace}. The {@link #reset}\n method will reset the value of the scanner\u0027s delimiter to the default\n whitespace delimiter regardless of whether it was previously changed.\n\n \u003cp\u003eA scanning operation may block waiting for input.\n\n \u003cp\u003eThe {@link #next} and {@link #hasNext} methods and their\n primitive-type companion methods (such as {@link #nextInt} and\n {@link #hasNextInt}) first skip any input that matches the delimiter\n pattern, and then attempt to return the next token. Both \u003ctt\u003ehasNext\u003c/tt\u003e\n and \u003ctt\u003enext\u003c/tt\u003e methods may block waiting for further input.  Whether a\n \u003ctt\u003ehasNext\u003c/tt\u003e method blocks has no connection to whether or not its\n associated \u003ctt\u003enext\u003c/tt\u003e method will block.\n\n \u003cp\u003e The {@link #findInLine}, {@link #findWithinHorizon}, and {@link #skip}\n methods operate independently of the delimiter pattern. These methods will\n attempt to match the specified pattern with no regard to delimiters in the\n input and thus can be used in special circumstances where delimiters are\n not relevant. These methods may block waiting for more input.\n\n \u003cp\u003eWhen a scanner throws an {@link InputMismatchException}, the scanner\n will not pass the token that caused the exception, so that it may be\n retrieved or skipped via some other method.\n\n \u003cp\u003eDepending upon the type of delimiting pattern, empty tokens may be\n returned. For example, the pattern \u003ctt\u003e\"\\\\s+\"\u003c/tt\u003e will return no empty\n tokens since it matches multiple instances of the delimiter. The delimiting\n pattern \u003ctt\u003e\"\\\\s\"\u003c/tt\u003e could return empty tokens since it only passes one\n space at a time.\n\n \u003cp\u003e A scanner can read text from any object which implements the {@link\n java.lang.Readable} interface.  If an invocation of the underlying\n readable\u0027s {@link java.lang.Readable#read} method throws an {@link\n java.io.IOException} then the scanner assumes that the end of the input\n has been reached.  The most recent \u003ctt\u003eIOException\u003c/tt\u003e thrown by the\n underlying readable can be retrieved via the {@link #ioException} method.\n\n \u003cp\u003eWhen a \u003ccode\u003eScanner\u003c/code\u003e is closed, it will close its input source\n if the source implements the {@link java.io.Closeable} interface.\n\n \u003cp\u003eA \u003ccode\u003eScanner\u003c/code\u003e is not safe for multithreaded use without\n external synchronization.\n\n \u003cp\u003eUnless otherwise mentioned, passing a \u003ccode\u003enull\u003c/code\u003e parameter into\n any method of a \u003ccode\u003eScanner\u003c/code\u003e will cause a\n \u003ccode\u003eNullPointerException\u003c/code\u003e to be thrown.\n\n \u003cp\u003eA scanner will default to interpreting numbers as decimal unless a\n different radix has been set by using the {@link #useRadix} method. The\n {@link #reset} method will reset the value of the scanner\u0027s radix to\n \u003ccode\u003e10\u003c/code\u003e regardless of whether it was previously changed.\n\n \u003ch3\u003e \u003ca name\u003d\"localized-numbers\"\u003eLocalized numbers\u003c/a\u003e \u003c/h3\u003e\n\n \u003cp\u003e An instance of this class is capable of scanning numbers in the standard\n formats as well as in the formats of the scanner\u0027s locale. A scanner\u0027s\n \u003ca name\u003d\"initial-locale\"\u003einitial locale \u003c/a\u003eis the value returned by the {@link\n java.util.Locale#getDefault(Locale.Category)\n Locale.getDefault(Locale.Category.FORMAT)} method; it may be changed via the {@link\n #useLocale} method. The {@link #reset} method will reset the value of the\n scanner\u0027s locale to the initial locale regardless of whether it was\n previously changed.\n\n \u003cp\u003eThe localized formats are defined in terms of the following parameters,\n which for a particular locale are taken from that locale\u0027s {@link\n java.text.DecimalFormat DecimalFormat} object, \u003ctt\u003edf\u003c/tt\u003e, and its and\n {@link java.text.DecimalFormatSymbols DecimalFormatSymbols} object,\n \u003ctt\u003edfs\u003c/tt\u003e.\n\n \u003cblockquote\u003e\u003cdl\u003e\n     \u003cdt\u003e\u003ci\u003eLocalGroupSeparator\u0026nbsp;\u0026nbsp;\u003c/i\u003e\n         \u003cdd\u003eThe character used to separate thousands groups,\n         \u003ci\u003ei.e.,\u003c/i\u003e\u0026nbsp;\u003ctt\u003edfs.\u003c/tt\u003e{@link\n         java.text.DecimalFormatSymbols#getGroupingSeparator\n         getGroupingSeparator()}\n     \u003cdt\u003e\u003ci\u003eLocalDecimalSeparator\u0026nbsp;\u0026nbsp;\u003c/i\u003e\n         \u003cdd\u003eThe character used for the decimal point,\n     \u003ci\u003ei.e.,\u003c/i\u003e\u0026nbsp;\u003ctt\u003edfs.\u003c/tt\u003e{@link\n     java.text.DecimalFormatSymbols#getDecimalSeparator\n     getDecimalSeparator()}\n     \u003cdt\u003e\u003ci\u003eLocalPositivePrefix\u0026nbsp;\u0026nbsp;\u003c/i\u003e\n         \u003cdd\u003eThe string that appears before a positive number (may\n         be empty), \u003ci\u003ei.e.,\u003c/i\u003e\u0026nbsp;\u003ctt\u003edf.\u003c/tt\u003e{@link\n         java.text.DecimalFormat#getPositivePrefix\n         getPositivePrefix()}\n     \u003cdt\u003e\u003ci\u003eLocalPositiveSuffix\u0026nbsp;\u0026nbsp;\u003c/i\u003e\n         \u003cdd\u003eThe string that appears after a positive number (may be\n         empty), \u003ci\u003ei.e.,\u003c/i\u003e\u0026nbsp;\u003ctt\u003edf.\u003c/tt\u003e{@link\n         java.text.DecimalFormat#getPositiveSuffix\n         getPositiveSuffix()}\n     \u003cdt\u003e\u003ci\u003eLocalNegativePrefix\u0026nbsp;\u0026nbsp;\u003c/i\u003e\n         \u003cdd\u003eThe string that appears before a negative number (may\n         be empty), \u003ci\u003ei.e.,\u003c/i\u003e\u0026nbsp;\u003ctt\u003edf.\u003c/tt\u003e{@link\n         java.text.DecimalFormat#getNegativePrefix\n         getNegativePrefix()}\n     \u003cdt\u003e\u003ci\u003eLocalNegativeSuffix\u0026nbsp;\u0026nbsp;\u003c/i\u003e\n         \u003cdd\u003eThe string that appears after a negative number (may be\n         empty), \u003ci\u003ei.e.,\u003c/i\u003e\u0026nbsp;\u003ctt\u003edf.\u003c/tt\u003e{@link\n     java.text.DecimalFormat#getNegativeSuffix\n     getNegativeSuffix()}\n     \u003cdt\u003e\u003ci\u003eLocalNaN\u0026nbsp;\u0026nbsp;\u003c/i\u003e\n         \u003cdd\u003eThe string that represents not-a-number for\n         floating-point values,\n         \u003ci\u003ei.e.,\u003c/i\u003e\u0026nbsp;\u003ctt\u003edfs.\u003c/tt\u003e{@link\n         java.text.DecimalFormatSymbols#getNaN\n         getNaN()}\n     \u003cdt\u003e\u003ci\u003eLocalInfinity\u0026nbsp;\u0026nbsp;\u003c/i\u003e\n         \u003cdd\u003eThe string that represents infinity for floating-point\n         values, \u003ci\u003ei.e.,\u003c/i\u003e\u0026nbsp;\u003ctt\u003edfs.\u003c/tt\u003e{@link\n         java.text.DecimalFormatSymbols#getInfinity\n         getInfinity()}\n \u003c/dl\u003e\u003c/blockquote\u003e\n\n \u003ch4\u003e \u003ca name\u003d\"number-syntax\"\u003eNumber syntax\u003c/a\u003e \u003c/h4\u003e\n\n \u003cp\u003e The strings that can be parsed as numbers by an instance of this class\n are specified in terms of the following regular-expression grammar, where\n Rmax is the highest digit in the radix being used (for example, Rmax is 9 in base 10).\n\n \u003cdl\u003e\n   \u003cdt\u003e\u003ci\u003eNonAsciiDigit\u003c/i\u003e:\n       \u003cdd\u003eA non-ASCII character c for which\n            {@link java.lang.Character#isDigit Character.isDigit}\u003ctt\u003e(c)\u003c/tt\u003e\n                        returns\u0026nbsp;true\n\n   \u003cdt\u003e\u003ci\u003eNon0Digit\u003c/i\u003e:\n       \u003cdd\u003e\u003ctt\u003e[1-\u003c/tt\u003e\u003ci\u003eRmax\u003c/i\u003e\u003ctt\u003e] | \u003c/tt\u003e\u003ci\u003eNonASCIIDigit\u003c/i\u003e\n\n   \u003cdt\u003e\u003ci\u003eDigit\u003c/i\u003e:\n       \u003cdd\u003e\u003ctt\u003e[0-\u003c/tt\u003e\u003ci\u003eRmax\u003c/i\u003e\u003ctt\u003e] | \u003c/tt\u003e\u003ci\u003eNonASCIIDigit\u003c/i\u003e\n\n   \u003cdt\u003e\u003ci\u003eGroupedNumeral\u003c/i\u003e:\n       \u003cdd\u003e\u003ctt\u003e(\u0026nbsp;\u003c/tt\u003e\u003ci\u003eNon0Digit\u003c/i\u003e\n                   \u003ci\u003eDigit\u003c/i\u003e\u003ctt\u003e?\n                   \u003c/tt\u003e\u003ci\u003eDigit\u003c/i\u003e\u003ctt\u003e?\u003c/tt\u003e\n       \u003cdd\u003e\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u003ctt\u003e(\u0026nbsp;\u003c/tt\u003e\u003ci\u003eLocalGroupSeparator\u003c/i\u003e\n                         \u003ci\u003eDigit\u003c/i\u003e\n                         \u003ci\u003eDigit\u003c/i\u003e\n                         \u003ci\u003eDigit\u003c/i\u003e\u003ctt\u003e )+ )\u003c/tt\u003e\n\n   \u003cdt\u003e\u003ci\u003eNumeral\u003c/i\u003e:\n       \u003cdd\u003e\u003ctt\u003e( ( \u003c/tt\u003e\u003ci\u003eDigit\u003c/i\u003e\u003ctt\u003e+ )\n               | \u003c/tt\u003e\u003ci\u003eGroupedNumeral\u003c/i\u003e\u003ctt\u003e )\u003c/tt\u003e\n\n   \u003cdt\u003e\u003ca name\u003d\"Integer-regex\"\u003e\u003ci\u003eInteger\u003c/i\u003e:\u003c/a\u003e\n       \u003cdd\u003e\u003ctt\u003e( [-+]? ( \u003c/tt\u003e\u003ci\u003eNumeral\u003c/i\u003e\u003ctt\u003e\n                               ) )\u003c/tt\u003e\n       \u003cdd\u003e\u003ctt\u003e| \u003c/tt\u003e\u003ci\u003eLocalPositivePrefix\u003c/i\u003e \u003ci\u003eNumeral\u003c/i\u003e\n                      \u003ci\u003eLocalPositiveSuffix\u003c/i\u003e\n       \u003cdd\u003e\u003ctt\u003e| \u003c/tt\u003e\u003ci\u003eLocalNegativePrefix\u003c/i\u003e \u003ci\u003eNumeral\u003c/i\u003e\n                 \u003ci\u003eLocalNegativeSuffix\u003c/i\u003e\n\n   \u003cdt\u003e\u003ci\u003eDecimalNumeral\u003c/i\u003e:\n       \u003cdd\u003e\u003ci\u003eNumeral\u003c/i\u003e\n       \u003cdd\u003e\u003ctt\u003e| \u003c/tt\u003e\u003ci\u003eNumeral\u003c/i\u003e\n                 \u003ci\u003eLocalDecimalSeparator\u003c/i\u003e\n                 \u003ci\u003eDigit\u003c/i\u003e\u003ctt\u003e*\u003c/tt\u003e\n       \u003cdd\u003e\u003ctt\u003e| \u003c/tt\u003e\u003ci\u003eLocalDecimalSeparator\u003c/i\u003e\n                 \u003ci\u003eDigit\u003c/i\u003e\u003ctt\u003e+\u003c/tt\u003e\n\n   \u003cdt\u003e\u003ci\u003eExponent\u003c/i\u003e:\n       \u003cdd\u003e\u003ctt\u003e( [eE] [+-]? \u003c/tt\u003e\u003ci\u003eDigit\u003c/i\u003e\u003ctt\u003e+ )\u003c/tt\u003e\n\n   \u003cdt\u003e\u003ca name\u003d\"Decimal-regex\"\u003e\u003ci\u003eDecimal\u003c/i\u003e:\u003c/a\u003e\n       \u003cdd\u003e\u003ctt\u003e( [-+]? \u003c/tt\u003e\u003ci\u003eDecimalNumeral\u003c/i\u003e\n                         \u003ci\u003eExponent\u003c/i\u003e\u003ctt\u003e? )\u003c/tt\u003e\n       \u003cdd\u003e\u003ctt\u003e| \u003c/tt\u003e\u003ci\u003eLocalPositivePrefix\u003c/i\u003e\n                 \u003ci\u003eDecimalNumeral\u003c/i\u003e\n                 \u003ci\u003eLocalPositiveSuffix\u003c/i\u003e\n                 \u003ci\u003eExponent\u003c/i\u003e\u003ctt\u003e?\u003c/tt\u003e\n       \u003cdd\u003e\u003ctt\u003e| \u003c/tt\u003e\u003ci\u003eLocalNegativePrefix\u003c/i\u003e\n                 \u003ci\u003eDecimalNumeral\u003c/i\u003e\n                 \u003ci\u003eLocalNegativeSuffix\u003c/i\u003e\n                 \u003ci\u003eExponent\u003c/i\u003e\u003ctt\u003e?\u003c/tt\u003e\n\n   \u003cdt\u003e\u003ci\u003eHexFloat\u003c/i\u003e:\n       \u003cdd\u003e\u003ctt\u003e[-+]? 0[xX][0-9a-fA-F]*\\.[0-9a-fA-F]+\n                 ([pP][-+]?[0-9]+)?\u003c/tt\u003e\n\n   \u003cdt\u003e\u003ci\u003eNonNumber\u003c/i\u003e:\n       \u003cdd\u003e\u003ctt\u003eNaN\n                          | \u003c/tt\u003e\u003ci\u003eLocalNan\u003c/i\u003e\u003ctt\u003e\n                          | Infinity\n                          | \u003c/tt\u003e\u003ci\u003eLocalInfinity\u003c/i\u003e\n\n   \u003cdt\u003e\u003ci\u003eSignedNonNumber\u003c/i\u003e:\n       \u003cdd\u003e\u003ctt\u003e( [-+]? \u003c/tt\u003e\u003ci\u003eNonNumber\u003c/i\u003e\u003ctt\u003e )\u003c/tt\u003e\n       \u003cdd\u003e\u003ctt\u003e| \u003c/tt\u003e\u003ci\u003eLocalPositivePrefix\u003c/i\u003e\n                 \u003ci\u003eNonNumber\u003c/i\u003e\n                 \u003ci\u003eLocalPositiveSuffix\u003c/i\u003e\n       \u003cdd\u003e\u003ctt\u003e| \u003c/tt\u003e\u003ci\u003eLocalNegativePrefix\u003c/i\u003e\n                 \u003ci\u003eNonNumber\u003c/i\u003e\n                 \u003ci\u003eLocalNegativeSuffix\u003c/i\u003e\n\n   \u003cdt\u003e\u003ca name\u003d\"Float-regex\"\u003e\u003ci\u003eFloat\u003c/i\u003e\u003c/a\u003e:\n       \u003cdd\u003e\u003ci\u003eDecimal\u003c/i\u003e\n           \u003ctt\u003e| \u003c/tt\u003e\u003ci\u003eHexFloat\u003c/i\u003e\n           \u003ctt\u003e| \u003c/tt\u003e\u003ci\u003eSignedNonNumber\u003c/i\u003e\n\n \u003c/dl\u003e\n \u003cp\u003eWhitespace is not significant in the above regular expressions.","isClass":true,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":false,"isOrdinaryClass":true,"isPrimitive":false,"simpleName":"Scanner","qualifiedName":"java.util.Scanner","dimension":"","elementType":{},"package":"java.util","superclass":"java.lang.Object","interfaces":["java.util.Iterator","java.io.Closeable"],"isAbstract":false,"isStatic":false,"since":"1.5","innerClasses":[],"isInnerClass":false,"constructors":[{"name":"Scanner","comment":"Constructs a new \u003ccode\u003eScanner\u003c/code\u003e that produces values scanned\n from the specified source.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":true,"isField":false,"isMethod":false,"isOrdinaryClass":false,"signature":"(java.lang.Readable)","flatSignature":"(Readable)","parameters":[{"name":"source","type":{"isPrimitive":false,"simpleName":"Readable","qualifiedName":"java.lang.Readable","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"Scanner","comment":"Constructs a new \u003ccode\u003eScanner\u003c/code\u003e that produces values scanned\n from the specified input stream. Bytes from the stream are converted\n into characters using the underlying platform\u0027s\n {@linkplain java.nio.charset.Charset#defaultCharset() default charset}.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":true,"isField":false,"isMethod":false,"isOrdinaryClass":false,"signature":"(java.io.InputStream)","flatSignature":"(InputStream)","parameters":[{"name":"source","type":{"isPrimitive":false,"simpleName":"InputStream","qualifiedName":"java.io.InputStream","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"Scanner","comment":"Constructs a new \u003ccode\u003eScanner\u003c/code\u003e that produces values scanned\n from the specified input stream. Bytes from the stream are converted\n into characters using the specified charset.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":true,"isField":false,"isMethod":false,"isOrdinaryClass":false,"signature":"(java.io.InputStream, java.lang.String)","flatSignature":"(InputStream, String)","parameters":[{"name":"source","type":{"isPrimitive":false,"simpleName":"InputStream","qualifiedName":"java.io.InputStream","dimension":"","elementType":{}}},{"name":"charsetName","type":{"isPrimitive":false,"simpleName":"String","qualifiedName":"java.lang.String","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"Scanner","comment":"Constructs a new \u003ccode\u003eScanner\u003c/code\u003e that produces values scanned\n from the specified file. Bytes from the file are converted into\n characters using the underlying platform\u0027s\n {@linkplain java.nio.charset.Charset#defaultCharset() default charset}.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":true,"isField":false,"isMethod":false,"isOrdinaryClass":false,"signature":"(java.io.File)","flatSignature":"(File)","parameters":[{"name":"source","type":{"isPrimitive":false,"simpleName":"File","qualifiedName":"java.io.File","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"Scanner","comment":"Constructs a new \u003ccode\u003eScanner\u003c/code\u003e that produces values scanned\n from the specified file. Bytes from the file are converted into\n characters using the specified charset.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":true,"isField":false,"isMethod":false,"isOrdinaryClass":false,"signature":"(java.io.File, java.lang.String)","flatSignature":"(File, String)","parameters":[{"name":"source","type":{"isPrimitive":false,"simpleName":"File","qualifiedName":"java.io.File","dimension":"","elementType":{}}},{"name":"charsetName","type":{"isPrimitive":false,"simpleName":"String","qualifiedName":"java.lang.String","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"Scanner","comment":"Constructs a new \u003ccode\u003eScanner\u003c/code\u003e that produces values scanned\n from the specified file. Bytes from the file are converted into\n characters using the underlying platform\u0027s\n {@linkplain java.nio.charset.Charset#defaultCharset() default charset}.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":true,"isField":false,"isMethod":false,"isOrdinaryClass":false,"signature":"(java.nio.file.Path)","flatSignature":"(Path)","parameters":[{"name":"source","type":{"isPrimitive":false,"simpleName":"Path","qualifiedName":"java.nio.file.Path","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"Scanner","comment":"Constructs a new \u003ccode\u003eScanner\u003c/code\u003e that produces values scanned\n from the specified file. Bytes from the file are converted into\n characters using the specified charset.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":true,"isField":false,"isMethod":false,"isOrdinaryClass":false,"signature":"(java.nio.file.Path, java.lang.String)","flatSignature":"(Path, String)","parameters":[{"name":"source","type":{"isPrimitive":false,"simpleName":"Path","qualifiedName":"java.nio.file.Path","dimension":"","elementType":{}}},{"name":"charsetName","type":{"isPrimitive":false,"simpleName":"String","qualifiedName":"java.lang.String","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"Scanner","comment":"Constructs a new \u003ccode\u003eScanner\u003c/code\u003e that produces values scanned\n from the specified string.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":true,"isField":false,"isMethod":false,"isOrdinaryClass":false,"signature":"(java.lang.String)","flatSignature":"(String)","parameters":[{"name":"source","type":{"isPrimitive":false,"simpleName":"String","qualifiedName":"java.lang.String","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"Scanner","comment":"Constructs a new \u003ccode\u003eScanner\u003c/code\u003e that produces values scanned\n from the specified channel. Bytes from the source are converted into\n characters using the underlying platform\u0027s\n {@linkplain java.nio.charset.Charset#defaultCharset() default charset}.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":true,"isField":false,"isMethod":false,"isOrdinaryClass":false,"signature":"(java.nio.channels.ReadableByteChannel)","flatSignature":"(ReadableByteChannel)","parameters":[{"name":"source","type":{"isPrimitive":false,"simpleName":"ReadableByteChannel","qualifiedName":"java.nio.channels.ReadableByteChannel","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"Scanner","comment":"Constructs a new \u003ccode\u003eScanner\u003c/code\u003e that produces values scanned\n from the specified channel. Bytes from the source are converted into\n characters using the specified charset.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":true,"isField":false,"isMethod":false,"isOrdinaryClass":false,"signature":"(java.nio.channels.ReadableByteChannel, java.lang.String)","flatSignature":"(ReadableByteChannel, String)","parameters":[{"name":"source","type":{"isPrimitive":false,"simpleName":"ReadableByteChannel","qualifiedName":"java.nio.channels.ReadableByteChannel","dimension":"","elementType":{}}},{"name":"charsetName","type":{"isPrimitive":false,"simpleName":"String","qualifiedName":"java.lang.String","dimension":"","elementType":{}}}],"typeParameters":[]}],"fields":[],"methods":[{"name":"close","comment":"Closes this scanner.\n\n \u003cp\u003e If this scanner has not yet been closed then if its underlying\n {@linkplain java.lang.Readable readable} also implements the {@link\n java.io.Closeable} interface then the readable\u0027s \u003ctt\u003eclose\u003c/tt\u003e method\n will be invoked.  If this scanner is already closed then invoking this\n method will have no effect.\n\n \u003cp\u003eAttempting to perform search operations after a scanner has\n been closed will result in an {@link IllegalStateException}.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":true,"simpleName":"void","qualifiedName":"void","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[],"typeParameters":[]},{"name":"ioException","comment":"Returns the \u003ccode\u003eIOException\u003c/code\u003e last thrown by this\n \u003ccode\u003eScanner\u003c/code\u003e\u0027s underlying \u003ccode\u003eReadable\u003c/code\u003e. This method\n returns \u003ccode\u003enull\u003c/code\u003e if no such exception exists.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":false,"simpleName":"IOException","qualifiedName":"java.io.IOException","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[],"typeParameters":[]},{"name":"delimiter","comment":"Returns the \u003ccode\u003ePattern\u003c/code\u003e this \u003ccode\u003eScanner\u003c/code\u003e is currently\n using to match delimiters.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":false,"simpleName":"Pattern","qualifiedName":"java.util.regex.Pattern","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[],"typeParameters":[]},{"name":"useDelimiter","comment":"Sets this scanner\u0027s delimiting pattern to the specified pattern.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.util.regex.Pattern)","flatSignature":"(Pattern)","returnType":{"isPrimitive":false,"simpleName":"Scanner","qualifiedName":"java.util.Scanner","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[{"name":"pattern","type":{"isPrimitive":false,"simpleName":"Pattern","qualifiedName":"java.util.regex.Pattern","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"useDelimiter","comment":"Sets this scanner\u0027s delimiting pattern to a pattern constructed from\n the specified \u003ccode\u003eString\u003c/code\u003e.\n\n \u003cp\u003e An invocation of this method of the form\n \u003ctt\u003euseDelimiter(pattern)\u003c/tt\u003e behaves in exactly the same way as the\n invocation \u003ctt\u003euseDelimiter(Pattern.compile(pattern))\u003c/tt\u003e.\n\n \u003cp\u003e Invoking the {@link #reset} method will set the scanner\u0027s delimiter\n to the \u003ca href\u003d \"#default-delimiter\"\u003edefault\u003c/a\u003e.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.lang.String)","flatSignature":"(String)","returnType":{"isPrimitive":false,"simpleName":"Scanner","qualifiedName":"java.util.Scanner","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[{"name":"pattern","type":{"isPrimitive":false,"simpleName":"String","qualifiedName":"java.lang.String","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"locale","comment":"Returns this scanner\u0027s locale.\n\n \u003cp\u003eA scanner\u0027s locale affects many elements of its default\n primitive matching regular expressions; see\n \u003ca href\u003d \"#localized-numbers\"\u003elocalized numbers\u003c/a\u003e above.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":false,"simpleName":"Locale","qualifiedName":"java.util.Locale","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[],"typeParameters":[]},{"name":"useLocale","comment":"Sets this scanner\u0027s locale to the specified locale.\n\n \u003cp\u003eA scanner\u0027s locale affects many elements of its default\n primitive matching regular expressions; see\n \u003ca href\u003d \"#localized-numbers\"\u003elocalized numbers\u003c/a\u003e above.\n\n \u003cp\u003eInvoking the {@link #reset} method will set the scanner\u0027s locale to\n the \u003ca href\u003d \"#initial-locale\"\u003einitial locale\u003c/a\u003e.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.util.Locale)","flatSignature":"(Locale)","returnType":{"isPrimitive":false,"simpleName":"Scanner","qualifiedName":"java.util.Scanner","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[{"name":"locale","type":{"isPrimitive":false,"simpleName":"Locale","qualifiedName":"java.util.Locale","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"radix","comment":"Returns this scanner\u0027s default radix.\n\n \u003cp\u003eA scanner\u0027s radix affects elements of its default\n number matching regular expressions; see\n \u003ca href\u003d \"#localized-numbers\"\u003elocalized numbers\u003c/a\u003e above.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[],"typeParameters":[]},{"name":"useRadix","comment":"Sets this scanner\u0027s default radix to the specified radix.\n\n \u003cp\u003eA scanner\u0027s radix affects elements of its default\n number matching regular expressions; see\n \u003ca href\u003d \"#localized-numbers\"\u003elocalized numbers\u003c/a\u003e above.\n\n \u003cp\u003eIf the radix is less than \u003ccode\u003eCharacter.MIN_RADIX\u003c/code\u003e\n or greater than \u003ccode\u003eCharacter.MAX_RADIX\u003c/code\u003e, then an\n \u003ccode\u003eIllegalArgumentException\u003c/code\u003e is thrown.\n\n \u003cp\u003eInvoking the {@link #reset} method will set the scanner\u0027s radix to\n \u003ccode\u003e10\u003c/code\u003e.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(int)","flatSignature":"(int)","returnType":{"isPrimitive":false,"simpleName":"Scanner","qualifiedName":"java.util.Scanner","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[{"name":"radix","type":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"match","comment":"Returns the match result of the last scanning operation performed\n by this scanner. This method throws \u003ccode\u003eIllegalStateException\u003c/code\u003e\n if no match has been performed, or if the last match was\n not successful.\n\n \u003cp\u003eThe various \u003ccode\u003enext\u003c/code\u003emethods of \u003ccode\u003eScanner\u003c/code\u003e\n make a match result available if they complete without throwing an\n exception. For instance, after an invocation of the {@link #nextInt}\n method that returned an int, this method returns a\n \u003ccode\u003eMatchResult\u003c/code\u003e for the search of the\n \u003ca href\u003d\"#Integer-regex\"\u003e\u003ci\u003eInteger\u003c/i\u003e\u003c/a\u003e regular expression\n defined above. Similarly the {@link #findInLine},\n {@link #findWithinHorizon}, and {@link #skip} methods will make a\n match available if they succeed.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":false,"simpleName":"MatchResult","qualifiedName":"java.util.regex.MatchResult","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[],"typeParameters":[]},{"name":"toString","comment":"\u003cp\u003eReturns the string representation of this \u003ccode\u003eScanner\u003c/code\u003e. The\n string representation of a \u003ccode\u003eScanner\u003c/code\u003e contains information\n that may be useful for debugging. The exact format is unspecified.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":false,"simpleName":"String","qualifiedName":"java.lang.String","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[],"typeParameters":[]},{"name":"hasNext","comment":"Returns true if this scanner has another token in its input.\n This method may block while waiting for input to scan.\n The scanner does not advance past any input.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":true,"simpleName":"boolean","qualifiedName":"boolean","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[],"typeParameters":[]},{"name":"next","comment":"Finds and returns the next complete token from this scanner.\n A complete token is preceded and followed by input that matches\n the delimiter pattern. This method may block while waiting for input\n to scan, even if a previous invocation of {@link #hasNext} returned\n \u003ccode\u003etrue\u003c/code\u003e.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":false,"simpleName":"String","qualifiedName":"java.lang.String","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[],"typeParameters":[]},{"name":"remove","comment":"The remove operation is not supported by this implementation of\n \u003ccode\u003eIterator\u003c/code\u003e.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":true,"simpleName":"void","qualifiedName":"void","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[],"typeParameters":[]},{"name":"hasNext","comment":"Returns true if the next token matches the pattern constructed from the\n specified string. The scanner does not advance past any input.\n\n \u003cp\u003e An invocation of this method of the form \u003ctt\u003ehasNext(pattern)\u003c/tt\u003e\n behaves in exactly the same way as the invocation\n \u003ctt\u003ehasNext(Pattern.compile(pattern))\u003c/tt\u003e.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.lang.String)","flatSignature":"(String)","returnType":{"isPrimitive":true,"simpleName":"boolean","qualifiedName":"boolean","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[{"name":"pattern","type":{"isPrimitive":false,"simpleName":"String","qualifiedName":"java.lang.String","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"next","comment":"Returns the next token if it matches the pattern constructed from the\n specified string.  If the match is successful, the scanner advances\n past the input that matched the pattern.\n\n \u003cp\u003e An invocation of this method of the form \u003ctt\u003enext(pattern)\u003c/tt\u003e\n behaves in exactly the same way as the invocation\n \u003ctt\u003enext(Pattern.compile(pattern))\u003c/tt\u003e.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.lang.String)","flatSignature":"(String)","returnType":{"isPrimitive":false,"simpleName":"String","qualifiedName":"java.lang.String","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[{"name":"pattern","type":{"isPrimitive":false,"simpleName":"String","qualifiedName":"java.lang.String","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"hasNext","comment":"Returns true if the next complete token matches the specified pattern.\n A complete token is prefixed and postfixed by input that matches\n the delimiter pattern. This method may block while waiting for input.\n The scanner does not advance past any input.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.util.regex.Pattern)","flatSignature":"(Pattern)","returnType":{"isPrimitive":true,"simpleName":"boolean","qualifiedName":"boolean","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[{"name":"pattern","type":{"isPrimitive":false,"simpleName":"Pattern","qualifiedName":"java.util.regex.Pattern","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"next","comment":"Returns the next token if it matches the specified pattern. This\n method may block while waiting for input to scan, even if a previous\n invocation of {@link #hasNext(Pattern)} returned \u003ccode\u003etrue\u003c/code\u003e.\n If the match is successful, the scanner advances past the input that\n matched the pattern.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.util.regex.Pattern)","flatSignature":"(Pattern)","returnType":{"isPrimitive":false,"simpleName":"String","qualifiedName":"java.lang.String","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[{"name":"pattern","type":{"isPrimitive":false,"simpleName":"Pattern","qualifiedName":"java.util.regex.Pattern","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"hasNextLine","comment":"Returns true if there is another line in the input of this scanner.\n This method may block while waiting for input. The scanner does not\n advance past any input.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":true,"simpleName":"boolean","qualifiedName":"boolean","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[],"typeParameters":[]},{"name":"nextLine","comment":"Advances this scanner past the current line and returns the input\n that was skipped.\n\n This method returns the rest of the current line, excluding any line\n separator at the end. The position is set to the beginning of the next\n line.\n\n \u003cp\u003eSince this method continues to search through the input looking\n for a line separator, it may buffer all of the input searching for\n the line to skip if no line separators are present.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":false,"simpleName":"String","qualifiedName":"java.lang.String","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[],"typeParameters":[]},{"name":"findInLine","comment":"Attempts to find the next occurrence of a pattern constructed from the\n specified string, ignoring delimiters.\n\n \u003cp\u003eAn invocation of this method of the form \u003ctt\u003efindInLine(pattern)\u003c/tt\u003e\n behaves in exactly the same way as the invocation\n \u003ctt\u003efindInLine(Pattern.compile(pattern))\u003c/tt\u003e.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.lang.String)","flatSignature":"(String)","returnType":{"isPrimitive":false,"simpleName":"String","qualifiedName":"java.lang.String","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[{"name":"pattern","type":{"isPrimitive":false,"simpleName":"String","qualifiedName":"java.lang.String","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"findInLine","comment":"Attempts to find the next occurrence of the specified pattern ignoring\n delimiters. If the pattern is found before the next line separator, the\n scanner advances past the input that matched and returns the string that\n matched the pattern.\n If no such pattern is detected in the input up to the next line\n separator, then \u003ccode\u003enull\u003c/code\u003e is returned and the scanner\u0027s\n position is unchanged. This method may block waiting for input that\n matches the pattern.\n\n \u003cp\u003eSince this method continues to search through the input looking\n for the specified pattern, it may buffer all of the input searching for\n the desired token if no line separators are present.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.util.regex.Pattern)","flatSignature":"(Pattern)","returnType":{"isPrimitive":false,"simpleName":"String","qualifiedName":"java.lang.String","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[{"name":"pattern","type":{"isPrimitive":false,"simpleName":"Pattern","qualifiedName":"java.util.regex.Pattern","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"findWithinHorizon","comment":"Attempts to find the next occurrence of a pattern constructed from the\n specified string, ignoring delimiters.\n\n \u003cp\u003eAn invocation of this method of the form\n \u003ctt\u003efindWithinHorizon(pattern)\u003c/tt\u003e behaves in exactly the same way as\n the invocation\n \u003ctt\u003efindWithinHorizon(Pattern.compile(pattern, horizon))\u003c/tt\u003e.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.lang.String, int)","flatSignature":"(String, int)","returnType":{"isPrimitive":false,"simpleName":"String","qualifiedName":"java.lang.String","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[{"name":"pattern","type":{"isPrimitive":false,"simpleName":"String","qualifiedName":"java.lang.String","dimension":"","elementType":{}}},{"name":"horizon","type":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"findWithinHorizon","comment":"Attempts to find the next occurrence of the specified pattern.\n\n \u003cp\u003eThis method searches through the input up to the specified\n search horizon, ignoring delimiters. If the pattern is found the\n scanner advances past the input that matched and returns the string\n that matched the pattern. If no such pattern is detected then the\n null is returned and the scanner\u0027s position remains unchanged. This\n method may block waiting for input that matches the pattern.\n\n \u003cp\u003eA scanner will never search more than \u003ccode\u003ehorizon\u003c/code\u003e code\n points beyond its current position. Note that a match may be clipped\n by the horizon; that is, an arbitrary match result may have been\n different if the horizon had been larger. The scanner treats the\n horizon as a transparent, non-anchoring bound (see {@link\n Matcher#useTransparentBounds} and {@link Matcher#useAnchoringBounds}).\n\n \u003cp\u003eIf horizon is \u003ccode\u003e0\u003c/code\u003e, then the horizon is ignored and\n this method continues to search through the input looking for the\n specified pattern without bound. In this case it may buffer all of\n the input searching for the pattern.\n\n \u003cp\u003eIf horizon is negative, then an IllegalArgumentException is\n thrown.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.util.regex.Pattern, int)","flatSignature":"(Pattern, int)","returnType":{"isPrimitive":false,"simpleName":"String","qualifiedName":"java.lang.String","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[{"name":"pattern","type":{"isPrimitive":false,"simpleName":"Pattern","qualifiedName":"java.util.regex.Pattern","dimension":"","elementType":{}}},{"name":"horizon","type":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"skip","comment":"Skips input that matches the specified pattern, ignoring delimiters.\n This method will skip input if an anchored match of the specified\n pattern succeeds.\n\n \u003cp\u003eIf a match to the specified pattern is not found at the\n current position, then no input is skipped and a\n \u003ctt\u003eNoSuchElementException\u003c/tt\u003e is thrown.\n\n \u003cp\u003eSince this method seeks to match the specified pattern starting at\n the scanner\u0027s current position, patterns that can match a lot of\n input (\".*\", for example) may cause the scanner to buffer a large\n amount of input.\n\n \u003cp\u003eNote that it is possible to skip something without risking a\n \u003ccode\u003eNoSuchElementException\u003c/code\u003e by using a pattern that can\n match nothing, e.g., \u003ccode\u003esc.skip(\"[ \\t]*\")\u003c/code\u003e.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.util.regex.Pattern)","flatSignature":"(Pattern)","returnType":{"isPrimitive":false,"simpleName":"Scanner","qualifiedName":"java.util.Scanner","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[{"name":"pattern","type":{"isPrimitive":false,"simpleName":"Pattern","qualifiedName":"java.util.regex.Pattern","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"skip","comment":"Skips input that matches a pattern constructed from the specified\n string.\n\n \u003cp\u003e An invocation of this method of the form \u003ctt\u003eskip(pattern)\u003c/tt\u003e\n behaves in exactly the same way as the invocation\n \u003ctt\u003eskip(Pattern.compile(pattern))\u003c/tt\u003e.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.lang.String)","flatSignature":"(String)","returnType":{"isPrimitive":false,"simpleName":"Scanner","qualifiedName":"java.util.Scanner","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[{"name":"pattern","type":{"isPrimitive":false,"simpleName":"String","qualifiedName":"java.lang.String","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"hasNextBoolean","comment":"Returns true if the next token in this scanner\u0027s input can be\n interpreted as a boolean value using a case insensitive pattern\n created from the string \"true|false\".  The scanner does not\n advance past the input that matched.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":true,"simpleName":"boolean","qualifiedName":"boolean","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[],"typeParameters":[]},{"name":"nextBoolean","comment":"Scans the next token of the input into a boolean value and returns\n that value. This method will throw \u003ccode\u003eInputMismatchException\u003c/code\u003e\n if the next token cannot be translated into a valid boolean value.\n If the match is successful, the scanner advances past the input that\n matched.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":true,"simpleName":"boolean","qualifiedName":"boolean","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[],"typeParameters":[]},{"name":"hasNextByte","comment":"Returns true if the next token in this scanner\u0027s input can be\n interpreted as a byte value in the default radix using the\n {@link #nextByte} method. The scanner does not advance past any input.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":true,"simpleName":"boolean","qualifiedName":"boolean","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[],"typeParameters":[]},{"name":"hasNextByte","comment":"Returns true if the next token in this scanner\u0027s input can be\n interpreted as a byte value in the specified radix using the\n {@link #nextByte} method. The scanner does not advance past any input.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(int)","flatSignature":"(int)","returnType":{"isPrimitive":true,"simpleName":"boolean","qualifiedName":"boolean","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[{"name":"radix","type":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"nextByte","comment":"Scans the next token of the input as a \u003ctt\u003ebyte\u003c/tt\u003e.\n\n \u003cp\u003e An invocation of this method of the form\n \u003ctt\u003enextByte()\u003c/tt\u003e behaves in exactly the same way as the\n invocation \u003ctt\u003enextByte(radix)\u003c/tt\u003e, where \u003ccode\u003eradix\u003c/code\u003e\n is the default radix of this scanner.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":true,"simpleName":"byte","qualifiedName":"byte","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[],"typeParameters":[]},{"name":"nextByte","comment":"Scans the next token of the input as a \u003ctt\u003ebyte\u003c/tt\u003e.\n This method will throw \u003ccode\u003eInputMismatchException\u003c/code\u003e\n if the next token cannot be translated into a valid byte value as\n described below. If the translation is successful, the scanner advances\n past the input that matched.\n\n \u003cp\u003e If the next token matches the \u003ca\n href\u003d\"#Integer-regex\"\u003e\u003ci\u003eInteger\u003c/i\u003e\u003c/a\u003e regular expression defined\n above then the token is converted into a \u003ctt\u003ebyte\u003c/tt\u003e value as if by\n removing all locale specific prefixes, group separators, and locale\n specific suffixes, then mapping non-ASCII digits into ASCII\n digits via {@link Character#digit Character.digit}, prepending a\n negative sign (-) if the locale specific negative prefixes and suffixes\n were present, and passing the resulting string to\n {@link Byte#parseByte(String, int) Byte.parseByte} with the\n specified radix.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(int)","flatSignature":"(int)","returnType":{"isPrimitive":true,"simpleName":"byte","qualifiedName":"byte","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[{"name":"radix","type":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"hasNextShort","comment":"Returns true if the next token in this scanner\u0027s input can be\n interpreted as a short value in the default radix using the\n {@link #nextShort} method. The scanner does not advance past any input.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":true,"simpleName":"boolean","qualifiedName":"boolean","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[],"typeParameters":[]},{"name":"hasNextShort","comment":"Returns true if the next token in this scanner\u0027s input can be\n interpreted as a short value in the specified radix using the\n {@link #nextShort} method. The scanner does not advance past any input.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(int)","flatSignature":"(int)","returnType":{"isPrimitive":true,"simpleName":"boolean","qualifiedName":"boolean","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[{"name":"radix","type":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"nextShort","comment":"Scans the next token of the input as a \u003ctt\u003eshort\u003c/tt\u003e.\n\n \u003cp\u003e An invocation of this method of the form\n \u003ctt\u003enextShort()\u003c/tt\u003e behaves in exactly the same way as the\n invocation \u003ctt\u003enextShort(radix)\u003c/tt\u003e, where \u003ccode\u003eradix\u003c/code\u003e\n is the default radix of this scanner.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":true,"simpleName":"short","qualifiedName":"short","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[],"typeParameters":[]},{"name":"nextShort","comment":"Scans the next token of the input as a \u003ctt\u003eshort\u003c/tt\u003e.\n This method will throw \u003ccode\u003eInputMismatchException\u003c/code\u003e\n if the next token cannot be translated into a valid short value as\n described below. If the translation is successful, the scanner advances\n past the input that matched.\n\n \u003cp\u003e If the next token matches the \u003ca\n href\u003d\"#Integer-regex\"\u003e\u003ci\u003eInteger\u003c/i\u003e\u003c/a\u003e regular expression defined\n above then the token is converted into a \u003ctt\u003eshort\u003c/tt\u003e value as if by\n removing all locale specific prefixes, group separators, and locale\n specific suffixes, then mapping non-ASCII digits into ASCII\n digits via {@link Character#digit Character.digit}, prepending a\n negative sign (-) if the locale specific negative prefixes and suffixes\n were present, and passing the resulting string to\n {@link Short#parseShort(String, int) Short.parseShort} with the\n specified radix.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(int)","flatSignature":"(int)","returnType":{"isPrimitive":true,"simpleName":"short","qualifiedName":"short","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[{"name":"radix","type":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"hasNextInt","comment":"Returns true if the next token in this scanner\u0027s input can be\n interpreted as an int value in the default radix using the\n {@link #nextInt} method. The scanner does not advance past any input.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":true,"simpleName":"boolean","qualifiedName":"boolean","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[],"typeParameters":[]},{"name":"hasNextInt","comment":"Returns true if the next token in this scanner\u0027s input can be\n interpreted as an int value in the specified radix using the\n {@link #nextInt} method. The scanner does not advance past any input.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(int)","flatSignature":"(int)","returnType":{"isPrimitive":true,"simpleName":"boolean","qualifiedName":"boolean","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[{"name":"radix","type":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"nextInt","comment":"Scans the next token of the input as an \u003ctt\u003eint\u003c/tt\u003e.\n\n \u003cp\u003e An invocation of this method of the form\n \u003ctt\u003enextInt()\u003c/tt\u003e behaves in exactly the same way as the\n invocation \u003ctt\u003enextInt(radix)\u003c/tt\u003e, where \u003ccode\u003eradix\u003c/code\u003e\n is the default radix of this scanner.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[],"typeParameters":[]},{"name":"nextInt","comment":"Scans the next token of the input as an \u003ctt\u003eint\u003c/tt\u003e.\n This method will throw \u003ccode\u003eInputMismatchException\u003c/code\u003e\n if the next token cannot be translated into a valid int value as\n described below. If the translation is successful, the scanner advances\n past the input that matched.\n\n \u003cp\u003e If the next token matches the \u003ca\n href\u003d\"#Integer-regex\"\u003e\u003ci\u003eInteger\u003c/i\u003e\u003c/a\u003e regular expression defined\n above then the token is converted into an \u003ctt\u003eint\u003c/tt\u003e value as if by\n removing all locale specific prefixes, group separators, and locale\n specific suffixes, then mapping non-ASCII digits into ASCII\n digits via {@link Character#digit Character.digit}, prepending a\n negative sign (-) if the locale specific negative prefixes and suffixes\n were present, and passing the resulting string to\n {@link Integer#parseInt(String, int) Integer.parseInt} with the\n specified radix.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(int)","flatSignature":"(int)","returnType":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[{"name":"radix","type":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"hasNextLong","comment":"Returns true if the next token in this scanner\u0027s input can be\n interpreted as a long value in the default radix using the\n {@link #nextLong} method. The scanner does not advance past any input.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":true,"simpleName":"boolean","qualifiedName":"boolean","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[],"typeParameters":[]},{"name":"hasNextLong","comment":"Returns true if the next token in this scanner\u0027s input can be\n interpreted as a long value in the specified radix using the\n {@link #nextLong} method. The scanner does not advance past any input.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(int)","flatSignature":"(int)","returnType":{"isPrimitive":true,"simpleName":"boolean","qualifiedName":"boolean","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[{"name":"radix","type":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"nextLong","comment":"Scans the next token of the input as a \u003ctt\u003elong\u003c/tt\u003e.\n\n \u003cp\u003e An invocation of this method of the form\n \u003ctt\u003enextLong()\u003c/tt\u003e behaves in exactly the same way as the\n invocation \u003ctt\u003enextLong(radix)\u003c/tt\u003e, where \u003ccode\u003eradix\u003c/code\u003e\n is the default radix of this scanner.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":true,"simpleName":"long","qualifiedName":"long","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[],"typeParameters":[]},{"name":"nextLong","comment":"Scans the next token of the input as a \u003ctt\u003elong\u003c/tt\u003e.\n This method will throw \u003ccode\u003eInputMismatchException\u003c/code\u003e\n if the next token cannot be translated into a valid long value as\n described below. If the translation is successful, the scanner advances\n past the input that matched.\n\n \u003cp\u003e If the next token matches the \u003ca\n href\u003d\"#Integer-regex\"\u003e\u003ci\u003eInteger\u003c/i\u003e\u003c/a\u003e regular expression defined\n above then the token is converted into a \u003ctt\u003elong\u003c/tt\u003e value as if by\n removing all locale specific prefixes, group separators, and locale\n specific suffixes, then mapping non-ASCII digits into ASCII\n digits via {@link Character#digit Character.digit}, prepending a\n negative sign (-) if the locale specific negative prefixes and suffixes\n were present, and passing the resulting string to\n {@link Long#parseLong(String, int) Long.parseLong} with the\n specified radix.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(int)","flatSignature":"(int)","returnType":{"isPrimitive":true,"simpleName":"long","qualifiedName":"long","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[{"name":"radix","type":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"hasNextFloat","comment":"Returns true if the next token in this scanner\u0027s input can be\n interpreted as a float value using the {@link #nextFloat}\n method. The scanner does not advance past any input.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":true,"simpleName":"boolean","qualifiedName":"boolean","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[],"typeParameters":[]},{"name":"nextFloat","comment":"Scans the next token of the input as a \u003ctt\u003efloat\u003c/tt\u003e.\n This method will throw \u003ccode\u003eInputMismatchException\u003c/code\u003e\n if the next token cannot be translated into a valid float value as\n described below. If the translation is successful, the scanner advances\n past the input that matched.\n\n \u003cp\u003e If the next token matches the \u003ca\n href\u003d\"#Float-regex\"\u003e\u003ci\u003eFloat\u003c/i\u003e\u003c/a\u003e regular expression defined above\n then the token is converted into a \u003ctt\u003efloat\u003c/tt\u003e value as if by\n removing all locale specific prefixes, group separators, and locale\n specific suffixes, then mapping non-ASCII digits into ASCII\n digits via {@link Character#digit Character.digit}, prepending a\n negative sign (-) if the locale specific negative prefixes and suffixes\n were present, and passing the resulting string to\n {@link Float#parseFloat Float.parseFloat}. If the token matches\n the localized NaN or infinity strings, then either \"Nan\" or \"Infinity\"\n is passed to {@link Float#parseFloat(String) Float.parseFloat} as\n appropriate.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":true,"simpleName":"float","qualifiedName":"float","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[],"typeParameters":[]},{"name":"hasNextDouble","comment":"Returns true if the next token in this scanner\u0027s input can be\n interpreted as a double value using the {@link #nextDouble}\n method. The scanner does not advance past any input.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":true,"simpleName":"boolean","qualifiedName":"boolean","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[],"typeParameters":[]},{"name":"nextDouble","comment":"Scans the next token of the input as a \u003ctt\u003edouble\u003c/tt\u003e.\n This method will throw \u003ccode\u003eInputMismatchException\u003c/code\u003e\n if the next token cannot be translated into a valid double value.\n If the translation is successful, the scanner advances past the input\n that matched.\n\n \u003cp\u003e If the next token matches the \u003ca\n href\u003d\"#Float-regex\"\u003e\u003ci\u003eFloat\u003c/i\u003e\u003c/a\u003e regular expression defined above\n then the token is converted into a \u003ctt\u003edouble\u003c/tt\u003e value as if by\n removing all locale specific prefixes, group separators, and locale\n specific suffixes, then mapping non-ASCII digits into ASCII\n digits via {@link Character#digit Character.digit}, prepending a\n negative sign (-) if the locale specific negative prefixes and suffixes\n were present, and passing the resulting string to\n {@link Double#parseDouble Double.parseDouble}. If the token matches\n the localized NaN or infinity strings, then either \"Nan\" or \"Infinity\"\n is passed to {@link Double#parseDouble(String) Double.parseDouble} as\n appropriate.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":true,"simpleName":"double","qualifiedName":"double","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[],"typeParameters":[]},{"name":"hasNextBigInteger","comment":"Returns true if the next token in this scanner\u0027s input can be\n interpreted as a \u003ccode\u003eBigInteger\u003c/code\u003e in the default radix using the\n {@link #nextBigInteger} method. The scanner does not advance past any\n input.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":true,"simpleName":"boolean","qualifiedName":"boolean","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[],"typeParameters":[]},{"name":"hasNextBigInteger","comment":"Returns true if the next token in this scanner\u0027s input can be\n interpreted as a \u003ccode\u003eBigInteger\u003c/code\u003e in the specified radix using\n the {@link #nextBigInteger} method. The scanner does not advance past\n any input.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(int)","flatSignature":"(int)","returnType":{"isPrimitive":true,"simpleName":"boolean","qualifiedName":"boolean","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[{"name":"radix","type":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"nextBigInteger","comment":"Scans the next token of the input as a {@link java.math.BigInteger\n BigInteger}.\n\n \u003cp\u003e An invocation of this method of the form\n \u003ctt\u003enextBigInteger()\u003c/tt\u003e behaves in exactly the same way as the\n invocation \u003ctt\u003enextBigInteger(radix)\u003c/tt\u003e, where \u003ccode\u003eradix\u003c/code\u003e\n is the default radix of this scanner.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":false,"simpleName":"BigInteger","qualifiedName":"java.math.BigInteger","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[],"typeParameters":[]},{"name":"nextBigInteger","comment":"Scans the next token of the input as a {@link java.math.BigInteger\n BigInteger}.\n\n \u003cp\u003e If the next token matches the \u003ca\n href\u003d\"#Integer-regex\"\u003e\u003ci\u003eInteger\u003c/i\u003e\u003c/a\u003e regular expression defined\n above then the token is converted into a \u003ctt\u003eBigInteger\u003c/tt\u003e value as if\n by removing all group separators, mapping non-ASCII digits into ASCII\n digits via the {@link Character#digit Character.digit}, and passing the\n resulting string to the {@link\n java.math.BigInteger#BigInteger(java.lang.String)\n BigInteger(String, int)} constructor with the specified radix.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(int)","flatSignature":"(int)","returnType":{"isPrimitive":false,"simpleName":"BigInteger","qualifiedName":"java.math.BigInteger","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[{"name":"radix","type":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"hasNextBigDecimal","comment":"Returns true if the next token in this scanner\u0027s input can be\n interpreted as a \u003ccode\u003eBigDecimal\u003c/code\u003e using the\n {@link #nextBigDecimal} method. The scanner does not advance past any\n input.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":true,"simpleName":"boolean","qualifiedName":"boolean","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[],"typeParameters":[]},{"name":"nextBigDecimal","comment":"Scans the next token of the input as a {@link java.math.BigDecimal\n BigDecimal}.\n\n \u003cp\u003e If the next token matches the \u003ca\n href\u003d\"#Decimal-regex\"\u003e\u003ci\u003eDecimal\u003c/i\u003e\u003c/a\u003e regular expression defined\n above then the token is converted into a \u003ctt\u003eBigDecimal\u003c/tt\u003e value as if\n by removing all group separators, mapping non-ASCII digits into ASCII\n digits via the {@link Character#digit Character.digit}, and passing the\n resulting string to the {@link\n java.math.BigDecimal#BigDecimal(java.lang.String) BigDecimal(String)}\n constructor.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":false,"simpleName":"BigDecimal","qualifiedName":"java.math.BigDecimal","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[],"typeParameters":[]},{"name":"reset","comment":"Resets this scanner.\n\n \u003cp\u003e Resetting a scanner discards all of its explicit state\n information which may have been changed by invocations of {@link\n #useDelimiter}, {@link #useLocale}, or {@link #useRadix}.\n\n \u003cp\u003e An invocation of this method of the form\n \u003ctt\u003escanner.reset()\u003c/tt\u003e behaves in exactly the same way as the\n invocation\n\n \u003cblockquote\u003e\u003cpre\u003e{@code\n   scanner.useDelimiter(\"\\\\p{javaWhitespace}+\")\n          .useLocale(Locale.getDefault(Locale.Category.FORMAT))\n          .useRadix(10);\n }\u003c/pre\u003e\u003c/blockquote\u003e","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":false,"simpleName":"Scanner","qualifiedName":"java.util.Scanner","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[],"typeParameters":[]}],"typeParameters":[],"enumConstants":[]}