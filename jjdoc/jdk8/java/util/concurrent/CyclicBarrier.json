{"name":"CyclicBarrier","comment":"A synchronization aid that allows a set of threads to all wait for\n each other to reach a common barrier point.  CyclicBarriers are\n useful in programs involving a fixed sized party of threads that\n must occasionally wait for each other. The barrier is called\n \u003cem\u003ecyclic\u003c/em\u003e because it can be re-used after the waiting threads\n are released.\n\n \u003cp\u003eA {@code CyclicBarrier} supports an optional {@link Runnable} command\n that is run once per barrier point, after the last thread in the party\n arrives, but before any threads are released.\n This \u003cem\u003ebarrier action\u003c/em\u003e is useful\n for updating shared-state before any of the parties continue.\n\n \u003cp\u003e\u003cb\u003eSample usage:\u003c/b\u003e Here is an example of using a barrier in a\n parallel decomposition design:\n\n  \u003cpre\u003e {@code\n class Solver {\n   final int N;\n   final float[][] data;\n   final CyclicBarrier barrier;\n\n   class Worker implements Runnable {\n     int myRow;\n     Worker(int row) { myRow \u003d row; }\n     public void run() {\n       while (!done()) {\n         processRow(myRow);\n\n         try {\n           barrier.await();\n         } catch (InterruptedException ex) {\n           return;\n         } catch (BrokenBarrierException ex) {\n           return;\n         }\n       }\n     }\n   }\n\n   public Solver(float[][] matrix) {\n     data \u003d matrix;\n     N \u003d matrix.length;\n     Runnable barrierAction \u003d\n       new Runnable() { public void run() { mergeRows(...); }};\n     barrier \u003d new CyclicBarrier(N, barrierAction);\n\n     List\u003cThread\u003e threads \u003d new ArrayList\u003cThread\u003e(N);\n     for (int i \u003d 0; i \u003c N; i++) {\n       Thread thread \u003d new Thread(new Worker(i));\n       threads.add(thread);\n       thread.start();\n     }\n\n     // wait until done\n     for (Thread thread : threads)\n       thread.join();\n   }\n }}\u003c/pre\u003e\n\n Here, each worker thread processes a row of the matrix then waits at the\n barrier until all rows have been processed. When all rows are processed\n the supplied {@link Runnable} barrier action is executed and merges the\n rows. If the merger\n determines that a solution has been found then {@code done()} will return\n {@code true} and each worker will terminate.\n\n \u003cp\u003eIf the barrier action does not rely on the parties being suspended when\n it is executed, then any of the threads in the party could execute that\n action when it is released. To facilitate this, each invocation of\n {@link #await} returns the arrival index of that thread at the barrier.\n You can then choose which thread should execute the barrier action, for\n example:\n  \u003cpre\u003e {@code\n if (barrier.await() \u003d\u003d 0) {\n   // log the completion of this iteration\n }}\u003c/pre\u003e\n\n \u003cp\u003eThe {@code CyclicBarrier} uses an all-or-none breakage model\n for failed synchronization attempts: If a thread leaves a barrier\n point prematurely because of interruption, failure, or timeout, all\n other threads waiting at that barrier point will also leave\n abnormally via {@link BrokenBarrierException} (or\n {@link InterruptedException} if they too were interrupted at about\n the same time).\n\n \u003cp\u003eMemory consistency effects: Actions in a thread prior to calling\n {@code await()}\n \u003ca href\u003d\"package-summary.html#MemoryVisibility\"\u003e\u003ci\u003ehappen-before\u003c/i\u003e\u003c/a\u003e\n actions that are part of the barrier action, which in turn\n \u003ci\u003ehappen-before\u003c/i\u003e actions following a successful return from the\n corresponding {@code await()} in other threads.","isClass":true,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":false,"isOrdinaryClass":true,"isPrimitive":false,"simpleName":"CyclicBarrier","qualifiedName":"java.util.concurrent.CyclicBarrier","dimension":"","elementType":{},"package":"java.util.concurrent","superclass":"java.lang.Object","interfaces":[],"isAbstract":false,"isStatic":false,"since":"1.5","innerClasses":[],"isInnerClass":false,"constructors":[{"name":"CyclicBarrier","comment":"Creates a new {@code CyclicBarrier} that will trip when the\n given number of parties (threads) are waiting upon it, and which\n will execute the given barrier action when the barrier is tripped,\n performed by the last thread entering the barrier.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":true,"isField":false,"isMethod":false,"isOrdinaryClass":false,"signature":"(int, java.lang.Runnable)","flatSignature":"(int, Runnable)","parameters":[{"name":"parties","type":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}}},{"name":"barrierAction","type":{"isPrimitive":false,"simpleName":"Runnable","qualifiedName":"java.lang.Runnable","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"CyclicBarrier","comment":"Creates a new {@code CyclicBarrier} that will trip when the\n given number of parties (threads) are waiting upon it, and\n does not perform a predefined action when the barrier is tripped.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":true,"isField":false,"isMethod":false,"isOrdinaryClass":false,"signature":"(int)","flatSignature":"(int)","parameters":[{"name":"parties","type":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}}}],"typeParameters":[]}],"fields":[],"methods":[{"name":"getParties","comment":"Returns the number of parties required to trip this barrier.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[],"typeParameters":[]},{"name":"await","comment":"Waits until all {@linkplain #getParties parties} have invoked\n {@code await} on this barrier.\n\n \u003cp\u003eIf the current thread is not the last to arrive then it is\n disabled for thread scheduling purposes and lies dormant until\n one of the following things happens:\n \u003cul\u003e\n \u003cli\u003eThe last thread arrives; or\n \u003cli\u003eSome other thread {@linkplain Thread#interrupt interrupts}\n the current thread; or\n \u003cli\u003eSome other thread {@linkplain Thread#interrupt interrupts}\n one of the other waiting threads; or\n \u003cli\u003eSome other thread times out while waiting for barrier; or\n \u003cli\u003eSome other thread invokes {@link #reset} on this barrier.\n \u003c/ul\u003e\n\n \u003cp\u003eIf the current thread:\n \u003cul\u003e\n \u003cli\u003ehas its interrupted status set on entry to this method; or\n \u003cli\u003eis {@linkplain Thread#interrupt interrupted} while waiting\n \u003c/ul\u003e\n then {@link InterruptedException} is thrown and the current thread\u0027s\n interrupted status is cleared.\n\n \u003cp\u003eIf the barrier is {@link #reset} while any thread is waiting,\n or if the barrier {@linkplain #isBroken is broken} when\n {@code await} is invoked, or while any thread is waiting, then\n {@link BrokenBarrierException} is thrown.\n\n \u003cp\u003eIf any thread is {@linkplain Thread#interrupt interrupted} while waiting,\n then all other waiting threads will throw\n {@link BrokenBarrierException} and the barrier is placed in the broken\n state.\n\n \u003cp\u003eIf the current thread is the last thread to arrive, and a\n non-null barrier action was supplied in the constructor, then the\n current thread runs the action before allowing the other threads to\n continue.\n If an exception occurs during the barrier action then that exception\n will be propagated in the current thread and the barrier is placed in\n the broken state.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[],"typeParameters":[]},{"name":"await","comment":"Waits until all {@linkplain #getParties parties} have invoked\n {@code await} on this barrier, or the specified waiting time elapses.\n\n \u003cp\u003eIf the current thread is not the last to arrive then it is\n disabled for thread scheduling purposes and lies dormant until\n one of the following things happens:\n \u003cul\u003e\n \u003cli\u003eThe last thread arrives; or\n \u003cli\u003eThe specified timeout elapses; or\n \u003cli\u003eSome other thread {@linkplain Thread#interrupt interrupts}\n the current thread; or\n \u003cli\u003eSome other thread {@linkplain Thread#interrupt interrupts}\n one of the other waiting threads; or\n \u003cli\u003eSome other thread times out while waiting for barrier; or\n \u003cli\u003eSome other thread invokes {@link #reset} on this barrier.\n \u003c/ul\u003e\n\n \u003cp\u003eIf the current thread:\n \u003cul\u003e\n \u003cli\u003ehas its interrupted status set on entry to this method; or\n \u003cli\u003eis {@linkplain Thread#interrupt interrupted} while waiting\n \u003c/ul\u003e\n then {@link InterruptedException} is thrown and the current thread\u0027s\n interrupted status is cleared.\n\n \u003cp\u003eIf the specified waiting time elapses then {@link TimeoutException}\n is thrown. If the time is less than or equal to zero, the\n method will not wait at all.\n\n \u003cp\u003eIf the barrier is {@link #reset} while any thread is waiting,\n or if the barrier {@linkplain #isBroken is broken} when\n {@code await} is invoked, or while any thread is waiting, then\n {@link BrokenBarrierException} is thrown.\n\n \u003cp\u003eIf any thread is {@linkplain Thread#interrupt interrupted} while\n waiting, then all other waiting threads will throw {@link\n BrokenBarrierException} and the barrier is placed in the broken\n state.\n\n \u003cp\u003eIf the current thread is the last thread to arrive, and a\n non-null barrier action was supplied in the constructor, then the\n current thread runs the action before allowing the other threads to\n continue.\n If an exception occurs during the barrier action then that exception\n will be propagated in the current thread and the barrier is placed in\n the broken state.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(long, java.util.concurrent.TimeUnit)","flatSignature":"(long, TimeUnit)","returnType":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[{"name":"timeout","type":{"isPrimitive":true,"simpleName":"long","qualifiedName":"long","dimension":"","elementType":{}}},{"name":"unit","type":{"isPrimitive":false,"simpleName":"TimeUnit","qualifiedName":"java.util.concurrent.TimeUnit","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"isBroken","comment":"Queries if this barrier is in a broken state.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":true,"simpleName":"boolean","qualifiedName":"boolean","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[],"typeParameters":[]},{"name":"reset","comment":"Resets the barrier to its initial state.  If any parties are\n currently waiting at the barrier, they will return with a\n {@link BrokenBarrierException}. Note that resets \u003cem\u003eafter\u003c/em\u003e\n a breakage has occurred for other reasons can be complicated to\n carry out; threads need to re-synchronize in some other way,\n and choose one to perform the reset.  It may be preferable to\n instead create a new barrier for subsequent use.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":true,"simpleName":"void","qualifiedName":"void","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[],"typeParameters":[]},{"name":"getNumberWaiting","comment":"Returns the number of parties currently waiting at the barrier.\n This method is primarily useful for debugging and assertions.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[],"typeParameters":[]}],"typeParameters":[],"enumConstants":[]}