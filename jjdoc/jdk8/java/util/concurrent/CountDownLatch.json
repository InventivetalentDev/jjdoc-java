{"name":"CountDownLatch","comment":"A synchronization aid that allows one or more threads to wait until\n a set of operations being performed in other threads completes.\n\n \u003cp\u003eA {@code CountDownLatch} is initialized with a given \u003cem\u003ecount\u003c/em\u003e.\n The {@link #await await} methods block until the current count reaches\n zero due to invocations of the {@link #countDown} method, after which\n all waiting threads are released and any subsequent invocations of\n {@link #await await} return immediately.  This is a one-shot phenomenon\n -- the count cannot be reset.  If you need a version that resets the\n count, consider using a {@link CyclicBarrier}.\n\n \u003cp\u003eA {@code CountDownLatch} is a versatile synchronization tool\n and can be used for a number of purposes.  A\n {@code CountDownLatch} initialized with a count of one serves as a\n simple on/off latch, or gate: all threads invoking {@link #await await}\n wait at the gate until it is opened by a thread invoking {@link\n #countDown}.  A {@code CountDownLatch} initialized to \u003cem\u003eN\u003c/em\u003e\n can be used to make one thread wait until \u003cem\u003eN\u003c/em\u003e threads have\n completed some action, or some action has been completed N times.\n\n \u003cp\u003eA useful property of a {@code CountDownLatch} is that it\n doesn\u0027t require that threads calling {@code countDown} wait for\n the count to reach zero before proceeding, it simply prevents any\n thread from proceeding past an {@link #await await} until all\n threads could pass.\n\n \u003cp\u003e\u003cb\u003eSample usage:\u003c/b\u003e Here is a pair of classes in which a group\n of worker threads use two countdown latches:\n \u003cul\u003e\n \u003cli\u003eThe first is a start signal that prevents any worker from proceeding\n until the driver is ready for them to proceed;\n \u003cli\u003eThe second is a completion signal that allows the driver to wait\n until all workers have completed.\n \u003c/ul\u003e\n\n  \u003cpre\u003e {@code\n class Driver { // ...\n   void main() throws InterruptedException {\n     CountDownLatch startSignal \u003d new CountDownLatch(1);\n     CountDownLatch doneSignal \u003d new CountDownLatch(N);\n\n     for (int i \u003d 0; i \u003c N; ++i) // create and start threads\n       new Thread(new Worker(startSignal, doneSignal)).start();\n\n     doSomethingElse();            // don\u0027t let run yet\n     startSignal.countDown();      // let all threads proceed\n     doSomethingElse();\n     doneSignal.await();           // wait for all to finish\n   }\n }\n\n class Worker implements Runnable {\n   private final CountDownLatch startSignal;\n   private final CountDownLatch doneSignal;\n   Worker(CountDownLatch startSignal, CountDownLatch doneSignal) {\n     this.startSignal \u003d startSignal;\n     this.doneSignal \u003d doneSignal;\n   }\n   public void run() {\n     try {\n       startSignal.await();\n       doWork();\n       doneSignal.countDown();\n     } catch (InterruptedException ex) {} // return;\n   }\n\n   void doWork() { ... }\n }}\u003c/pre\u003e\n\n \u003cp\u003eAnother typical usage would be to divide a problem into N parts,\n describe each part with a Runnable that executes that portion and\n counts down on the latch, and queue all the Runnables to an\n Executor.  When all sub-parts are complete, the coordinating thread\n will be able to pass through await. (When threads must repeatedly\n count down in this way, instead use a {@link CyclicBarrier}.)\n\n  \u003cpre\u003e {@code\n class Driver2 { // ...\n   void main() throws InterruptedException {\n     CountDownLatch doneSignal \u003d new CountDownLatch(N);\n     Executor e \u003d ...\n\n     for (int i \u003d 0; i \u003c N; ++i) // create and start threads\n       e.execute(new WorkerRunnable(doneSignal, i));\n\n     doneSignal.await();           // wait for all to finish\n   }\n }\n\n class WorkerRunnable implements Runnable {\n   private final CountDownLatch doneSignal;\n   private final int i;\n   WorkerRunnable(CountDownLatch doneSignal, int i) {\n     this.doneSignal \u003d doneSignal;\n     this.i \u003d i;\n   }\n   public void run() {\n     try {\n       doWork(i);\n       doneSignal.countDown();\n     } catch (InterruptedException ex) {} // return;\n   }\n\n   void doWork() { ... }\n }}\u003c/pre\u003e\n\n \u003cp\u003eMemory consistency effects: Until the count reaches\n zero, actions in a thread prior to calling\n {@code countDown()}\n \u003ca href\u003d\"package-summary.html#MemoryVisibility\"\u003e\u003ci\u003ehappen-before\u003c/i\u003e\u003c/a\u003e\n actions following a successful return from a corresponding\n {@code await()} in another thread.","isClass":true,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":false,"isOrdinaryClass":true,"isPrimitive":false,"simpleName":"CountDownLatch","qualifiedName":"java.util.concurrent.CountDownLatch","dimension":"","elementType":{},"package":"java.util.concurrent","superclass":"java.lang.Object","interfaces":[],"isAbstract":false,"isStatic":false,"since":"1.5","innerClasses":[],"isInnerClass":false,"constructors":[{"name":"CountDownLatch","comment":"Constructs a {@code CountDownLatch} initialized with the given count.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":true,"isField":false,"isMethod":false,"isOrdinaryClass":false,"signature":"(int)","flatSignature":"(int)","parameters":[{"name":"count","type":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}}}],"typeParameters":[]}],"fields":[],"methods":[{"name":"await","comment":"Causes the current thread to wait until the latch has counted down to\n zero, unless the thread is {@linkplain Thread#interrupt interrupted}.\n\n \u003cp\u003eIf the current count is zero then this method returns immediately.\n\n \u003cp\u003eIf the current count is greater than zero then the current\n thread becomes disabled for thread scheduling purposes and lies\n dormant until one of two things happen:\n \u003cul\u003e\n \u003cli\u003eThe count reaches zero due to invocations of the\n {@link #countDown} method; or\n \u003cli\u003eSome other thread {@linkplain Thread#interrupt interrupts}\n the current thread.\n \u003c/ul\u003e\n\n \u003cp\u003eIf the current thread:\n \u003cul\u003e\n \u003cli\u003ehas its interrupted status set on entry to this method; or\n \u003cli\u003eis {@linkplain Thread#interrupt interrupted} while waiting,\n \u003c/ul\u003e\n then {@link InterruptedException} is thrown and the current thread\u0027s\n interrupted status is cleared.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":true,"simpleName":"void","qualifiedName":"void","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[],"typeParameters":[]},{"name":"await","comment":"Causes the current thread to wait until the latch has counted down to\n zero, unless the thread is {@linkplain Thread#interrupt interrupted},\n or the specified waiting time elapses.\n\n \u003cp\u003eIf the current count is zero then this method returns immediately\n with the value {@code true}.\n\n \u003cp\u003eIf the current count is greater than zero then the current\n thread becomes disabled for thread scheduling purposes and lies\n dormant until one of three things happen:\n \u003cul\u003e\n \u003cli\u003eThe count reaches zero due to invocations of the\n {@link #countDown} method; or\n \u003cli\u003eSome other thread {@linkplain Thread#interrupt interrupts}\n the current thread; or\n \u003cli\u003eThe specified waiting time elapses.\n \u003c/ul\u003e\n\n \u003cp\u003eIf the count reaches zero then the method returns with the\n value {@code true}.\n\n \u003cp\u003eIf the current thread:\n \u003cul\u003e\n \u003cli\u003ehas its interrupted status set on entry to this method; or\n \u003cli\u003eis {@linkplain Thread#interrupt interrupted} while waiting,\n \u003c/ul\u003e\n then {@link InterruptedException} is thrown and the current thread\u0027s\n interrupted status is cleared.\n\n \u003cp\u003eIf the specified waiting time elapses then the value {@code false}\n is returned.  If the time is less than or equal to zero, the method\n will not wait at all.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(long, java.util.concurrent.TimeUnit)","flatSignature":"(long, TimeUnit)","returnType":{"isPrimitive":true,"simpleName":"boolean","qualifiedName":"boolean","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[{"name":"timeout","type":{"isPrimitive":true,"simpleName":"long","qualifiedName":"long","dimension":"","elementType":{}}},{"name":"unit","type":{"isPrimitive":false,"simpleName":"TimeUnit","qualifiedName":"java.util.concurrent.TimeUnit","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"countDown","comment":"Decrements the count of the latch, releasing all waiting threads if\n the count reaches zero.\n\n \u003cp\u003eIf the current count is greater than zero then it is decremented.\n If the new count is zero then all waiting threads are re-enabled for\n thread scheduling purposes.\n\n \u003cp\u003eIf the current count equals zero then nothing happens.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":true,"simpleName":"void","qualifiedName":"void","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[],"typeParameters":[]},{"name":"getCount","comment":"Returns the current count.\n\n \u003cp\u003eThis method is typically used for debugging and testing purposes.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":true,"simpleName":"long","qualifiedName":"long","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[],"typeParameters":[]},{"name":"toString","comment":"Returns a string identifying this latch, as well as its state.\n The state, in brackets, includes the String {@code \"Count \u003d\"}\n followed by the current count.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":false,"simpleName":"String","qualifiedName":"java.lang.String","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[],"typeParameters":[]}],"typeParameters":[],"enumConstants":[]}