{"name":"RecursiveAction","comment":"A recursive resultless {@link ForkJoinTask}.  This class\n establishes conventions to parameterize resultless actions as\n {@code Void} {@code ForkJoinTask}s. Because {@code null} is the\n only valid value of type {@code Void}, methods such as {@code join}\n always return {@code null} upon completion.\n\n \u003cp\u003e\u003cb\u003eSample Usages.\u003c/b\u003e Here is a simple but complete ForkJoin\n sort that sorts a given {@code long[]} array:\n\n  \u003cpre\u003e {@code\n static class SortTask extends RecursiveAction {\n   final long[] array; final int lo, hi;\n   SortTask(long[] array, int lo, int hi) {\n     this.array \u003d array; this.lo \u003d lo; this.hi \u003d hi;\n   }\n   SortTask(long[] array) { this(array, 0, array.length); }\n   protected void compute() {\n     if (hi - lo \u003c THRESHOLD)\n       sortSequentially(lo, hi);\n     else {\n       int mid \u003d (lo + hi) \u003e\u003e\u003e 1;\n       invokeAll(new SortTask(array, lo, mid),\n                 new SortTask(array, mid, hi));\n       merge(lo, mid, hi);\n     }\n   }\n   // implementation details follow:\n   static final int THRESHOLD \u003d 1000;\n   void sortSequentially(int lo, int hi) {\n     Arrays.sort(array, lo, hi);\n   }\n   void merge(int lo, int mid, int hi) {\n     long[] buf \u003d Arrays.copyOfRange(array, lo, mid);\n     for (int i \u003d 0, j \u003d lo, k \u003d mid; i \u003c buf.length; j++)\n       array[j] \u003d (k \u003d\u003d hi || buf[i] \u003c array[k]) ?\n         buf[i++] : array[k++];\n   }\n }}\u003c/pre\u003e\n\n You could then sort {@code anArray} by creating {@code new\n SortTask(anArray)} and invoking it in a ForkJoinPool.  As a more\n concrete simple example, the following task increments each element\n of an array:\n  \u003cpre\u003e {@code\n class IncrementTask extends RecursiveAction {\n   final long[] array; final int lo, hi;\n   IncrementTask(long[] array, int lo, int hi) {\n     this.array \u003d array; this.lo \u003d lo; this.hi \u003d hi;\n   }\n   protected void compute() {\n     if (hi - lo \u003c THRESHOLD) {\n       for (int i \u003d lo; i \u003c hi; ++i)\n         array[i]++;\n     }\n     else {\n       int mid \u003d (lo + hi) \u003e\u003e\u003e 1;\n       invokeAll(new IncrementTask(array, lo, mid),\n                 new IncrementTask(array, mid, hi));\n     }\n   }\n }}\u003c/pre\u003e\n\n \u003cp\u003eThe following example illustrates some refinements and idioms\n that may lead to better performance: RecursiveActions need not be\n fully recursive, so long as they maintain the basic\n divide-and-conquer approach. Here is a class that sums the squares\n of each element of a double array, by subdividing out only the\n right-hand-sides of repeated divisions by two, and keeping track of\n them with a chain of {@code next} references. It uses a dynamic\n threshold based on method {@code getSurplusQueuedTaskCount}, but\n counterbalances potential excess partitioning by directly\n performing leaf actions on unstolen tasks rather than further\n subdividing.\n\n  \u003cpre\u003e {@code\n double sumOfSquares(ForkJoinPool pool, double[] array) {\n   int n \u003d array.length;\n   Applyer a \u003d new Applyer(array, 0, n, null);\n   pool.invoke(a);\n   return a.result;\n }\n\n class Applyer extends RecursiveAction {\n   final double[] array;\n   final int lo, hi;\n   double result;\n   Applyer next; // keeps track of right-hand-side tasks\n   Applyer(double[] array, int lo, int hi, Applyer next) {\n     this.array \u003d array; this.lo \u003d lo; this.hi \u003d hi;\n     this.next \u003d next;\n   }\n\n   double atLeaf(int l, int h) {\n     double sum \u003d 0;\n     for (int i \u003d l; i \u003c h; ++i) // perform leftmost base step\n       sum +\u003d array[i] * array[i];\n     return sum;\n   }\n\n   protected void compute() {\n     int l \u003d lo;\n     int h \u003d hi;\n     Applyer right \u003d null;\n     while (h - l \u003e 1 \u0026\u0026 getSurplusQueuedTaskCount() \u003c\u003d 3) {\n       int mid \u003d (l + h) \u003e\u003e\u003e 1;\n       right \u003d new Applyer(array, mid, h, right);\n       right.fork();\n       h \u003d mid;\n     }\n     double sum \u003d atLeaf(l, h);\n     while (right !\u003d null) {\n       if (right.tryUnfork()) // directly calculate if not stolen\n         sum +\u003d right.atLeaf(right.lo, right.hi);\n       else {\n         right.join();\n         sum +\u003d right.result;\n       }\n       right \u003d right.next;\n     }\n     result \u003d sum;\n   }\n }}\u003c/pre\u003e","isClass":true,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":false,"isOrdinaryClass":true,"isPrimitive":false,"simpleName":"RecursiveAction","qualifiedName":"java.util.concurrent.RecursiveAction","dimension":"","elementType":{},"package":"java.util.concurrent","superclass":"java.util.concurrent.ForkJoinTask","interfaces":[],"isAbstract":true,"isStatic":false,"since":"1.7","innerClasses":[],"isInnerClass":false,"constructors":[{"name":"RecursiveAction","comment":"","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":true,"isField":false,"isMethod":false,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","parameters":[],"typeParameters":[]}],"fields":[],"methods":[{"name":"getRawResult","comment":"Always returns {@code null}.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":false,"simpleName":"Void","qualifiedName":"java.lang.Void","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[],"typeParameters":[]}],"typeParameters":[],"enumConstants":[]}