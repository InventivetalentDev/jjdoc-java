{"name":"BlockingQueue","comment":"A {@link java.util.Queue} that additionally supports operations\n that wait for the queue to become non-empty when retrieving an\n element, and wait for space to become available in the queue when\n storing an element.\n\n \u003cp\u003e{@code BlockingQueue} methods come in four forms, with different ways\n of handling operations that cannot be satisfied immediately, but may be\n satisfied at some point in the future:\n one throws an exception, the second returns a special value (either\n {@code null} or {@code false}, depending on the operation), the third\n blocks the current thread indefinitely until the operation can succeed,\n and the fourth blocks for only a given maximum time limit before giving\n up.  These methods are summarized in the following table:\n\n \u003ctable BORDER CELLPADDING\u003d3 CELLSPACING\u003d1\u003e\n \u003ccaption\u003eSummary of BlockingQueue methods\u003c/caption\u003e\n  \u003ctr\u003e\n    \u003ctd\u003e\u003c/td\u003e\n    \u003ctd ALIGN\u003dCENTER\u003e\u003cem\u003eThrows exception\u003c/em\u003e\u003c/td\u003e\n    \u003ctd ALIGN\u003dCENTER\u003e\u003cem\u003eSpecial value\u003c/em\u003e\u003c/td\u003e\n    \u003ctd ALIGN\u003dCENTER\u003e\u003cem\u003eBlocks\u003c/em\u003e\u003c/td\u003e\n    \u003ctd ALIGN\u003dCENTER\u003e\u003cem\u003eTimes out\u003c/em\u003e\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003ctd\u003e\u003cb\u003eInsert\u003c/b\u003e\u003c/td\u003e\n    \u003ctd\u003e{@link #add add(e)}\u003c/td\u003e\n    \u003ctd\u003e{@link #offer offer(e)}\u003c/td\u003e\n    \u003ctd\u003e{@link #put put(e)}\u003c/td\u003e\n    \u003ctd\u003e{@link #offer(Object, long, TimeUnit) offer(e, time, unit)}\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003ctd\u003e\u003cb\u003eRemove\u003c/b\u003e\u003c/td\u003e\n    \u003ctd\u003e{@link #remove remove()}\u003c/td\u003e\n    \u003ctd\u003e{@link #poll poll()}\u003c/td\u003e\n    \u003ctd\u003e{@link #take take()}\u003c/td\u003e\n    \u003ctd\u003e{@link #poll(long, TimeUnit) poll(time, unit)}\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003ctd\u003e\u003cb\u003eExamine\u003c/b\u003e\u003c/td\u003e\n    \u003ctd\u003e{@link #element element()}\u003c/td\u003e\n    \u003ctd\u003e{@link #peek peek()}\u003c/td\u003e\n    \u003ctd\u003e\u003cem\u003enot applicable\u003c/em\u003e\u003c/td\u003e\n    \u003ctd\u003e\u003cem\u003enot applicable\u003c/em\u003e\u003c/td\u003e\n  \u003c/tr\u003e\n \u003c/table\u003e\n\n \u003cp\u003eA {@code BlockingQueue} does not accept {@code null} elements.\n Implementations throw {@code NullPointerException} on attempts\n to {@code add}, {@code put} or {@code offer} a {@code null}.  A\n {@code null} is used as a sentinel value to indicate failure of\n {@code poll} operations.\n\n \u003cp\u003eA {@code BlockingQueue} may be capacity bounded. At any given\n time it may have a {@code remainingCapacity} beyond which no\n additional elements can be {@code put} without blocking.\n A {@code BlockingQueue} without any intrinsic capacity constraints always\n reports a remaining capacity of {@code Integer.MAX_VALUE}.\n\n \u003cp\u003e{@code BlockingQueue} implementations are designed to be used\n primarily for producer-consumer queues, but additionally support\n the {@link java.util.Collection} interface.  So, for example, it is\n possible to remove an arbitrary element from a queue using\n {@code remove(x)}. However, such operations are in general\n \u003cem\u003enot\u003c/em\u003e performed very efficiently, and are intended for only\n occasional use, such as when a queued message is cancelled.\n\n \u003cp\u003e{@code BlockingQueue} implementations are thread-safe.  All\n queuing methods achieve their effects atomically using internal\n locks or other forms of concurrency control. However, the\n \u003cem\u003ebulk\u003c/em\u003e Collection operations {@code addAll},\n {@code containsAll}, {@code retainAll} and {@code removeAll} are\n \u003cem\u003enot\u003c/em\u003e necessarily performed atomically unless specified\n otherwise in an implementation. So it is possible, for example, for\n {@code addAll(c)} to fail (throwing an exception) after adding\n only some of the elements in {@code c}.\n\n \u003cp\u003eA {@code BlockingQueue} does \u003cem\u003enot\u003c/em\u003e intrinsically support\n any kind of \u0026quot;close\u0026quot; or \u0026quot;shutdown\u0026quot; operation to\n indicate that no more items will be added.  The needs and usage of\n such features tend to be implementation-dependent. For example, a\n common tactic is for producers to insert special\n \u003cem\u003eend-of-stream\u003c/em\u003e or \u003cem\u003epoison\u003c/em\u003e objects, that are\n interpreted accordingly when taken by consumers.\n\n \u003cp\u003e\n Usage example, based on a typical producer-consumer scenario.\n Note that a {@code BlockingQueue} can safely be used with multiple\n producers and multiple consumers.\n  \u003cpre\u003e {@code\n class Producer implements Runnable {\n   private final BlockingQueue queue;\n   Producer(BlockingQueue q) { queue \u003d q; }\n   public void run() {\n     try {\n       while (true) { queue.put(produce()); }\n     } catch (InterruptedException ex) { ... handle ...}\n   }\n   Object produce() { ... }\n }\n\n class Consumer implements Runnable {\n   private final BlockingQueue queue;\n   Consumer(BlockingQueue q) { queue \u003d q; }\n   public void run() {\n     try {\n       while (true) { consume(queue.take()); }\n     } catch (InterruptedException ex) { ... handle ...}\n   }\n   void consume(Object x) { ... }\n }\n\n class Setup {\n   void main() {\n     BlockingQueue q \u003d new SomeQueueImplementation();\n     Producer p \u003d new Producer(q);\n     Consumer c1 \u003d new Consumer(q);\n     Consumer c2 \u003d new Consumer(q);\n     new Thread(p).start();\n     new Thread(c1).start();\n     new Thread(c2).start();\n   }\n }}\u003c/pre\u003e\n\n \u003cp\u003eMemory consistency effects: As with other concurrent\n collections, actions in a thread prior to placing an object into a\n {@code BlockingQueue}\n \u003ca href\u003d\"package-summary.html#MemoryVisibility\"\u003e\u003ci\u003ehappen-before\u003c/i\u003e\u003c/a\u003e\n actions subsequent to the access or removal of that element from\n the {@code BlockingQueue} in another thread.\n\n \u003cp\u003eThis interface is a member of the\n \u003ca href\u003d\"{@docRoot}/../technotes/guides/collections/index.html\"\u003e\n Java Collections Framework\u003c/a\u003e.","isClass":false,"isInterface":true,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":false,"isOrdinaryClass":false,"isPrimitive":false,"simpleName":"BlockingQueue","qualifiedName":"java.util.concurrent.BlockingQueue","dimension":"","elementType":{},"package":"java.util.concurrent","interfaces":["java.util.Queue"],"isAbstract":true,"isStatic":false,"since":"1.5","innerClasses":[],"isInnerClass":false,"constructors":[],"fields":[],"methods":[{"name":"add","comment":"Inserts the specified element into this queue if it is possible to do\n so immediately without violating capacity restrictions, returning\n {@code true} upon success and throwing an\n {@code IllegalStateException} if no space is currently available.\n When using a capacity-restricted queue, it is generally preferable to\n use {@link #offer(Object) offer}.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(E)","flatSignature":"(E)","returnType":{"isPrimitive":true,"simpleName":"boolean","qualifiedName":"boolean","dimension":"","elementType":{}},"isAbstract":true,"isDefault":false,"isStatic":false,"parameters":[{"name":"e","type":{"isPrimitive":false,"simpleName":"E","qualifiedName":"E","dimension":"","elementType":{},"typeVariable":{"name":"E","bounds":[]}}}],"typeParameters":[]},{"name":"offer","comment":"Inserts the specified element into this queue if it is possible to do\n so immediately without violating capacity restrictions, returning\n {@code true} upon success and {@code false} if no space is currently\n available.  When using a capacity-restricted queue, this method is\n generally preferable to {@link #add}, which can fail to insert an\n element only by throwing an exception.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(E)","flatSignature":"(E)","returnType":{"isPrimitive":true,"simpleName":"boolean","qualifiedName":"boolean","dimension":"","elementType":{}},"isAbstract":true,"isDefault":false,"isStatic":false,"parameters":[{"name":"e","type":{"isPrimitive":false,"simpleName":"E","qualifiedName":"E","dimension":"","elementType":{},"typeVariable":{"name":"E","bounds":[]}}}],"typeParameters":[]},{"name":"put","comment":"Inserts the specified element into this queue, waiting if necessary\n for space to become available.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(E)","flatSignature":"(E)","returnType":{"isPrimitive":true,"simpleName":"void","qualifiedName":"void","dimension":"","elementType":{}},"isAbstract":true,"isDefault":false,"isStatic":false,"parameters":[{"name":"e","type":{"isPrimitive":false,"simpleName":"E","qualifiedName":"E","dimension":"","elementType":{},"typeVariable":{"name":"E","bounds":[]}}}],"typeParameters":[]},{"name":"offer","comment":"Inserts the specified element into this queue, waiting up to the\n specified wait time if necessary for space to become available.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(E, long, java.util.concurrent.TimeUnit)","flatSignature":"(E, long, TimeUnit)","returnType":{"isPrimitive":true,"simpleName":"boolean","qualifiedName":"boolean","dimension":"","elementType":{}},"isAbstract":true,"isDefault":false,"isStatic":false,"parameters":[{"name":"e","type":{"isPrimitive":false,"simpleName":"E","qualifiedName":"E","dimension":"","elementType":{},"typeVariable":{"name":"E","bounds":[]}}},{"name":"timeout","type":{"isPrimitive":true,"simpleName":"long","qualifiedName":"long","dimension":"","elementType":{}}},{"name":"unit","type":{"isPrimitive":false,"simpleName":"TimeUnit","qualifiedName":"java.util.concurrent.TimeUnit","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"take","comment":"Retrieves and removes the head of this queue, waiting if necessary\n until an element becomes available.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":false,"simpleName":"E","qualifiedName":"E","dimension":"","elementType":{},"typeVariable":{"name":"E","bounds":[]}},"isAbstract":true,"isDefault":false,"isStatic":false,"parameters":[],"typeParameters":[]},{"name":"poll","comment":"Retrieves and removes the head of this queue, waiting up to the\n specified wait time if necessary for an element to become available.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(long, java.util.concurrent.TimeUnit)","flatSignature":"(long, TimeUnit)","returnType":{"isPrimitive":false,"simpleName":"E","qualifiedName":"E","dimension":"","elementType":{},"typeVariable":{"name":"E","bounds":[]}},"isAbstract":true,"isDefault":false,"isStatic":false,"parameters":[{"name":"timeout","type":{"isPrimitive":true,"simpleName":"long","qualifiedName":"long","dimension":"","elementType":{}}},{"name":"unit","type":{"isPrimitive":false,"simpleName":"TimeUnit","qualifiedName":"java.util.concurrent.TimeUnit","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"remainingCapacity","comment":"Returns the number of additional elements that this queue can ideally\n (in the absence of memory or resource constraints) accept without\n blocking, or {@code Integer.MAX_VALUE} if there is no intrinsic\n limit.\n\n \u003cp\u003eNote that you \u003cem\u003ecannot\u003c/em\u003e always tell if an attempt to insert\n an element will succeed by inspecting {@code remainingCapacity}\n because it may be the case that another thread is about to\n insert or remove an element.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}},"isAbstract":true,"isDefault":false,"isStatic":false,"parameters":[],"typeParameters":[]},{"name":"remove","comment":"Removes a single instance of the specified element from this queue,\n if it is present.  More formally, removes an element {@code e} such\n that {@code o.equals(e)}, if this queue contains one or more such\n elements.\n Returns {@code true} if this queue contained the specified element\n (or equivalently, if this queue changed as a result of the call).","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.lang.Object)","flatSignature":"(Object)","returnType":{"isPrimitive":true,"simpleName":"boolean","qualifiedName":"boolean","dimension":"","elementType":{}},"isAbstract":true,"isDefault":false,"isStatic":false,"parameters":[{"name":"o","type":{"isPrimitive":false,"simpleName":"Object","qualifiedName":"java.lang.Object","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"contains","comment":"Returns {@code true} if this queue contains the specified element.\n More formally, returns {@code true} if and only if this queue contains\n at least one element {@code e} such that {@code o.equals(e)}.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.lang.Object)","flatSignature":"(Object)","returnType":{"isPrimitive":true,"simpleName":"boolean","qualifiedName":"boolean","dimension":"","elementType":{}},"isAbstract":true,"isDefault":false,"isStatic":false,"parameters":[{"name":"o","type":{"isPrimitive":false,"simpleName":"Object","qualifiedName":"java.lang.Object","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"drainTo","comment":"Removes all available elements from this queue and adds them\n to the given collection.  This operation may be more\n efficient than repeatedly polling this queue.  A failure\n encountered while attempting to add elements to\n collection {@code c} may result in elements being in neither,\n either or both collections when the associated exception is\n thrown.  Attempts to drain a queue to itself result in\n {@code IllegalArgumentException}. Further, the behavior of\n this operation is undefined if the specified collection is\n modified while the operation is in progress.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.util.Collection\u003c? super E\u003e)","flatSignature":"(Collection\u003c? super E\u003e)","returnType":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}},"isAbstract":true,"isDefault":false,"isStatic":false,"parameters":[{"name":"c","type":{"isPrimitive":false,"simpleName":"Collection","qualifiedName":"java.util.Collection","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"drainTo","comment":"Removes at most the given number of available elements from\n this queue and adds them to the given collection.  A failure\n encountered while attempting to add elements to\n collection {@code c} may result in elements being in neither,\n either or both collections when the associated exception is\n thrown.  Attempts to drain a queue to itself result in\n {@code IllegalArgumentException}. Further, the behavior of\n this operation is undefined if the specified collection is\n modified while the operation is in progress.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.util.Collection\u003c? super E\u003e, int)","flatSignature":"(Collection\u003c? super E\u003e, int)","returnType":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}},"isAbstract":true,"isDefault":false,"isStatic":false,"parameters":[{"name":"c","type":{"isPrimitive":false,"simpleName":"Collection","qualifiedName":"java.util.Collection","dimension":"","elementType":{}}},{"name":"maxElements","type":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}}}],"typeParameters":[]}],"typeParameters":[{"name":"E","bounds":[]}],"subInterfaces":["java.util.concurrent.TransferQueue","java.util.concurrent.SynchronousQueue","java.util.concurrent.PriorityBlockingQueue","java.util.concurrent.LinkedBlockingQueue","java.util.concurrent.BlockingDeque","java.util.concurrent.DelayQueue","java.util.concurrent.ArrayBlockingQueue"],"enumConstants":[]}