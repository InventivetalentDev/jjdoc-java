{"name":"ForkJoinPool.ManagedBlocker","comment":"Interface for extending managed parallelism for tasks running\n in {@link ForkJoinPool}s.\n\n \u003cp\u003eA {@code ManagedBlocker} provides two methods.  Method\n {@link #isReleasable} must return {@code true} if blocking is\n not necessary. Method {@link #block} blocks the current thread\n if necessary (perhaps internally invoking {@code isReleasable}\n before actually blocking). These actions are performed by any\n thread invoking {@link ForkJoinPool#managedBlock(ManagedBlocker)}.\n The unusual methods in this API accommodate synchronizers that\n may, but don\u0027t usually, block for long periods. Similarly, they\n allow more efficient internal handling of cases in which\n additional workers may be, but usually are not, needed to\n ensure sufficient parallelism.  Toward this end,\n implementations of method {@code isReleasable} must be amenable\n to repeated invocation.\n\n \u003cp\u003eFor example, here is a ManagedBlocker based on a\n ReentrantLock:\n  \u003cpre\u003e {@code\n class ManagedLocker implements ManagedBlocker {\n   final ReentrantLock lock;\n   boolean hasLock \u003d false;\n   ManagedLocker(ReentrantLock lock) { this.lock \u003d lock; }\n   public boolean block() {\n     if (!hasLock)\n       lock.lock();\n     return true;\n   }\n   public boolean isReleasable() {\n     return hasLock || (hasLock \u003d lock.tryLock());\n   }\n }}\u003c/pre\u003e\n\n \u003cp\u003eHere is a class that possibly blocks waiting for an\n item on a given queue:\n  \u003cpre\u003e {@code\n class QueueTaker\u003cE\u003e implements ManagedBlocker {\n   final BlockingQueue\u003cE\u003e queue;\n   volatile E item \u003d null;\n   QueueTaker(BlockingQueue\u003cE\u003e q) { this.queue \u003d q; }\n   public boolean block() throws InterruptedException {\n     if (item \u003d\u003d null)\n       item \u003d queue.take();\n     return true;\n   }\n   public boolean isReleasable() {\n     return item !\u003d null || (item \u003d queue.poll()) !\u003d null;\n   }\n   public E getItem() { // call after pool.managedBlock completes\n     return item;\n   }\n }}\u003c/pre\u003e","isClass":false,"isInterface":true,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":false,"isOrdinaryClass":false,"isPrimitive":false,"simpleName":"ManagedBlocker","qualifiedName":"java.util.concurrent.ForkJoinPool.ManagedBlocker","dimension":"","elementType":{},"package":"java.util.concurrent","interfaces":[],"isAbstract":true,"isStatic":true,"innerClasses":[],"isInnerClass":true,"constructors":[],"fields":[],"methods":[{"name":"block","comment":"Possibly blocks the current thread, for example waiting for\n a lock or condition.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":true,"simpleName":"boolean","qualifiedName":"boolean","dimension":"","elementType":{}},"isAbstract":true,"isDefault":false,"isStatic":false,"parameters":[],"typeParameters":[]},{"name":"isReleasable","comment":"Returns {@code true} if blocking is unnecessary.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":true,"simpleName":"boolean","qualifiedName":"boolean","dimension":"","elementType":{}},"isAbstract":true,"isDefault":false,"isStatic":false,"parameters":[],"typeParameters":[]}],"typeParameters":[],"enumConstants":[]}