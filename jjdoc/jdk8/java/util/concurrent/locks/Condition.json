{"name":"Condition","comment":"{@code Condition} factors out the {@code Object} monitor\n methods ({@link Object#wait() wait}, {@link Object#notify notify}\n and {@link Object#notifyAll notifyAll}) into distinct objects to\n give the effect of having multiple wait-sets per object, by\n combining them with the use of arbitrary {@link Lock} implementations.\n Where a {@code Lock} replaces the use of {@code synchronized} methods\n and statements, a {@code Condition} replaces the use of the Object\n monitor methods.\n\n \u003cp\u003eConditions (also known as \u003cem\u003econdition queues\u003c/em\u003e or\n \u003cem\u003econdition variables\u003c/em\u003e) provide a means for one thread to\n suspend execution (to \u0026quot;wait\u0026quot;) until notified by another\n thread that some state condition may now be true.  Because access\n to this shared state information occurs in different threads, it\n must be protected, so a lock of some form is associated with the\n condition. The key property that waiting for a condition provides\n is that it \u003cem\u003eatomically\u003c/em\u003e releases the associated lock and\n suspends the current thread, just like {@code Object.wait}.\n\n \u003cp\u003eA {@code Condition} instance is intrinsically bound to a lock.\n To obtain a {@code Condition} instance for a particular {@link Lock}\n instance use its {@link Lock#newCondition newCondition()} method.\n\n \u003cp\u003eAs an example, suppose we have a bounded buffer which supports\n {@code put} and {@code take} methods.  If a\n {@code take} is attempted on an empty buffer, then the thread will block\n until an item becomes available; if a {@code put} is attempted on a\n full buffer, then the thread will block until a space becomes available.\n We would like to keep waiting {@code put} threads and {@code take}\n threads in separate wait-sets so that we can use the optimization of\n only notifying a single thread at a time when items or spaces become\n available in the buffer. This can be achieved using two\n {@link Condition} instances.\n \u003cpre\u003e\n class BoundedBuffer {\n   \u003cb\u003efinal Lock lock \u003d new ReentrantLock();\u003c/b\u003e\n   final Condition notFull  \u003d \u003cb\u003elock.newCondition(); \u003c/b\u003e\n   final Condition notEmpty \u003d \u003cb\u003elock.newCondition(); \u003c/b\u003e\n\n   final Object[] items \u003d new Object[100];\n   int putptr, takeptr, count;\n\n   public void put(Object x) throws InterruptedException {\n     \u003cb\u003elock.lock();\n     try {\u003c/b\u003e\n       while (count \u003d\u003d items.length)\n         \u003cb\u003enotFull.await();\u003c/b\u003e\n       items[putptr] \u003d x;\n       if (++putptr \u003d\u003d items.length) putptr \u003d 0;\n       ++count;\n       \u003cb\u003enotEmpty.signal();\u003c/b\u003e\n     \u003cb\u003e} finally {\n       lock.unlock();\n     }\u003c/b\u003e\n   }\n\n   public Object take() throws InterruptedException {\n     \u003cb\u003elock.lock();\n     try {\u003c/b\u003e\n       while (count \u003d\u003d 0)\n         \u003cb\u003enotEmpty.await();\u003c/b\u003e\n       Object x \u003d items[takeptr];\n       if (++takeptr \u003d\u003d items.length) takeptr \u003d 0;\n       --count;\n       \u003cb\u003enotFull.signal();\u003c/b\u003e\n       return x;\n     \u003cb\u003e} finally {\n       lock.unlock();\n     }\u003c/b\u003e\n   }\n }\n \u003c/pre\u003e\n\n (The {@link java.util.concurrent.ArrayBlockingQueue} class provides\n this functionality, so there is no reason to implement this\n sample usage class.)\n\n \u003cp\u003eA {@code Condition} implementation can provide behavior and semantics\n that is\n different from that of the {@code Object} monitor methods, such as\n guaranteed ordering for notifications, or not requiring a lock to be held\n when performing notifications.\n If an implementation provides such specialized semantics then the\n implementation must document those semantics.\n\n \u003cp\u003eNote that {@code Condition} instances are just normal objects and can\n themselves be used as the target in a {@code synchronized} statement,\n and can have their own monitor {@link Object#wait wait} and\n {@link Object#notify notification} methods invoked.\n Acquiring the monitor lock of a {@code Condition} instance, or using its\n monitor methods, has no specified relationship with acquiring the\n {@link Lock} associated with that {@code Condition} or the use of its\n {@linkplain #await waiting} and {@linkplain #signal signalling} methods.\n It is recommended that to avoid confusion you never use {@code Condition}\n instances in this way, except perhaps within their own implementation.\n\n \u003cp\u003eExcept where noted, passing a {@code null} value for any parameter\n will result in a {@link NullPointerException} being thrown.\n\n \u003ch3\u003eImplementation Considerations\u003c/h3\u003e\n\n \u003cp\u003eWhen waiting upon a {@code Condition}, a \u0026quot;\u003cem\u003espurious\n wakeup\u003c/em\u003e\u0026quot; is permitted to occur, in\n general, as a concession to the underlying platform semantics.\n This has little practical impact on most application programs as a\n {@code Condition} should always be waited upon in a loop, testing\n the state predicate that is being waited for.  An implementation is\n free to remove the possibility of spurious wakeups but it is\n recommended that applications programmers always assume that they can\n occur and so always wait in a loop.\n\n \u003cp\u003eThe three forms of condition waiting\n (interruptible, non-interruptible, and timed) may differ in their ease of\n implementation on some platforms and in their performance characteristics.\n In particular, it may be difficult to provide these features and maintain\n specific semantics such as ordering guarantees.\n Further, the ability to interrupt the actual suspension of the thread may\n not always be feasible to implement on all platforms.\n\n \u003cp\u003eConsequently, an implementation is not required to define exactly the\n same guarantees or semantics for all three forms of waiting, nor is it\n required to support interruption of the actual suspension of the thread.\n\n \u003cp\u003eAn implementation is required to\n clearly document the semantics and guarantees provided by each of the\n waiting methods, and when an implementation does support interruption of\n thread suspension then it must obey the interruption semantics as defined\n in this interface.\n\n \u003cp\u003eAs interruption generally implies cancellation, and checks for\n interruption are often infrequent, an implementation can favor responding\n to an interrupt over normal method return. This is true even if it can be\n shown that the interrupt occurred after another action that may have\n unblocked the thread. An implementation should document this behavior.","isClass":false,"isInterface":true,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":false,"isOrdinaryClass":false,"isPrimitive":false,"simpleName":"Condition","qualifiedName":"java.util.concurrent.locks.Condition","dimension":"","elementType":{},"package":"java.util.concurrent.locks","interfaces":[],"isAbstract":true,"isStatic":false,"since":"1.5","innerClasses":[],"isInnerClass":false,"constructors":[],"fields":[],"methods":[{"name":"await","comment":"Causes the current thread to wait until it is signalled or\n {@linkplain Thread#interrupt interrupted}.\n\n \u003cp\u003eThe lock associated with this {@code Condition} is atomically\n released and the current thread becomes disabled for thread scheduling\n purposes and lies dormant until \u003cem\u003eone\u003c/em\u003e of four things happens:\n \u003cul\u003e\n \u003cli\u003eSome other thread invokes the {@link #signal} method for this\n {@code Condition} and the current thread happens to be chosen as the\n thread to be awakened; or\n \u003cli\u003eSome other thread invokes the {@link #signalAll} method for this\n {@code Condition}; or\n \u003cli\u003eSome other thread {@linkplain Thread#interrupt interrupts} the\n current thread, and interruption of thread suspension is supported; or\n \u003cli\u003eA \u0026quot;\u003cem\u003espurious wakeup\u003c/em\u003e\u0026quot; occurs.\n \u003c/ul\u003e\n\n \u003cp\u003eIn all cases, before this method can return the current thread must\n re-acquire the lock associated with this condition. When the\n thread returns it is \u003cem\u003eguaranteed\u003c/em\u003e to hold this lock.\n\n \u003cp\u003eIf the current thread:\n \u003cul\u003e\n \u003cli\u003ehas its interrupted status set on entry to this method; or\n \u003cli\u003eis {@linkplain Thread#interrupt interrupted} while waiting\n and interruption of thread suspension is supported,\n \u003c/ul\u003e\n then {@link InterruptedException} is thrown and the current thread\u0027s\n interrupted status is cleared. It is not specified, in the first\n case, whether or not the test for interruption occurs before the lock\n is released.\n\n \u003cp\u003e\u003cb\u003eImplementation Considerations\u003c/b\u003e\n\n \u003cp\u003eThe current thread is assumed to hold the lock associated with this\n {@code Condition} when this method is called.\n It is up to the implementation to determine if this is\n the case and if not, how to respond. Typically, an exception will be\n thrown (such as {@link IllegalMonitorStateException}) and the\n implementation must document that fact.\n\n \u003cp\u003eAn implementation can favor responding to an interrupt over normal\n method return in response to a signal. In that case the implementation\n must ensure that the signal is redirected to another waiting thread, if\n there is one.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":true,"simpleName":"void","qualifiedName":"void","dimension":"","elementType":{}},"isAbstract":true,"isDefault":false,"isStatic":false,"parameters":[],"typeParameters":[]},{"name":"awaitUninterruptibly","comment":"Causes the current thread to wait until it is signalled.\n\n \u003cp\u003eThe lock associated with this condition is atomically\n released and the current thread becomes disabled for thread scheduling\n purposes and lies dormant until \u003cem\u003eone\u003c/em\u003e of three things happens:\n \u003cul\u003e\n \u003cli\u003eSome other thread invokes the {@link #signal} method for this\n {@code Condition} and the current thread happens to be chosen as the\n thread to be awakened; or\n \u003cli\u003eSome other thread invokes the {@link #signalAll} method for this\n {@code Condition}; or\n \u003cli\u003eA \u0026quot;\u003cem\u003espurious wakeup\u003c/em\u003e\u0026quot; occurs.\n \u003c/ul\u003e\n\n \u003cp\u003eIn all cases, before this method can return the current thread must\n re-acquire the lock associated with this condition. When the\n thread returns it is \u003cem\u003eguaranteed\u003c/em\u003e to hold this lock.\n\n \u003cp\u003eIf the current thread\u0027s interrupted status is set when it enters\n this method, or it is {@linkplain Thread#interrupt interrupted}\n while waiting, it will continue to wait until signalled. When it finally\n returns from this method its interrupted status will still\n be set.\n\n \u003cp\u003e\u003cb\u003eImplementation Considerations\u003c/b\u003e\n\n \u003cp\u003eThe current thread is assumed to hold the lock associated with this\n {@code Condition} when this method is called.\n It is up to the implementation to determine if this is\n the case and if not, how to respond. Typically, an exception will be\n thrown (such as {@link IllegalMonitorStateException}) and the\n implementation must document that fact.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":true,"simpleName":"void","qualifiedName":"void","dimension":"","elementType":{}},"isAbstract":true,"isDefault":false,"isStatic":false,"parameters":[],"typeParameters":[]},{"name":"awaitNanos","comment":"Causes the current thread to wait until it is signalled or interrupted,\n or the specified waiting time elapses.\n\n \u003cp\u003eThe lock associated with this condition is atomically\n released and the current thread becomes disabled for thread scheduling\n purposes and lies dormant until \u003cem\u003eone\u003c/em\u003e of five things happens:\n \u003cul\u003e\n \u003cli\u003eSome other thread invokes the {@link #signal} method for this\n {@code Condition} and the current thread happens to be chosen as the\n thread to be awakened; or\n \u003cli\u003eSome other thread invokes the {@link #signalAll} method for this\n {@code Condition}; or\n \u003cli\u003eSome other thread {@linkplain Thread#interrupt interrupts} the\n current thread, and interruption of thread suspension is supported; or\n \u003cli\u003eThe specified waiting time elapses; or\n \u003cli\u003eA \u0026quot;\u003cem\u003espurious wakeup\u003c/em\u003e\u0026quot; occurs.\n \u003c/ul\u003e\n\n \u003cp\u003eIn all cases, before this method can return the current thread must\n re-acquire the lock associated with this condition. When the\n thread returns it is \u003cem\u003eguaranteed\u003c/em\u003e to hold this lock.\n\n \u003cp\u003eIf the current thread:\n \u003cul\u003e\n \u003cli\u003ehas its interrupted status set on entry to this method; or\n \u003cli\u003eis {@linkplain Thread#interrupt interrupted} while waiting\n and interruption of thread suspension is supported,\n \u003c/ul\u003e\n then {@link InterruptedException} is thrown and the current thread\u0027s\n interrupted status is cleared. It is not specified, in the first\n case, whether or not the test for interruption occurs before the lock\n is released.\n\n \u003cp\u003eThe method returns an estimate of the number of nanoseconds\n remaining to wait given the supplied {@code nanosTimeout}\n value upon return, or a value less than or equal to zero if it\n timed out. This value can be used to determine whether and how\n long to re-wait in cases where the wait returns but an awaited\n condition still does not hold. Typical uses of this method take\n the following form:\n\n  \u003cpre\u003e {@code\n boolean aMethod(long timeout, TimeUnit unit) {\n   long nanos \u003d unit.toNanos(timeout);\n   lock.lock();\n   try {\n     while (!conditionBeingWaitedFor()) {\n       if (nanos \u003c\u003d 0L)\n         return false;\n       nanos \u003d theCondition.awaitNanos(nanos);\n     }\n     // ...\n   } finally {\n     lock.unlock();\n   }\n }}\u003c/pre\u003e\n\n \u003cp\u003eDesign note: This method requires a nanosecond argument so\n as to avoid truncation errors in reporting remaining times.\n Such precision loss would make it difficult for programmers to\n ensure that total waiting times are not systematically shorter\n than specified when re-waits occur.\n\n \u003cp\u003e\u003cb\u003eImplementation Considerations\u003c/b\u003e\n\n \u003cp\u003eThe current thread is assumed to hold the lock associated with this\n {@code Condition} when this method is called.\n It is up to the implementation to determine if this is\n the case and if not, how to respond. Typically, an exception will be\n thrown (such as {@link IllegalMonitorStateException}) and the\n implementation must document that fact.\n\n \u003cp\u003eAn implementation can favor responding to an interrupt over normal\n method return in response to a signal, or over indicating the elapse\n of the specified waiting time. In either case the implementation\n must ensure that the signal is redirected to another waiting thread, if\n there is one.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(long)","flatSignature":"(long)","returnType":{"isPrimitive":true,"simpleName":"long","qualifiedName":"long","dimension":"","elementType":{}},"isAbstract":true,"isDefault":false,"isStatic":false,"parameters":[{"name":"nanosTimeout","type":{"isPrimitive":true,"simpleName":"long","qualifiedName":"long","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"await","comment":"Causes the current thread to wait until it is signalled or interrupted,\n or the specified waiting time elapses. This method is behaviorally\n equivalent to:\n  \u003cpre\u003e {@code awaitNanos(unit.toNanos(time)) \u003e 0}\u003c/pre\u003e","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(long, java.util.concurrent.TimeUnit)","flatSignature":"(long, TimeUnit)","returnType":{"isPrimitive":true,"simpleName":"boolean","qualifiedName":"boolean","dimension":"","elementType":{}},"isAbstract":true,"isDefault":false,"isStatic":false,"parameters":[{"name":"time","type":{"isPrimitive":true,"simpleName":"long","qualifiedName":"long","dimension":"","elementType":{}}},{"name":"unit","type":{"isPrimitive":false,"simpleName":"TimeUnit","qualifiedName":"java.util.concurrent.TimeUnit","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"awaitUntil","comment":"Causes the current thread to wait until it is signalled or interrupted,\n or the specified deadline elapses.\n\n \u003cp\u003eThe lock associated with this condition is atomically\n released and the current thread becomes disabled for thread scheduling\n purposes and lies dormant until \u003cem\u003eone\u003c/em\u003e of five things happens:\n \u003cul\u003e\n \u003cli\u003eSome other thread invokes the {@link #signal} method for this\n {@code Condition} and the current thread happens to be chosen as the\n thread to be awakened; or\n \u003cli\u003eSome other thread invokes the {@link #signalAll} method for this\n {@code Condition}; or\n \u003cli\u003eSome other thread {@linkplain Thread#interrupt interrupts} the\n current thread, and interruption of thread suspension is supported; or\n \u003cli\u003eThe specified deadline elapses; or\n \u003cli\u003eA \u0026quot;\u003cem\u003espurious wakeup\u003c/em\u003e\u0026quot; occurs.\n \u003c/ul\u003e\n\n \u003cp\u003eIn all cases, before this method can return the current thread must\n re-acquire the lock associated with this condition. When the\n thread returns it is \u003cem\u003eguaranteed\u003c/em\u003e to hold this lock.\n\n\n \u003cp\u003eIf the current thread:\n \u003cul\u003e\n \u003cli\u003ehas its interrupted status set on entry to this method; or\n \u003cli\u003eis {@linkplain Thread#interrupt interrupted} while waiting\n and interruption of thread suspension is supported,\n \u003c/ul\u003e\n then {@link InterruptedException} is thrown and the current thread\u0027s\n interrupted status is cleared. It is not specified, in the first\n case, whether or not the test for interruption occurs before the lock\n is released.\n\n\n \u003cp\u003eThe return value indicates whether the deadline has elapsed,\n which can be used as follows:\n  \u003cpre\u003e {@code\n boolean aMethod(Date deadline) {\n   boolean stillWaiting \u003d true;\n   lock.lock();\n   try {\n     while (!conditionBeingWaitedFor()) {\n       if (!stillWaiting)\n         return false;\n       stillWaiting \u003d theCondition.awaitUntil(deadline);\n     }\n     // ...\n   } finally {\n     lock.unlock();\n   }\n }}\u003c/pre\u003e\n\n \u003cp\u003e\u003cb\u003eImplementation Considerations\u003c/b\u003e\n\n \u003cp\u003eThe current thread is assumed to hold the lock associated with this\n {@code Condition} when this method is called.\n It is up to the implementation to determine if this is\n the case and if not, how to respond. Typically, an exception will be\n thrown (such as {@link IllegalMonitorStateException}) and the\n implementation must document that fact.\n\n \u003cp\u003eAn implementation can favor responding to an interrupt over normal\n method return in response to a signal, or over indicating the passing\n of the specified deadline. In either case the implementation\n must ensure that the signal is redirected to another waiting thread, if\n there is one.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.util.Date)","flatSignature":"(Date)","returnType":{"isPrimitive":true,"simpleName":"boolean","qualifiedName":"boolean","dimension":"","elementType":{}},"isAbstract":true,"isDefault":false,"isStatic":false,"parameters":[{"name":"deadline","type":{"isPrimitive":false,"simpleName":"Date","qualifiedName":"java.util.Date","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"signal","comment":"Wakes up one waiting thread.\n\n \u003cp\u003eIf any threads are waiting on this condition then one\n is selected for waking up. That thread must then re-acquire the\n lock before returning from {@code await}.\n\n \u003cp\u003e\u003cb\u003eImplementation Considerations\u003c/b\u003e\n\n \u003cp\u003eAn implementation may (and typically does) require that the\n current thread hold the lock associated with this {@code\n Condition} when this method is called. Implementations must\n document this precondition and any actions taken if the lock is\n not held. Typically, an exception such as {@link\n IllegalMonitorStateException} will be thrown.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":true,"simpleName":"void","qualifiedName":"void","dimension":"","elementType":{}},"isAbstract":true,"isDefault":false,"isStatic":false,"parameters":[],"typeParameters":[]},{"name":"signalAll","comment":"Wakes up all waiting threads.\n\n \u003cp\u003eIf any threads are waiting on this condition then they are\n all woken up. Each thread must re-acquire the lock before it can\n return from {@code await}.\n\n \u003cp\u003e\u003cb\u003eImplementation Considerations\u003c/b\u003e\n\n \u003cp\u003eAn implementation may (and typically does) require that the\n current thread hold the lock associated with this {@code\n Condition} when this method is called. Implementations must\n document this precondition and any actions taken if the lock is\n not held. Typically, an exception such as {@link\n IllegalMonitorStateException} will be thrown.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":true,"simpleName":"void","qualifiedName":"void","dimension":"","elementType":{}},"isAbstract":true,"isDefault":false,"isStatic":false,"parameters":[],"typeParameters":[]}],"typeParameters":[],"subInterfaces":["java.util.concurrent.locks.AbstractQueuedSynchronizer.ConditionObject","java.util.concurrent.locks.AbstractQueuedLongSynchronizer.ConditionObject"],"enumConstants":[]}