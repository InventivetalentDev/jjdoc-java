{"name":"Phaser","comment":"A reusable synchronization barrier, similar in functionality to\n {@link java.util.concurrent.CyclicBarrier CyclicBarrier} and\n {@link java.util.concurrent.CountDownLatch CountDownLatch}\n but supporting more flexible usage.\n\n \u003cp\u003e\u003cb\u003eRegistration.\u003c/b\u003e Unlike the case for other barriers, the\n number of parties \u003cem\u003eregistered\u003c/em\u003e to synchronize on a phaser\n may vary over time.  Tasks may be registered at any time (using\n methods {@link #register}, {@link #bulkRegister}, or forms of\n constructors establishing initial numbers of parties), and\n optionally deregistered upon any arrival (using {@link\n #arriveAndDeregister}).  As is the case with most basic\n synchronization constructs, registration and deregistration affect\n only internal counts; they do not establish any further internal\n bookkeeping, so tasks cannot query whether they are registered.\n (However, you can introduce such bookkeeping by subclassing this\n class.)\n\n \u003cp\u003e\u003cb\u003eSynchronization.\u003c/b\u003e Like a {@code CyclicBarrier}, a {@code\n Phaser} may be repeatedly awaited.  Method {@link\n #arriveAndAwaitAdvance} has effect analogous to {@link\n java.util.concurrent.CyclicBarrier#await CyclicBarrier.await}. Each\n generation of a phaser has an associated phase number. The phase\n number starts at zero, and advances when all parties arrive at the\n phaser, wrapping around to zero after reaching {@code\n Integer.MAX_VALUE}. The use of phase numbers enables independent\n control of actions upon arrival at a phaser and upon awaiting\n others, via two kinds of methods that may be invoked by any\n registered party:\n\n \u003cul\u003e\n\n   \u003cli\u003e \u003cb\u003eArrival.\u003c/b\u003e Methods {@link #arrive} and\n       {@link #arriveAndDeregister} record arrival.  These methods\n       do not block, but return an associated \u003cem\u003earrival phase\n       number\u003c/em\u003e; that is, the phase number of the phaser to which\n       the arrival applied. When the final party for a given phase\n       arrives, an optional action is performed and the phase\n       advances.  These actions are performed by the party\n       triggering a phase advance, and are arranged by overriding\n       method {@link #onAdvance(int, int)}, which also controls\n       termination. Overriding this method is similar to, but more\n       flexible than, providing a barrier action to a {@code\n       CyclicBarrier}.\n\n   \u003cli\u003e \u003cb\u003eWaiting.\u003c/b\u003e Method {@link #awaitAdvance} requires an\n       argument indicating an arrival phase number, and returns when\n       the phaser advances to (or is already at) a different phase.\n       Unlike similar constructions using {@code CyclicBarrier},\n       method {@code awaitAdvance} continues to wait even if the\n       waiting thread is interrupted. Interruptible and timeout\n       versions are also available, but exceptions encountered while\n       tasks wait interruptibly or with timeout do not change the\n       state of the phaser. If necessary, you can perform any\n       associated recovery within handlers of those exceptions,\n       often after invoking {@code forceTermination}.  Phasers may\n       also be used by tasks executing in a {@link ForkJoinPool},\n       which will ensure sufficient parallelism to execute tasks\n       when others are blocked waiting for a phase to advance.\n\n \u003c/ul\u003e\n\n \u003cp\u003e\u003cb\u003eTermination.\u003c/b\u003e A phaser may enter a \u003cem\u003etermination\u003c/em\u003e\n state, that may be checked using method {@link #isTerminated}. Upon\n termination, all synchronization methods immediately return without\n waiting for advance, as indicated by a negative return value.\n Similarly, attempts to register upon termination have no effect.\n Termination is triggered when an invocation of {@code onAdvance}\n returns {@code true}. The default implementation returns {@code\n true} if a deregistration has caused the number of registered\n parties to become zero.  As illustrated below, when phasers control\n actions with a fixed number of iterations, it is often convenient\n to override this method to cause termination when the current phase\n number reaches a threshold. Method {@link #forceTermination} is\n also available to abruptly release waiting threads and allow them\n to terminate.\n\n \u003cp\u003e\u003cb\u003eTiering.\u003c/b\u003e Phasers may be \u003cem\u003etiered\u003c/em\u003e (i.e.,\n constructed in tree structures) to reduce contention. Phasers with\n large numbers of parties that would otherwise experience heavy\n synchronization contention costs may instead be set up so that\n groups of sub-phasers share a common parent.  This may greatly\n increase throughput even though it incurs greater per-operation\n overhead.\n\n \u003cp\u003eIn a tree of tiered phasers, registration and deregistration of\n child phasers with their parent are managed automatically.\n Whenever the number of registered parties of a child phaser becomes\n non-zero (as established in the {@link #Phaser(Phaser,int)}\n constructor, {@link #register}, or {@link #bulkRegister}), the\n child phaser is registered with its parent.  Whenever the number of\n registered parties becomes zero as the result of an invocation of\n {@link #arriveAndDeregister}, the child phaser is deregistered\n from its parent.\n\n \u003cp\u003e\u003cb\u003eMonitoring.\u003c/b\u003e While synchronization methods may be invoked\n only by registered parties, the current state of a phaser may be\n monitored by any caller.  At any given moment there are {@link\n #getRegisteredParties} parties in total, of which {@link\n #getArrivedParties} have arrived at the current phase ({@link\n #getPhase}).  When the remaining ({@link #getUnarrivedParties})\n parties arrive, the phase advances.  The values returned by these\n methods may reflect transient states and so are not in general\n useful for synchronization control.  Method {@link #toString}\n returns snapshots of these state queries in a form convenient for\n informal monitoring.\n\n \u003cp\u003e\u003cb\u003eSample usages:\u003c/b\u003e\n\n \u003cp\u003eA {@code Phaser} may be used instead of a {@code CountDownLatch}\n to control a one-shot action serving a variable number of parties.\n The typical idiom is for the method setting this up to first\n register, then start the actions, then deregister, as in:\n\n  \u003cpre\u003e {@code\n void runTasks(List\u003cRunnable\u003e tasks) {\n   final Phaser phaser \u003d new Phaser(1); // \"1\" to register self\n   // create and start threads\n   for (final Runnable task : tasks) {\n     phaser.register();\n     new Thread() {\n       public void run() {\n         phaser.arriveAndAwaitAdvance(); // await all creation\n         task.run();\n       }\n     }.start();\n   }\n\n   // allow threads to start and deregister self\n   phaser.arriveAndDeregister();\n }}\u003c/pre\u003e\n\n \u003cp\u003eOne way to cause a set of threads to repeatedly perform actions\n for a given number of iterations is to override {@code onAdvance}:\n\n  \u003cpre\u003e {@code\n void startTasks(List\u003cRunnable\u003e tasks, final int iterations) {\n   final Phaser phaser \u003d new Phaser() {\n     protected boolean onAdvance(int phase, int registeredParties) {\n       return phase \u003e\u003d iterations || registeredParties \u003d\u003d 0;\n     }\n   };\n   phaser.register();\n   for (final Runnable task : tasks) {\n     phaser.register();\n     new Thread() {\n       public void run() {\n         do {\n           task.run();\n           phaser.arriveAndAwaitAdvance();\n         } while (!phaser.isTerminated());\n       }\n     }.start();\n   }\n   phaser.arriveAndDeregister(); // deregister self, don\u0027t wait\n }}\u003c/pre\u003e\n\n If the main task must later await termination, it\n may re-register and then execute a similar loop:\n  \u003cpre\u003e {@code\n   // ...\n   phaser.register();\n   while (!phaser.isTerminated())\n     phaser.arriveAndAwaitAdvance();}\u003c/pre\u003e\n\n \u003cp\u003eRelated constructions may be used to await particular phase numbers\n in contexts where you are sure that the phase will never wrap around\n {@code Integer.MAX_VALUE}. For example:\n\n  \u003cpre\u003e {@code\n void awaitPhase(Phaser phaser, int phase) {\n   int p \u003d phaser.register(); // assumes caller not already registered\n   while (p \u003c phase) {\n     if (phaser.isTerminated())\n       // ... deal with unexpected termination\n     else\n       p \u003d phaser.arriveAndAwaitAdvance();\n   }\n   phaser.arriveAndDeregister();\n }}\u003c/pre\u003e\n\n\n \u003cp\u003eTo create a set of {@code n} tasks using a tree of phasers, you\n could use code of the following form, assuming a Task class with a\n constructor accepting a {@code Phaser} that it registers with upon\n construction. After invocation of {@code build(new Task[n], 0, n,\n new Phaser())}, these tasks could then be started, for example by\n submitting to a pool:\n\n  \u003cpre\u003e {@code\n void build(Task[] tasks, int lo, int hi, Phaser ph) {\n   if (hi - lo \u003e TASKS_PER_PHASER) {\n     for (int i \u003d lo; i \u003c hi; i +\u003d TASKS_PER_PHASER) {\n       int j \u003d Math.min(i + TASKS_PER_PHASER, hi);\n       build(tasks, i, j, new Phaser(ph));\n     }\n   } else {\n     for (int i \u003d lo; i \u003c hi; ++i)\n       tasks[i] \u003d new Task(ph);\n       // assumes new Task(ph) performs ph.register()\n   }\n }}\u003c/pre\u003e\n\n The best value of {@code TASKS_PER_PHASER} depends mainly on\n expected synchronization rates. A value as low as four may\n be appropriate for extremely small per-phase task bodies (thus\n high rates), or up to hundreds for extremely large ones.\n\n \u003cp\u003e\u003cb\u003eImplementation notes\u003c/b\u003e: This implementation restricts the\n maximum number of parties to 65535. Attempts to register additional\n parties result in {@code IllegalStateException}. However, you can and\n should create tiered phasers to accommodate arbitrarily large sets\n of participants.","isClass":true,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":false,"isOrdinaryClass":true,"isPrimitive":false,"simpleName":"Phaser","qualifiedName":"java.util.concurrent.Phaser","dimension":"","elementType":{},"package":"java.util.concurrent","superclass":"java.lang.Object","interfaces":[],"isAbstract":false,"isStatic":false,"since":"1.7","innerClasses":[],"isInnerClass":false,"constructors":[{"name":"Phaser","comment":"Creates a new phaser with no initially registered parties, no\n parent, and initial phase number 0. Any thread using this\n phaser will need to first register for it.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":true,"isField":false,"isMethod":false,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","parameters":[],"typeParameters":[]},{"name":"Phaser","comment":"Creates a new phaser with the given number of registered\n unarrived parties, no parent, and initial phase number 0.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":true,"isField":false,"isMethod":false,"isOrdinaryClass":false,"signature":"(int)","flatSignature":"(int)","parameters":[{"name":"parties","type":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"Phaser","comment":"Equivalent to {@link #Phaser(Phaser, int) Phaser(parent, 0)}.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":true,"isField":false,"isMethod":false,"isOrdinaryClass":false,"signature":"(java.util.concurrent.Phaser)","flatSignature":"(Phaser)","parameters":[{"name":"parent","type":{"isPrimitive":false,"simpleName":"Phaser","qualifiedName":"java.util.concurrent.Phaser","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"Phaser","comment":"Creates a new phaser with the given parent and number of\n registered unarrived parties.  When the given parent is non-null\n and the given number of parties is greater than zero, this\n child phaser is registered with its parent.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":true,"isField":false,"isMethod":false,"isOrdinaryClass":false,"signature":"(java.util.concurrent.Phaser, int)","flatSignature":"(Phaser, int)","parameters":[{"name":"parent","type":{"isPrimitive":false,"simpleName":"Phaser","qualifiedName":"java.util.concurrent.Phaser","dimension":"","elementType":{}}},{"name":"parties","type":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}}}],"typeParameters":[]}],"fields":[],"methods":[{"name":"register","comment":"Adds a new unarrived party to this phaser.  If an ongoing\n invocation of {@link #onAdvance} is in progress, this method\n may await its completion before returning.  If this phaser has\n a parent, and this phaser previously had no registered parties,\n this child phaser is also registered with its parent. If\n this phaser is terminated, the attempt to register has\n no effect, and a negative value is returned.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[],"typeParameters":[]},{"name":"bulkRegister","comment":"Adds the given number of new unarrived parties to this phaser.\n If an ongoing invocation of {@link #onAdvance} is in progress,\n this method may await its completion before returning.  If this\n phaser has a parent, and the given number of parties is greater\n than zero, and this phaser previously had no registered\n parties, this child phaser is also registered with its parent.\n If this phaser is terminated, the attempt to register has no\n effect, and a negative value is returned.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(int)","flatSignature":"(int)","returnType":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[{"name":"parties","type":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"arrive","comment":"Arrives at this phaser, without waiting for others to arrive.\n\n \u003cp\u003eIt is a usage error for an unregistered party to invoke this\n method.  However, this error may result in an {@code\n IllegalStateException} only upon some subsequent operation on\n this phaser, if ever.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[],"typeParameters":[]},{"name":"arriveAndDeregister","comment":"Arrives at this phaser and deregisters from it without waiting\n for others to arrive. Deregistration reduces the number of\n parties required to advance in future phases.  If this phaser\n has a parent, and deregistration causes this phaser to have\n zero parties, this phaser is also deregistered from its parent.\n\n \u003cp\u003eIt is a usage error for an unregistered party to invoke this\n method.  However, this error may result in an {@code\n IllegalStateException} only upon some subsequent operation on\n this phaser, if ever.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[],"typeParameters":[]},{"name":"arriveAndAwaitAdvance","comment":"Arrives at this phaser and awaits others. Equivalent in effect\n to {@code awaitAdvance(arrive())}.  If you need to await with\n interruption or timeout, you can arrange this with an analogous\n construction using one of the other forms of the {@code\n awaitAdvance} method.  If instead you need to deregister upon\n arrival, use {@code awaitAdvance(arriveAndDeregister())}.\n\n \u003cp\u003eIt is a usage error for an unregistered party to invoke this\n method.  However, this error may result in an {@code\n IllegalStateException} only upon some subsequent operation on\n this phaser, if ever.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[],"typeParameters":[]},{"name":"awaitAdvance","comment":"Awaits the phase of this phaser to advance from the given phase\n value, returning immediately if the current phase is not equal\n to the given phase value or this phaser is terminated.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(int)","flatSignature":"(int)","returnType":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[{"name":"phase","type":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"awaitAdvanceInterruptibly","comment":"Awaits the phase of this phaser to advance from the given phase\n value, throwing {@code InterruptedException} if interrupted\n while waiting, or returning immediately if the current phase is\n not equal to the given phase value or this phaser is\n terminated.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(int)","flatSignature":"(int)","returnType":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[{"name":"phase","type":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"awaitAdvanceInterruptibly","comment":"Awaits the phase of this phaser to advance from the given phase\n value or the given timeout to elapse, throwing {@code\n InterruptedException} if interrupted while waiting, or\n returning immediately if the current phase is not equal to the\n given phase value or this phaser is terminated.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(int, long, java.util.concurrent.TimeUnit)","flatSignature":"(int, long, TimeUnit)","returnType":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[{"name":"phase","type":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}}},{"name":"timeout","type":{"isPrimitive":true,"simpleName":"long","qualifiedName":"long","dimension":"","elementType":{}}},{"name":"unit","type":{"isPrimitive":false,"simpleName":"TimeUnit","qualifiedName":"java.util.concurrent.TimeUnit","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"forceTermination","comment":"Forces this phaser to enter termination state.  Counts of\n registered parties are unaffected.  If this phaser is a member\n of a tiered set of phasers, then all of the phasers in the set\n are terminated.  If this phaser is already terminated, this\n method has no effect.  This method may be useful for\n coordinating recovery after one or more tasks encounter\n unexpected exceptions.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":true,"simpleName":"void","qualifiedName":"void","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[],"typeParameters":[]},{"name":"getPhase","comment":"Returns the current phase number. The maximum phase number is\n {@code Integer.MAX_VALUE}, after which it restarts at\n zero. Upon termination, the phase number is negative,\n in which case the prevailing phase prior to termination\n may be obtained via {@code getPhase() + Integer.MIN_VALUE}.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[],"typeParameters":[]},{"name":"getRegisteredParties","comment":"Returns the number of parties registered at this phaser.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[],"typeParameters":[]},{"name":"getArrivedParties","comment":"Returns the number of registered parties that have arrived at\n the current phase of this phaser. If this phaser has terminated,\n the returned value is meaningless and arbitrary.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[],"typeParameters":[]},{"name":"getUnarrivedParties","comment":"Returns the number of registered parties that have not yet\n arrived at the current phase of this phaser. If this phaser has\n terminated, the returned value is meaningless and arbitrary.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[],"typeParameters":[]},{"name":"getParent","comment":"Returns the parent of this phaser, or {@code null} if none.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":false,"simpleName":"Phaser","qualifiedName":"java.util.concurrent.Phaser","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[],"typeParameters":[]},{"name":"getRoot","comment":"Returns the root ancestor of this phaser, which is the same as\n this phaser if it has no parent.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":false,"simpleName":"Phaser","qualifiedName":"java.util.concurrent.Phaser","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[],"typeParameters":[]},{"name":"isTerminated","comment":"Returns {@code true} if this phaser has been terminated.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":true,"simpleName":"boolean","qualifiedName":"boolean","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[],"typeParameters":[]},{"name":"toString","comment":"Returns a string identifying this phaser, as well as its\n state.  The state, in brackets, includes the String {@code\n \"phase \u003d \"} followed by the phase number, {@code \"parties \u003d \"}\n followed by the number of registered parties, and {@code\n \"arrived \u003d \"} followed by the number of arrived parties.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":false,"simpleName":"String","qualifiedName":"java.lang.String","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[],"typeParameters":[]}],"typeParameters":[],"enumConstants":[]}