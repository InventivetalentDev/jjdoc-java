{"name":"Random","comment":"An instance of this class is used to generate a stream of\n pseudorandom numbers. The class uses a 48-bit seed, which is\n modified using a linear congruential formula. (See Donald Knuth,\n \u003ci\u003eThe Art of Computer Programming, Volume 2\u003c/i\u003e, Section 3.2.1.)\n \u003cp\u003e\n If two instances of {@code Random} are created with the same\n seed, and the same sequence of method calls is made for each, they\n will generate and return identical sequences of numbers. In order to\n guarantee this property, particular algorithms are specified for the\n class {@code Random}. Java implementations must use all the algorithms\n shown here for the class {@code Random}, for the sake of absolute\n portability of Java code. However, subclasses of class {@code Random}\n are permitted to use other algorithms, so long as they adhere to the\n general contracts for all the methods.\n \u003cp\u003e\n The algorithms implemented by class {@code Random} use a\n {@code protected} utility method that on each invocation can supply\n up to 32 pseudorandomly generated bits.\n \u003cp\u003e\n Many applications will find the method {@link Math#random} simpler to use.\n\n \u003cp\u003eInstances of {@code java.util.Random} are threadsafe.\n However, the concurrent use of the same {@code java.util.Random}\n instance across threads may encounter contention and consequent\n poor performance. Consider instead using\n {@link java.util.concurrent.ThreadLocalRandom} in multithreaded\n designs.\n\n \u003cp\u003eInstances of {@code java.util.Random} are not cryptographically\n secure.  Consider instead using {@link java.security.SecureRandom} to\n get a cryptographically secure pseudo-random number generator for use\n by security-sensitive applications.","isClass":true,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":false,"isOrdinaryClass":true,"isPrimitive":false,"simpleName":"Random","qualifiedName":"java.util.Random","dimension":"","elementType":{},"package":"java.util","superclass":"java.lang.Object","interfaces":["java.io.Serializable"],"isAbstract":false,"isStatic":false,"since":"1.0","innerClasses":[],"isInnerClass":false,"constructors":[{"name":"Random","comment":"Creates a new random number generator. This constructor sets\n the seed of the random number generator to a value very likely\n to be distinct from any other invocation of this constructor.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":true,"isField":false,"isMethod":false,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","parameters":[],"typeParameters":[]},{"name":"Random","comment":"Creates a new random number generator using a single {@code long} seed.\n The seed is the initial value of the internal state of the pseudorandom\n number generator which is maintained by method {@link #next}.\n\n \u003cp\u003eThe invocation {@code new Random(seed)} is equivalent to:\n  \u003cpre\u003e {@code\n Random rnd \u003d new Random();\n rnd.setSeed(seed);}\u003c/pre\u003e","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":true,"isField":false,"isMethod":false,"isOrdinaryClass":false,"signature":"(long)","flatSignature":"(long)","parameters":[{"name":"seed","type":{"isPrimitive":true,"simpleName":"long","qualifiedName":"long","dimension":"","elementType":{}}}],"typeParameters":[]}],"fields":[],"methods":[{"name":"setSeed","comment":"Sets the seed of this random number generator using a single\n {@code long} seed. The general contract of {@code setSeed} is\n that it alters the state of this random number generator object\n so as to be in exactly the same state as if it had just been\n created with the argument {@code seed} as a seed. The method\n {@code setSeed} is implemented by class {@code Random} by\n atomically updating the seed to\n  \u003cpre\u003e{@code (seed ^ 0x5DEECE66DL) \u0026 ((1L \u003c\u003c 48) - 1)}\u003c/pre\u003e\n and clearing the {@code haveNextNextGaussian} flag used by {@link\n #nextGaussian}.\n\n \u003cp\u003eThe implementation of {@code setSeed} by class {@code Random}\n happens to use only 48 bits of the given seed. In general, however,\n an overriding method may use all 64 bits of the {@code long}\n argument as a seed value.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(long)","flatSignature":"(long)","returnType":{"isPrimitive":true,"simpleName":"void","qualifiedName":"void","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[{"name":"seed","type":{"isPrimitive":true,"simpleName":"long","qualifiedName":"long","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"nextBytes","comment":"Generates random bytes and places them into a user-supplied\n byte array.  The number of random bytes produced is equal to\n the length of the byte array.\n\n \u003cp\u003eThe method {@code nextBytes} is implemented by class {@code Random}\n as if by:\n  \u003cpre\u003e {@code\n public void nextBytes(byte[] bytes) {\n   for (int i \u003d 0; i \u003c bytes.length; )\n     for (int rnd \u003d nextInt(), n \u003d Math.min(bytes.length - i, 4);\n          n-- \u003e 0; rnd \u003e\u003e\u003d 8)\n       bytes[i++] \u003d (byte)rnd;\n }}\u003c/pre\u003e","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(byte[])","flatSignature":"(byte[])","returnType":{"isPrimitive":true,"simpleName":"void","qualifiedName":"void","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[{"name":"bytes","type":{"isPrimitive":true,"simpleName":"byte","qualifiedName":"byte","dimension":"[]","elementType":{"isPrimitive":true,"simpleName":"byte","qualifiedName":"byte","dimension":"","elementType":{}}}}],"typeParameters":[]},{"name":"nextInt","comment":"Returns the next pseudorandom, uniformly distributed {@code int}\n value from this random number generator\u0027s sequence. The general\n contract of {@code nextInt} is that one {@code int} value is\n pseudorandomly generated and returned. All 2\u003csup\u003e32\u003c/sup\u003e possible\n {@code int} values are produced with (approximately) equal probability.\n\n \u003cp\u003eThe method {@code nextInt} is implemented by class {@code Random}\n as if by:\n  \u003cpre\u003e {@code\n public int nextInt() {\n   return next(32);\n }}\u003c/pre\u003e","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[],"typeParameters":[]},{"name":"nextInt","comment":"Returns a pseudorandom, uniformly distributed {@code int} value\n between 0 (inclusive) and the specified value (exclusive), drawn from\n this random number generator\u0027s sequence.  The general contract of\n {@code nextInt} is that one {@code int} value in the specified range\n is pseudorandomly generated and returned.  All {@code bound} possible\n {@code int} values are produced with (approximately) equal\n probability.  The method {@code nextInt(int bound)} is implemented by\n class {@code Random} as if by:\n  \u003cpre\u003e {@code\n public int nextInt(int bound) {\n   if (bound \u003c\u003d 0)\n     throw new IllegalArgumentException(\"bound must be positive\");\n\n   if ((bound \u0026 -bound) \u003d\u003d bound)  // i.e., bound is a power of 2\n     return (int)((bound * (long)next(31)) \u003e\u003e 31);\n\n   int bits, val;\n   do {\n       bits \u003d next(31);\n       val \u003d bits % bound;\n   } while (bits - val + (bound-1) \u003c 0);\n   return val;\n }}\u003c/pre\u003e\n\n \u003cp\u003eThe hedge \"approximately\" is used in the foregoing description only\n because the next method is only approximately an unbiased source of\n independently chosen bits.  If it were a perfect source of randomly\n chosen bits, then the algorithm shown would choose {@code int}\n values from the stated range with perfect uniformity.\n \u003cp\u003e\n The algorithm is slightly tricky.  It rejects values that would result\n in an uneven distribution (due to the fact that 2^31 is not divisible\n by n). The probability of a value being rejected depends on n.  The\n worst case is n\u003d2^30+1, for which the probability of a reject is 1/2,\n and the expected number of iterations before the loop terminates is 2.\n \u003cp\u003e\n The algorithm treats the case where n is a power of two specially: it\n returns the correct number of high-order bits from the underlying\n pseudo-random number generator.  In the absence of special treatment,\n the correct number of \u003ci\u003elow-order\u003c/i\u003e bits would be returned.  Linear\n congruential pseudo-random number generators such as the one\n implemented by this class are known to have short periods in the\n sequence of values of their low-order bits.  Thus, this special case\n greatly increases the length of the sequence of values returned by\n successive calls to this method if n is a small power of two.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(int)","flatSignature":"(int)","returnType":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[{"name":"bound","type":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"nextLong","comment":"Returns the next pseudorandom, uniformly distributed {@code long}\n value from this random number generator\u0027s sequence. The general\n contract of {@code nextLong} is that one {@code long} value is\n pseudorandomly generated and returned.\n\n \u003cp\u003eThe method {@code nextLong} is implemented by class {@code Random}\n as if by:\n  \u003cpre\u003e {@code\n public long nextLong() {\n   return ((long)next(32) \u003c\u003c 32) + next(32);\n }}\u003c/pre\u003e\n\n Because class {@code Random} uses a seed with only 48 bits,\n this algorithm will not return all possible {@code long} values.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":true,"simpleName":"long","qualifiedName":"long","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[],"typeParameters":[]},{"name":"nextBoolean","comment":"Returns the next pseudorandom, uniformly distributed\n {@code boolean} value from this random number generator\u0027s\n sequence. The general contract of {@code nextBoolean} is that one\n {@code boolean} value is pseudorandomly generated and returned.  The\n values {@code true} and {@code false} are produced with\n (approximately) equal probability.\n\n \u003cp\u003eThe method {@code nextBoolean} is implemented by class {@code Random}\n as if by:\n  \u003cpre\u003e {@code\n public boolean nextBoolean() {\n   return next(1) !\u003d 0;\n }}\u003c/pre\u003e","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":true,"simpleName":"boolean","qualifiedName":"boolean","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[],"typeParameters":[]},{"name":"nextFloat","comment":"Returns the next pseudorandom, uniformly distributed {@code float}\n value between {@code 0.0} and {@code 1.0} from this random\n number generator\u0027s sequence.\n\n \u003cp\u003eThe general contract of {@code nextFloat} is that one\n {@code float} value, chosen (approximately) uniformly from the\n range {@code 0.0f} (inclusive) to {@code 1.0f} (exclusive), is\n pseudorandomly generated and returned. All 2\u003csup\u003e24\u003c/sup\u003e possible\n {@code float} values of the form \u003ci\u003em\u0026nbsp;x\u0026nbsp;\u003c/i\u003e2\u003csup\u003e-24\u003c/sup\u003e,\n where \u003ci\u003em\u003c/i\u003e is a positive integer less than 2\u003csup\u003e24\u003c/sup\u003e, are\n produced with (approximately) equal probability.\n\n \u003cp\u003eThe method {@code nextFloat} is implemented by class {@code Random}\n as if by:\n  \u003cpre\u003e {@code\n public float nextFloat() {\n   return next(24) / ((float)(1 \u003c\u003c 24));\n }}\u003c/pre\u003e\n\n \u003cp\u003eThe hedge \"approximately\" is used in the foregoing description only\n because the next method is only approximately an unbiased source of\n independently chosen bits. If it were a perfect source of randomly\n chosen bits, then the algorithm shown would choose {@code float}\n values from the stated range with perfect uniformity.\u003cp\u003e\n [In early versions of Java, the result was incorrectly calculated as:\n  \u003cpre\u003e {@code\n   return next(30) / ((float)(1 \u003c\u003c 30));}\u003c/pre\u003e\n This might seem to be equivalent, if not better, but in fact it\n introduced a slight nonuniformity because of the bias in the rounding\n of floating-point numbers: it was slightly more likely that the\n low-order bit of the significand would be 0 than that it would be 1.]","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":true,"simpleName":"float","qualifiedName":"float","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[],"typeParameters":[]},{"name":"nextDouble","comment":"Returns the next pseudorandom, uniformly distributed\n {@code double} value between {@code 0.0} and\n {@code 1.0} from this random number generator\u0027s sequence.\n\n \u003cp\u003eThe general contract of {@code nextDouble} is that one\n {@code double} value, chosen (approximately) uniformly from the\n range {@code 0.0d} (inclusive) to {@code 1.0d} (exclusive), is\n pseudorandomly generated and returned.\n\n \u003cp\u003eThe method {@code nextDouble} is implemented by class {@code Random}\n as if by:\n  \u003cpre\u003e {@code\n public double nextDouble() {\n   return (((long)next(26) \u003c\u003c 27) + next(27))\n     / (double)(1L \u003c\u003c 53);\n }}\u003c/pre\u003e\n\n \u003cp\u003eThe hedge \"approximately\" is used in the foregoing description only\n because the {@code next} method is only approximately an unbiased\n source of independently chosen bits. If it were a perfect source of\n randomly chosen bits, then the algorithm shown would choose\n {@code double} values from the stated range with perfect uniformity.\n \u003cp\u003e[In early versions of Java, the result was incorrectly calculated as:\n  \u003cpre\u003e {@code\n   return (((long)next(27) \u003c\u003c 27) + next(27))\n     / (double)(1L \u003c\u003c 54);}\u003c/pre\u003e\n This might seem to be equivalent, if not better, but in fact it\n introduced a large nonuniformity because of the bias in the rounding\n of floating-point numbers: it was three times as likely that the\n low-order bit of the significand would be 0 than that it would be 1!\n This nonuniformity probably doesn\u0027t matter much in practice, but we\n strive for perfection.]","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":true,"simpleName":"double","qualifiedName":"double","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[],"typeParameters":[]},{"name":"nextGaussian","comment":"Returns the next pseudorandom, Gaussian (\"normally\") distributed\n {@code double} value with mean {@code 0.0} and standard\n deviation {@code 1.0} from this random number generator\u0027s sequence.\n \u003cp\u003e\n The general contract of {@code nextGaussian} is that one\n {@code double} value, chosen from (approximately) the usual\n normal distribution with mean {@code 0.0} and standard deviation\n {@code 1.0}, is pseudorandomly generated and returned.\n\n \u003cp\u003eThe method {@code nextGaussian} is implemented by class\n {@code Random} as if by a threadsafe version of the following:\n  \u003cpre\u003e {@code\n private double nextNextGaussian;\n private boolean haveNextNextGaussian \u003d false;\n\n public double nextGaussian() {\n   if (haveNextNextGaussian) {\n     haveNextNextGaussian \u003d false;\n     return nextNextGaussian;\n   } else {\n     double v1, v2, s;\n     do {\n       v1 \u003d 2 * nextDouble() - 1;   // between -1.0 and 1.0\n       v2 \u003d 2 * nextDouble() - 1;   // between -1.0 and 1.0\n       s \u003d v1 * v1 + v2 * v2;\n     } while (s \u003e\u003d 1 || s \u003d\u003d 0);\n     double multiplier \u003d StrictMath.sqrt(-2 * StrictMath.log(s)/s);\n     nextNextGaussian \u003d v2 * multiplier;\n     haveNextNextGaussian \u003d true;\n     return v1 * multiplier;\n   }\n }}\u003c/pre\u003e\n This uses the \u003ci\u003epolar method\u003c/i\u003e of G. E. P. Box, M. E. Muller, and\n G. Marsaglia, as described by Donald E. Knuth in \u003ci\u003eThe Art of\n Computer Programming\u003c/i\u003e, Volume 3: \u003ci\u003eSeminumerical Algorithms\u003c/i\u003e,\n section 3.4.1, subsection C, algorithm P. Note that it generates two\n independent values at the cost of only one call to {@code StrictMath.log}\n and one call to {@code StrictMath.sqrt}.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":true,"simpleName":"double","qualifiedName":"double","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[],"typeParameters":[]},{"name":"ints","comment":"Returns a stream producing the given {@code streamSize} number of\n pseudorandom {@code int} values.\n\n \u003cp\u003eA pseudorandom {@code int} value is generated as if it\u0027s the result of\n calling the method {@link #nextInt()}.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(long)","flatSignature":"(long)","returnType":{"isPrimitive":false,"simpleName":"IntStream","qualifiedName":"java.util.stream.IntStream","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[{"name":"streamSize","type":{"isPrimitive":true,"simpleName":"long","qualifiedName":"long","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"ints","comment":"Returns an effectively unlimited stream of pseudorandom {@code int}\n values.\n\n \u003cp\u003eA pseudorandom {@code int} value is generated as if it\u0027s the result of\n calling the method {@link #nextInt()}.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":false,"simpleName":"IntStream","qualifiedName":"java.util.stream.IntStream","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[],"typeParameters":[]},{"name":"ints","comment":"Returns a stream producing the given {@code streamSize} number\n of pseudorandom {@code int} values, each conforming to the given\n origin (inclusive) and bound (exclusive).\n\n \u003cp\u003eA pseudorandom {@code int} value is generated as if it\u0027s the result of\n calling the following method with the origin and bound:\n \u003cpre\u003e {@code\n int nextInt(int origin, int bound) {\n   int n \u003d bound - origin;\n   if (n \u003e 0) {\n     return nextInt(n) + origin;\n   }\n   else {  // range not representable as int\n     int r;\n     do {\n       r \u003d nextInt();\n     } while (r \u003c origin || r \u003e\u003d bound);\n     return r;\n   }\n }}\u003c/pre\u003e","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(long, int, int)","flatSignature":"(long, int, int)","returnType":{"isPrimitive":false,"simpleName":"IntStream","qualifiedName":"java.util.stream.IntStream","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[{"name":"streamSize","type":{"isPrimitive":true,"simpleName":"long","qualifiedName":"long","dimension":"","elementType":{}}},{"name":"randomNumberOrigin","type":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}}},{"name":"randomNumberBound","type":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"ints","comment":"Returns an effectively unlimited stream of pseudorandom {@code\n int} values, each conforming to the given origin (inclusive) and bound\n (exclusive).\n\n \u003cp\u003eA pseudorandom {@code int} value is generated as if it\u0027s the result of\n calling the following method with the origin and bound:\n \u003cpre\u003e {@code\n int nextInt(int origin, int bound) {\n   int n \u003d bound - origin;\n   if (n \u003e 0) {\n     return nextInt(n) + origin;\n   }\n   else {  // range not representable as int\n     int r;\n     do {\n       r \u003d nextInt();\n     } while (r \u003c origin || r \u003e\u003d bound);\n     return r;\n   }\n }}\u003c/pre\u003e","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(int, int)","flatSignature":"(int, int)","returnType":{"isPrimitive":false,"simpleName":"IntStream","qualifiedName":"java.util.stream.IntStream","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[{"name":"randomNumberOrigin","type":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}}},{"name":"randomNumberBound","type":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"longs","comment":"Returns a stream producing the given {@code streamSize} number of\n pseudorandom {@code long} values.\n\n \u003cp\u003eA pseudorandom {@code long} value is generated as if it\u0027s the result\n of calling the method {@link #nextLong()}.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(long)","flatSignature":"(long)","returnType":{"isPrimitive":false,"simpleName":"LongStream","qualifiedName":"java.util.stream.LongStream","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[{"name":"streamSize","type":{"isPrimitive":true,"simpleName":"long","qualifiedName":"long","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"longs","comment":"Returns an effectively unlimited stream of pseudorandom {@code long}\n values.\n\n \u003cp\u003eA pseudorandom {@code long} value is generated as if it\u0027s the result\n of calling the method {@link #nextLong()}.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":false,"simpleName":"LongStream","qualifiedName":"java.util.stream.LongStream","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[],"typeParameters":[]},{"name":"longs","comment":"Returns a stream producing the given {@code streamSize} number of\n pseudorandom {@code long}, each conforming to the given origin\n (inclusive) and bound (exclusive).\n\n \u003cp\u003eA pseudorandom {@code long} value is generated as if it\u0027s the result\n of calling the following method with the origin and bound:\n \u003cpre\u003e {@code\n long nextLong(long origin, long bound) {\n   long r \u003d nextLong();\n   long n \u003d bound - origin, m \u003d n - 1;\n   if ((n \u0026 m) \u003d\u003d 0L)  // power of two\n     r \u003d (r \u0026 m) + origin;\n   else if (n \u003e 0L) {  // reject over-represented candidates\n     for (long u \u003d r \u003e\u003e\u003e 1;            // ensure nonnegative\n          u + m - (r \u003d u % n) \u003c 0L;    // rejection check\n          u \u003d nextLong() \u003e\u003e\u003e 1) // retry\n         ;\n     r +\u003d origin;\n   }\n   else {              // range not representable as long\n     while (r \u003c origin || r \u003e\u003d bound)\n       r \u003d nextLong();\n   }\n   return r;\n }}\u003c/pre\u003e","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(long, long, long)","flatSignature":"(long, long, long)","returnType":{"isPrimitive":false,"simpleName":"LongStream","qualifiedName":"java.util.stream.LongStream","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[{"name":"streamSize","type":{"isPrimitive":true,"simpleName":"long","qualifiedName":"long","dimension":"","elementType":{}}},{"name":"randomNumberOrigin","type":{"isPrimitive":true,"simpleName":"long","qualifiedName":"long","dimension":"","elementType":{}}},{"name":"randomNumberBound","type":{"isPrimitive":true,"simpleName":"long","qualifiedName":"long","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"longs","comment":"Returns an effectively unlimited stream of pseudorandom {@code\n long} values, each conforming to the given origin (inclusive) and bound\n (exclusive).\n\n \u003cp\u003eA pseudorandom {@code long} value is generated as if it\u0027s the result\n of calling the following method with the origin and bound:\n \u003cpre\u003e {@code\n long nextLong(long origin, long bound) {\n   long r \u003d nextLong();\n   long n \u003d bound - origin, m \u003d n - 1;\n   if ((n \u0026 m) \u003d\u003d 0L)  // power of two\n     r \u003d (r \u0026 m) + origin;\n   else if (n \u003e 0L) {  // reject over-represented candidates\n     for (long u \u003d r \u003e\u003e\u003e 1;            // ensure nonnegative\n          u + m - (r \u003d u % n) \u003c 0L;    // rejection check\n          u \u003d nextLong() \u003e\u003e\u003e 1) // retry\n         ;\n     r +\u003d origin;\n   }\n   else {              // range not representable as long\n     while (r \u003c origin || r \u003e\u003d bound)\n       r \u003d nextLong();\n   }\n   return r;\n }}\u003c/pre\u003e","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(long, long)","flatSignature":"(long, long)","returnType":{"isPrimitive":false,"simpleName":"LongStream","qualifiedName":"java.util.stream.LongStream","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[{"name":"randomNumberOrigin","type":{"isPrimitive":true,"simpleName":"long","qualifiedName":"long","dimension":"","elementType":{}}},{"name":"randomNumberBound","type":{"isPrimitive":true,"simpleName":"long","qualifiedName":"long","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"doubles","comment":"Returns a stream producing the given {@code streamSize} number of\n pseudorandom {@code double} values, each between zero\n (inclusive) and one (exclusive).\n\n \u003cp\u003eA pseudorandom {@code double} value is generated as if it\u0027s the result\n of calling the method {@link #nextDouble()}.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(long)","flatSignature":"(long)","returnType":{"isPrimitive":false,"simpleName":"DoubleStream","qualifiedName":"java.util.stream.DoubleStream","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[{"name":"streamSize","type":{"isPrimitive":true,"simpleName":"long","qualifiedName":"long","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"doubles","comment":"Returns an effectively unlimited stream of pseudorandom {@code\n double} values, each between zero (inclusive) and one\n (exclusive).\n\n \u003cp\u003eA pseudorandom {@code double} value is generated as if it\u0027s the result\n of calling the method {@link #nextDouble()}.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":false,"simpleName":"DoubleStream","qualifiedName":"java.util.stream.DoubleStream","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[],"typeParameters":[]},{"name":"doubles","comment":"Returns a stream producing the given {@code streamSize} number of\n pseudorandom {@code double} values, each conforming to the given origin\n (inclusive) and bound (exclusive).\n\n \u003cp\u003eA pseudorandom {@code double} value is generated as if it\u0027s the result\n of calling the following method with the origin and bound:\n \u003cpre\u003e {@code\n double nextDouble(double origin, double bound) {\n   double r \u003d nextDouble();\n   r \u003d r * (bound - origin) + origin;\n   if (r \u003e\u003d bound) // correct for rounding\n     r \u003d Math.nextDown(bound);\n   return r;\n }}\u003c/pre\u003e","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(long, double, double)","flatSignature":"(long, double, double)","returnType":{"isPrimitive":false,"simpleName":"DoubleStream","qualifiedName":"java.util.stream.DoubleStream","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[{"name":"streamSize","type":{"isPrimitive":true,"simpleName":"long","qualifiedName":"long","dimension":"","elementType":{}}},{"name":"randomNumberOrigin","type":{"isPrimitive":true,"simpleName":"double","qualifiedName":"double","dimension":"","elementType":{}}},{"name":"randomNumberBound","type":{"isPrimitive":true,"simpleName":"double","qualifiedName":"double","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"doubles","comment":"Returns an effectively unlimited stream of pseudorandom {@code\n double} values, each conforming to the given origin (inclusive) and bound\n (exclusive).\n\n \u003cp\u003eA pseudorandom {@code double} value is generated as if it\u0027s the result\n of calling the following method with the origin and bound:\n \u003cpre\u003e {@code\n double nextDouble(double origin, double bound) {\n   double r \u003d nextDouble();\n   r \u003d r * (bound - origin) + origin;\n   if (r \u003e\u003d bound) // correct for rounding\n     r \u003d Math.nextDown(bound);\n   return r;\n }}\u003c/pre\u003e","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(double, double)","flatSignature":"(double, double)","returnType":{"isPrimitive":false,"simpleName":"DoubleStream","qualifiedName":"java.util.stream.DoubleStream","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[{"name":"randomNumberOrigin","type":{"isPrimitive":true,"simpleName":"double","qualifiedName":"double","dimension":"","elementType":{}}},{"name":"randomNumberBound","type":{"isPrimitive":true,"simpleName":"double","qualifiedName":"double","dimension":"","elementType":{}}}],"typeParameters":[]}],"typeParameters":[],"subClasses":["java.security.SecureRandom","java.util.concurrent.ThreadLocalRandom"],"enumConstants":[]}