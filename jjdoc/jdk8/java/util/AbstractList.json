{"name":"AbstractList","comment":"This class provides a skeletal implementation of the {@link List}\n interface to minimize the effort required to implement this interface\n backed by a \"random access\" data store (such as an array).  For sequential\n access data (such as a linked list), {@link AbstractSequentialList} should\n be used in preference to this class.\n\n \u003cp\u003eTo implement an unmodifiable list, the programmer needs only to extend\n this class and provide implementations for the {@link #get(int)} and\n {@link List#size() size()} methods.\n\n \u003cp\u003eTo implement a modifiable list, the programmer must additionally\n override the {@link #set(int, Object) set(int, E)} method (which otherwise\n throws an {@code UnsupportedOperationException}).  If the list is\n variable-size the programmer must additionally override the\n {@link #add(int, Object) add(int, E)} and {@link #remove(int)} methods.\n\n \u003cp\u003eThe programmer should generally provide a void (no argument) and collection\n constructor, as per the recommendation in the {@link Collection} interface\n specification.\n\n \u003cp\u003eUnlike the other abstract collection implementations, the programmer does\n \u003ci\u003enot\u003c/i\u003e have to provide an iterator implementation; the iterator and\n list iterator are implemented by this class, on top of the \"random access\"\n methods:\n {@link #get(int)},\n {@link #set(int, Object) set(int, E)},\n {@link #add(int, Object) add(int, E)} and\n {@link #remove(int)}.\n\n \u003cp\u003eThe documentation for each non-abstract method in this class describes its\n implementation in detail.  Each of these methods may be overridden if the\n collection being implemented admits a more efficient implementation.\n\n \u003cp\u003eThis class is a member of the\n \u003ca href\u003d\"{@docRoot}/../technotes/guides/collections/index.html\"\u003e\n Java Collections Framework\u003c/a\u003e.","isClass":true,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":false,"isOrdinaryClass":true,"isPrimitive":false,"simpleName":"AbstractList","qualifiedName":"java.util.AbstractList","dimension":"","elementType":{},"package":"java.util","superclass":"java.util.AbstractCollection","interfaces":["java.util.List"],"isAbstract":true,"isStatic":false,"since":"1.2","innerClasses":[],"isInnerClass":false,"constructors":[],"fields":[],"methods":[{"name":"add","comment":"Appends the specified element to the end of this list (optional\n operation).\n\n \u003cp\u003eLists that support this operation may place limitations on what\n elements may be added to this list.  In particular, some\n lists will refuse to add null elements, and others will impose\n restrictions on the type of elements that may be added.  List\n classes should clearly specify in their documentation any restrictions\n on what elements may be added.\n\n \u003cp\u003eThis implementation calls {@code add(size(), e)}.\n\n \u003cp\u003eNote that this implementation throws an\n {@code UnsupportedOperationException} unless\n {@link #add(int, Object) add(int, E)} is overridden.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(E)","flatSignature":"(E)","returnType":{"isPrimitive":true,"simpleName":"boolean","qualifiedName":"boolean","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[{"name":"e","type":{"isPrimitive":false,"simpleName":"E","qualifiedName":"E","dimension":"","elementType":{},"typeVariable":{"name":"E","bounds":[]}}}],"typeParameters":[]},{"name":"get","comment":"{@inheritDoc}","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(int)","flatSignature":"(int)","returnType":{"isPrimitive":false,"simpleName":"E","qualifiedName":"E","dimension":"","elementType":{},"typeVariable":{"name":"E","bounds":[]}},"isAbstract":true,"isDefault":false,"isStatic":false,"parameters":[{"name":"index","type":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"set","comment":"{@inheritDoc}\n\n \u003cp\u003eThis implementation always throws an\n {@code UnsupportedOperationException}.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(int, E)","flatSignature":"(int, E)","returnType":{"isPrimitive":false,"simpleName":"E","qualifiedName":"E","dimension":"","elementType":{},"typeVariable":{"name":"E","bounds":[]}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[{"name":"index","type":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}}},{"name":"element","type":{"isPrimitive":false,"simpleName":"E","qualifiedName":"E","dimension":"","elementType":{},"typeVariable":{"name":"E","bounds":[]}}}],"typeParameters":[]},{"name":"add","comment":"{@inheritDoc}\n\n \u003cp\u003eThis implementation always throws an\n {@code UnsupportedOperationException}.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(int, E)","flatSignature":"(int, E)","returnType":{"isPrimitive":true,"simpleName":"void","qualifiedName":"void","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[{"name":"index","type":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}}},{"name":"element","type":{"isPrimitive":false,"simpleName":"E","qualifiedName":"E","dimension":"","elementType":{},"typeVariable":{"name":"E","bounds":[]}}}],"typeParameters":[]},{"name":"remove","comment":"{@inheritDoc}\n\n \u003cp\u003eThis implementation always throws an\n {@code UnsupportedOperationException}.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(int)","flatSignature":"(int)","returnType":{"isPrimitive":false,"simpleName":"E","qualifiedName":"E","dimension":"","elementType":{},"typeVariable":{"name":"E","bounds":[]}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[{"name":"index","type":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"indexOf","comment":"{@inheritDoc}\n\n \u003cp\u003eThis implementation first gets a list iterator (with\n {@code listIterator()}).  Then, it iterates over the list until the\n specified element is found or the end of the list is reached.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.lang.Object)","flatSignature":"(Object)","returnType":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[{"name":"o","type":{"isPrimitive":false,"simpleName":"Object","qualifiedName":"java.lang.Object","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"lastIndexOf","comment":"{@inheritDoc}\n\n \u003cp\u003eThis implementation first gets a list iterator that points to the end\n of the list (with {@code listIterator(size())}).  Then, it iterates\n backwards over the list until the specified element is found, or the\n beginning of the list is reached.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.lang.Object)","flatSignature":"(Object)","returnType":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[{"name":"o","type":{"isPrimitive":false,"simpleName":"Object","qualifiedName":"java.lang.Object","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"clear","comment":"Removes all of the elements from this list (optional operation).\n The list will be empty after this call returns.\n\n \u003cp\u003eThis implementation calls {@code removeRange(0, size())}.\n\n \u003cp\u003eNote that this implementation throws an\n {@code UnsupportedOperationException} unless {@code remove(int\n index)} or {@code removeRange(int fromIndex, int toIndex)} is\n overridden.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":true,"simpleName":"void","qualifiedName":"void","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[],"typeParameters":[]},{"name":"addAll","comment":"{@inheritDoc}\n\n \u003cp\u003eThis implementation gets an iterator over the specified collection\n and iterates over it, inserting the elements obtained from the\n iterator into this list at the appropriate position, one at a time,\n using {@code add(int, E)}.\n Many implementations will override this method for efficiency.\n\n \u003cp\u003eNote that this implementation throws an\n {@code UnsupportedOperationException} unless\n {@link #add(int, Object) add(int, E)} is overridden.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(int, java.util.Collection\u003c? extends E\u003e)","flatSignature":"(int, Collection\u003c? extends E\u003e)","returnType":{"isPrimitive":true,"simpleName":"boolean","qualifiedName":"boolean","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[{"name":"index","type":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}}},{"name":"c","type":{"isPrimitive":false,"simpleName":"Collection","qualifiedName":"java.util.Collection","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"iterator","comment":"Returns an iterator over the elements in this list in proper sequence.\n\n \u003cp\u003eThis implementation returns a straightforward implementation of the\n iterator interface, relying on the backing list\u0027s {@code size()},\n {@code get(int)}, and {@code remove(int)} methods.\n\n \u003cp\u003eNote that the iterator returned by this method will throw an\n {@link UnsupportedOperationException} in response to its\n {@code remove} method unless the list\u0027s {@code remove(int)} method is\n overridden.\n\n \u003cp\u003eThis implementation can be made to throw runtime exceptions in the\n face of concurrent modification, as described in the specification\n for the (protected) {@link #modCount} field.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":false,"simpleName":"Iterator","qualifiedName":"java.util.Iterator","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[],"typeParameters":[]},{"name":"listIterator","comment":"{@inheritDoc}\n\n \u003cp\u003eThis implementation returns {@code listIterator(0)}.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":false,"simpleName":"ListIterator","qualifiedName":"java.util.ListIterator","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[],"typeParameters":[]},{"name":"listIterator","comment":"{@inheritDoc}\n\n \u003cp\u003eThis implementation returns a straightforward implementation of the\n {@code ListIterator} interface that extends the implementation of the\n {@code Iterator} interface returned by the {@code iterator()} method.\n The {@code ListIterator} implementation relies on the backing list\u0027s\n {@code get(int)}, {@code set(int, E)}, {@code add(int, E)}\n and {@code remove(int)} methods.\n\n \u003cp\u003eNote that the list iterator returned by this implementation will\n throw an {@link UnsupportedOperationException} in response to its\n {@code remove}, {@code set} and {@code add} methods unless the\n list\u0027s {@code remove(int)}, {@code set(int, E)}, and\n {@code add(int, E)} methods are overridden.\n\n \u003cp\u003eThis implementation can be made to throw runtime exceptions in the\n face of concurrent modification, as described in the specification for\n the (protected) {@link #modCount} field.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(int)","flatSignature":"(int)","returnType":{"isPrimitive":false,"simpleName":"ListIterator","qualifiedName":"java.util.ListIterator","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[{"name":"index","type":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"subList","comment":"{@inheritDoc}\n\n \u003cp\u003eThis implementation returns a list that subclasses\n {@code AbstractList}.  The subclass stores, in private fields, the\n offset of the subList within the backing list, the size of the subList\n (which can change over its lifetime), and the expected\n {@code modCount} value of the backing list.  There are two variants\n of the subclass, one of which implements {@code RandomAccess}.\n If this list implements {@code RandomAccess} the returned list will\n be an instance of the subclass that implements {@code RandomAccess}.\n\n \u003cp\u003eThe subclass\u0027s {@code set(int, E)}, {@code get(int)},\n {@code add(int, E)}, {@code remove(int)}, {@code addAll(int,\n Collection)} and {@code removeRange(int, int)} methods all\n delegate to the corresponding methods on the backing abstract list,\n after bounds-checking the index and adjusting for the offset.  The\n {@code addAll(Collection c)} method merely returns {@code addAll(size,\n c)}.\n\n \u003cp\u003eThe {@code listIterator(int)} method returns a \"wrapper object\"\n over a list iterator on the backing list, which is created with the\n corresponding method on the backing list.  The {@code iterator} method\n merely returns {@code listIterator()}, and the {@code size} method\n merely returns the subclass\u0027s {@code size} field.\n\n \u003cp\u003eAll methods first check to see if the actual {@code modCount} of\n the backing list is equal to its expected value, and throw a\n {@code ConcurrentModificationException} if it is not.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(int, int)","flatSignature":"(int, int)","returnType":{"isPrimitive":false,"simpleName":"List","qualifiedName":"java.util.List","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[{"name":"fromIndex","type":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}}},{"name":"toIndex","type":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"equals","comment":"Compares the specified object with this list for equality.  Returns\n {@code true} if and only if the specified object is also a list, both\n lists have the same size, and all corresponding pairs of elements in\n the two lists are \u003ci\u003eequal\u003c/i\u003e.  (Two elements {@code e1} and\n {@code e2} are \u003ci\u003eequal\u003c/i\u003e if {@code (e1\u003d\u003dnull ? e2\u003d\u003dnull :\n e1.equals(e2))}.)  In other words, two lists are defined to be\n equal if they contain the same elements in the same order.\u003cp\u003e\n\n This implementation first checks if the specified object is this\n list. If so, it returns {@code true}; if not, it checks if the\n specified object is a list. If not, it returns {@code false}; if so,\n it iterates over both lists, comparing corresponding pairs of elements.\n If any comparison returns {@code false}, this method returns\n {@code false}.  If either iterator runs out of elements before the\n other it returns {@code false} (as the lists are of unequal length);\n otherwise it returns {@code true} when the iterations complete.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.lang.Object)","flatSignature":"(Object)","returnType":{"isPrimitive":true,"simpleName":"boolean","qualifiedName":"boolean","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[{"name":"o","type":{"isPrimitive":false,"simpleName":"Object","qualifiedName":"java.lang.Object","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"hashCode","comment":"Returns the hash code value for this list.\n\n \u003cp\u003eThis implementation uses exactly the code that is used to define the\n list hash function in the documentation for the {@link List#hashCode}\n method.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[],"typeParameters":[]}],"typeParameters":[{"name":"E","bounds":[]}],"subClasses":["java.util.Vector","java.util.AbstractSequentialList","java.util.ArrayList"],"enumConstants":[]}