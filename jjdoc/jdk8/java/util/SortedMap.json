{"name":"SortedMap","comment":"A {@link Map} that further provides a \u003cem\u003etotal ordering\u003c/em\u003e on its keys.\n The map is ordered according to the {@linkplain Comparable natural\n ordering} of its keys, or by a {@link Comparator} typically\n provided at sorted map creation time.  This order is reflected when\n iterating over the sorted map\u0027s collection views (returned by the\n {@code entrySet}, {@code keySet} and {@code values} methods).\n Several additional operations are provided to take advantage of the\n ordering.  (This interface is the map analogue of {@link SortedSet}.)\n\n \u003cp\u003eAll keys inserted into a sorted map must implement the {@code Comparable}\n interface (or be accepted by the specified comparator).  Furthermore, all\n such keys must be \u003cem\u003emutually comparable\u003c/em\u003e: {@code k1.compareTo(k2)} (or\n {@code comparator.compare(k1, k2)}) must not throw a\n {@code ClassCastException} for any keys {@code k1} and {@code k2} in\n the sorted map.  Attempts to violate this restriction will cause the\n offending method or constructor invocation to throw a\n {@code ClassCastException}.\n\n \u003cp\u003eNote that the ordering maintained by a sorted map (whether or not an\n explicit comparator is provided) must be \u003cem\u003econsistent with equals\u003c/em\u003e if\n the sorted map is to correctly implement the {@code Map} interface.  (See\n the {@code Comparable} interface or {@code Comparator} interface for a\n precise definition of \u003cem\u003econsistent with equals\u003c/em\u003e.)  This is so because\n the {@code Map} interface is defined in terms of the {@code equals}\n operation, but a sorted map performs all key comparisons using its\n {@code compareTo} (or {@code compare}) method, so two keys that are\n deemed equal by this method are, from the standpoint of the sorted map,\n equal.  The behavior of a tree map \u003cem\u003eis\u003c/em\u003e well-defined even if its\n ordering is inconsistent with equals; it just fails to obey the general\n contract of the {@code Map} interface.\n\n \u003cp\u003eAll general-purpose sorted map implementation classes should provide four\n \"standard\" constructors. It is not possible to enforce this recommendation\n though as required constructors cannot be specified by interfaces. The\n expected \"standard\" constructors for all sorted map implementations are:\n \u003col\u003e\n   \u003cli\u003eA void (no arguments) constructor, which creates an empty sorted map\n   sorted according to the natural ordering of its keys.\u003c/li\u003e\n   \u003cli\u003eA constructor with a single argument of type {@code Comparator}, which\n   creates an empty sorted map sorted according to the specified comparator.\u003c/li\u003e\n   \u003cli\u003eA constructor with a single argument of type {@code Map}, which creates\n   a new map with the same key-value mappings as its argument, sorted\n   according to the keys\u0027 natural ordering.\u003c/li\u003e\n   \u003cli\u003eA constructor with a single argument of type {@code SortedMap}, which\n   creates a new sorted map with the same key-value mappings and the same\n   ordering as the input sorted map.\u003c/li\u003e\n \u003c/ol\u003e\n\n \u003cp\u003e\u003cstrong\u003eNote\u003c/strong\u003e: several methods return submaps with restricted key\n ranges. Such ranges are \u003cem\u003ehalf-open\u003c/em\u003e, that is, they include their low\n endpoint but not their high endpoint (where applicable).  If you need a\n \u003cem\u003eclosed range\u003c/em\u003e (which includes both endpoints), and the key type\n allows for calculation of the successor of a given key, merely request\n the subrange from {@code lowEndpoint} to\n {@code successor(highEndpoint)}.  For example, suppose that {@code m}\n is a map whose keys are strings.  The following idiom obtains a view\n containing all of the key-value mappings in {@code m} whose keys are\n between {@code low} and {@code high}, inclusive:\u003cpre\u003e\n   SortedMap\u0026lt;String, V\u0026gt; sub \u003d m.subMap(low, high+\"\\0\");\u003c/pre\u003e\n\n A similar technique can be used to generate an \u003cem\u003eopen range\u003c/em\u003e\n (which contains neither endpoint).  The following idiom obtains a\n view containing all of the key-value mappings in {@code m} whose keys\n are between {@code low} and {@code high}, exclusive:\u003cpre\u003e\n   SortedMap\u0026lt;String, V\u0026gt; sub \u003d m.subMap(low+\"\\0\", high);\u003c/pre\u003e\n\n \u003cp\u003eThis interface is a member of the\n \u003ca href\u003d\"{@docRoot}/../technotes/guides/collections/index.html\"\u003e\n Java Collections Framework\u003c/a\u003e.","isClass":false,"isInterface":true,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":false,"isOrdinaryClass":false,"isPrimitive":false,"simpleName":"SortedMap","qualifiedName":"java.util.SortedMap","dimension":"","elementType":{},"package":"java.util","interfaces":["java.util.Map"],"isAbstract":true,"isStatic":false,"since":"1.2","innerClasses":[],"isInnerClass":false,"constructors":[],"fields":[],"methods":[{"name":"comparator","comment":"Returns the comparator used to order the keys in this map, or\n {@code null} if this map uses the {@linkplain Comparable\n natural ordering} of its keys.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":false,"simpleName":"Comparator","qualifiedName":"java.util.Comparator","dimension":"","elementType":{}},"isAbstract":true,"isDefault":false,"isStatic":false,"parameters":[],"typeParameters":[]},{"name":"subMap","comment":"Returns a view of the portion of this map whose keys range from\n {@code fromKey}, inclusive, to {@code toKey}, exclusive.  (If\n {@code fromKey} and {@code toKey} are equal, the returned map\n is empty.)  The returned map is backed by this map, so changes\n in the returned map are reflected in this map, and vice-versa.\n The returned map supports all optional map operations that this\n map supports.\n\n \u003cp\u003eThe returned map will throw an {@code IllegalArgumentException}\n on an attempt to insert a key outside its range.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(K, K)","flatSignature":"(K, K)","returnType":{"isPrimitive":false,"simpleName":"SortedMap","qualifiedName":"java.util.SortedMap","dimension":"","elementType":{}},"isAbstract":true,"isDefault":false,"isStatic":false,"parameters":[{"name":"fromKey","type":{"isPrimitive":false,"simpleName":"K","qualifiedName":"K","dimension":"","elementType":{},"typeVariable":{"name":"K","bounds":[]}}},{"name":"toKey","type":{"isPrimitive":false,"simpleName":"K","qualifiedName":"K","dimension":"","elementType":{},"typeVariable":{"name":"K","bounds":[]}}}],"typeParameters":[]},{"name":"headMap","comment":"Returns a view of the portion of this map whose keys are\n strictly less than {@code toKey}.  The returned map is backed\n by this map, so changes in the returned map are reflected in\n this map, and vice-versa.  The returned map supports all\n optional map operations that this map supports.\n\n \u003cp\u003eThe returned map will throw an {@code IllegalArgumentException}\n on an attempt to insert a key outside its range.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(K)","flatSignature":"(K)","returnType":{"isPrimitive":false,"simpleName":"SortedMap","qualifiedName":"java.util.SortedMap","dimension":"","elementType":{}},"isAbstract":true,"isDefault":false,"isStatic":false,"parameters":[{"name":"toKey","type":{"isPrimitive":false,"simpleName":"K","qualifiedName":"K","dimension":"","elementType":{},"typeVariable":{"name":"K","bounds":[]}}}],"typeParameters":[]},{"name":"tailMap","comment":"Returns a view of the portion of this map whose keys are\n greater than or equal to {@code fromKey}.  The returned map is\n backed by this map, so changes in the returned map are\n reflected in this map, and vice-versa.  The returned map\n supports all optional map operations that this map supports.\n\n \u003cp\u003eThe returned map will throw an {@code IllegalArgumentException}\n on an attempt to insert a key outside its range.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(K)","flatSignature":"(K)","returnType":{"isPrimitive":false,"simpleName":"SortedMap","qualifiedName":"java.util.SortedMap","dimension":"","elementType":{}},"isAbstract":true,"isDefault":false,"isStatic":false,"parameters":[{"name":"fromKey","type":{"isPrimitive":false,"simpleName":"K","qualifiedName":"K","dimension":"","elementType":{},"typeVariable":{"name":"K","bounds":[]}}}],"typeParameters":[]},{"name":"firstKey","comment":"Returns the first (lowest) key currently in this map.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":false,"simpleName":"K","qualifiedName":"K","dimension":"","elementType":{},"typeVariable":{"name":"K","bounds":[]}},"isAbstract":true,"isDefault":false,"isStatic":false,"parameters":[],"typeParameters":[]},{"name":"lastKey","comment":"Returns the last (highest) key currently in this map.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":false,"simpleName":"K","qualifiedName":"K","dimension":"","elementType":{},"typeVariable":{"name":"K","bounds":[]}},"isAbstract":true,"isDefault":false,"isStatic":false,"parameters":[],"typeParameters":[]},{"name":"keySet","comment":"Returns a {@link Set} view of the keys contained in this map.\n The set\u0027s iterator returns the keys in ascending order.\n The set is backed by the map, so changes to the map are\n reflected in the set, and vice-versa.  If the map is modified\n while an iteration over the set is in progress (except through\n the iterator\u0027s own {@code remove} operation), the results of\n the iteration are undefined.  The set supports element removal,\n which removes the corresponding mapping from the map, via the\n {@code Iterator.remove}, {@code Set.remove},\n {@code removeAll}, {@code retainAll}, and {@code clear}\n operations.  It does not support the {@code add} or {@code addAll}\n operations.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":false,"simpleName":"Set","qualifiedName":"java.util.Set","dimension":"","elementType":{}},"isAbstract":true,"isDefault":false,"isStatic":false,"parameters":[],"typeParameters":[]},{"name":"values","comment":"Returns a {@link Collection} view of the values contained in this map.\n The collection\u0027s iterator returns the values in ascending order\n of the corresponding keys.\n The collection is backed by the map, so changes to the map are\n reflected in the collection, and vice-versa.  If the map is\n modified while an iteration over the collection is in progress\n (except through the iterator\u0027s own {@code remove} operation),\n the results of the iteration are undefined.  The collection\n supports element removal, which removes the corresponding\n mapping from the map, via the {@code Iterator.remove},\n {@code Collection.remove}, {@code removeAll},\n {@code retainAll} and {@code clear} operations.  It does not\n support the {@code add} or {@code addAll} operations.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":false,"simpleName":"Collection","qualifiedName":"java.util.Collection","dimension":"","elementType":{}},"isAbstract":true,"isDefault":false,"isStatic":false,"parameters":[],"typeParameters":[]},{"name":"entrySet","comment":"Returns a {@link Set} view of the mappings contained in this map.\n The set\u0027s iterator returns the entries in ascending key order.\n The set is backed by the map, so changes to the map are\n reflected in the set, and vice-versa.  If the map is modified\n while an iteration over the set is in progress (except through\n the iterator\u0027s own {@code remove} operation, or through the\n {@code setValue} operation on a map entry returned by the\n iterator) the results of the iteration are undefined.  The set\n supports element removal, which removes the corresponding\n mapping from the map, via the {@code Iterator.remove},\n {@code Set.remove}, {@code removeAll}, {@code retainAll} and\n {@code clear} operations.  It does not support the\n {@code add} or {@code addAll} operations.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":false,"simpleName":"Set","qualifiedName":"java.util.Set","dimension":"","elementType":{}},"isAbstract":true,"isDefault":false,"isStatic":false,"parameters":[],"typeParameters":[]}],"typeParameters":[{"name":"K","bounds":[]},{"name":"V","bounds":[]}],"subInterfaces":["java.util.NavigableMap"],"enumConstants":[]}