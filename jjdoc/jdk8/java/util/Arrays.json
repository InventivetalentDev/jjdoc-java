{"name":"Arrays","comment":"This class contains various methods for manipulating arrays (such as\n sorting and searching). This class also contains a static factory\n that allows arrays to be viewed as lists.\n\n \u003cp\u003eThe methods in this class all throw a {@code NullPointerException},\n if the specified array reference is null, except where noted.\n\n \u003cp\u003eThe documentation for the methods contained in this class includes\n briefs description of the \u003ci\u003eimplementations\u003c/i\u003e. Such descriptions should\n be regarded as \u003ci\u003eimplementation notes\u003c/i\u003e, rather than parts of the\n \u003ci\u003especification\u003c/i\u003e. Implementors should feel free to substitute other\n algorithms, so long as the specification itself is adhered to. (For\n example, the algorithm used by {@code sort(Object[])} does not have to be\n a MergeSort, but it does have to be \u003ci\u003estable\u003c/i\u003e.)\n\n \u003cp\u003eThis class is a member of the\n \u003ca href\u003d\"{@docRoot}/../technotes/guides/collections/index.html\"\u003e\n Java Collections Framework\u003c/a\u003e.","isClass":true,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":false,"isOrdinaryClass":true,"isPrimitive":false,"simpleName":"Arrays","qualifiedName":"java.util.Arrays","dimension":"","elementType":{},"package":"java.util","superclass":"java.lang.Object","interfaces":[],"isAbstract":false,"isStatic":false,"since":"1.2","innerClasses":[],"isInnerClass":false,"constructors":[],"fields":[],"methods":[{"name":"sort","comment":"Sorts the specified array into ascending numerical order.\n\n \u003cp\u003eImplementation note: The sorting algorithm is a Dual-Pivot Quicksort\n by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm\n offers O(n log(n)) performance on many data sets that cause other\n quicksorts to degrade to quadratic performance, and is typically\n faster than traditional (one-pivot) Quicksort implementations.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(int[])","flatSignature":"(int[])","returnType":{"isPrimitive":true,"simpleName":"void","qualifiedName":"void","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"a","type":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"[]","elementType":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}}}}],"typeParameters":[]},{"name":"sort","comment":"Sorts the specified range of the array into ascending order. The range\n to be sorted extends from the index {@code fromIndex}, inclusive, to\n the index {@code toIndex}, exclusive. If {@code fromIndex \u003d\u003d toIndex},\n the range to be sorted is empty.\n\n \u003cp\u003eImplementation note: The sorting algorithm is a Dual-Pivot Quicksort\n by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm\n offers O(n log(n)) performance on many data sets that cause other\n quicksorts to degrade to quadratic performance, and is typically\n faster than traditional (one-pivot) Quicksort implementations.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(int[], int, int)","flatSignature":"(int[], int, int)","returnType":{"isPrimitive":true,"simpleName":"void","qualifiedName":"void","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"a","type":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"[]","elementType":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}}}},{"name":"fromIndex","type":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}}},{"name":"toIndex","type":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"sort","comment":"Sorts the specified array into ascending numerical order.\n\n \u003cp\u003eImplementation note: The sorting algorithm is a Dual-Pivot Quicksort\n by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm\n offers O(n log(n)) performance on many data sets that cause other\n quicksorts to degrade to quadratic performance, and is typically\n faster than traditional (one-pivot) Quicksort implementations.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(long[])","flatSignature":"(long[])","returnType":{"isPrimitive":true,"simpleName":"void","qualifiedName":"void","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"a","type":{"isPrimitive":true,"simpleName":"long","qualifiedName":"long","dimension":"[]","elementType":{"isPrimitive":true,"simpleName":"long","qualifiedName":"long","dimension":"","elementType":{}}}}],"typeParameters":[]},{"name":"sort","comment":"Sorts the specified range of the array into ascending order. The range\n to be sorted extends from the index {@code fromIndex}, inclusive, to\n the index {@code toIndex}, exclusive. If {@code fromIndex \u003d\u003d toIndex},\n the range to be sorted is empty.\n\n \u003cp\u003eImplementation note: The sorting algorithm is a Dual-Pivot Quicksort\n by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm\n offers O(n log(n)) performance on many data sets that cause other\n quicksorts to degrade to quadratic performance, and is typically\n faster than traditional (one-pivot) Quicksort implementations.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(long[], int, int)","flatSignature":"(long[], int, int)","returnType":{"isPrimitive":true,"simpleName":"void","qualifiedName":"void","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"a","type":{"isPrimitive":true,"simpleName":"long","qualifiedName":"long","dimension":"[]","elementType":{"isPrimitive":true,"simpleName":"long","qualifiedName":"long","dimension":"","elementType":{}}}},{"name":"fromIndex","type":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}}},{"name":"toIndex","type":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"sort","comment":"Sorts the specified array into ascending numerical order.\n\n \u003cp\u003eImplementation note: The sorting algorithm is a Dual-Pivot Quicksort\n by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm\n offers O(n log(n)) performance on many data sets that cause other\n quicksorts to degrade to quadratic performance, and is typically\n faster than traditional (one-pivot) Quicksort implementations.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(short[])","flatSignature":"(short[])","returnType":{"isPrimitive":true,"simpleName":"void","qualifiedName":"void","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"a","type":{"isPrimitive":true,"simpleName":"short","qualifiedName":"short","dimension":"[]","elementType":{"isPrimitive":true,"simpleName":"short","qualifiedName":"short","dimension":"","elementType":{}}}}],"typeParameters":[]},{"name":"sort","comment":"Sorts the specified range of the array into ascending order. The range\n to be sorted extends from the index {@code fromIndex}, inclusive, to\n the index {@code toIndex}, exclusive. If {@code fromIndex \u003d\u003d toIndex},\n the range to be sorted is empty.\n\n \u003cp\u003eImplementation note: The sorting algorithm is a Dual-Pivot Quicksort\n by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm\n offers O(n log(n)) performance on many data sets that cause other\n quicksorts to degrade to quadratic performance, and is typically\n faster than traditional (one-pivot) Quicksort implementations.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(short[], int, int)","flatSignature":"(short[], int, int)","returnType":{"isPrimitive":true,"simpleName":"void","qualifiedName":"void","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"a","type":{"isPrimitive":true,"simpleName":"short","qualifiedName":"short","dimension":"[]","elementType":{"isPrimitive":true,"simpleName":"short","qualifiedName":"short","dimension":"","elementType":{}}}},{"name":"fromIndex","type":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}}},{"name":"toIndex","type":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"sort","comment":"Sorts the specified array into ascending numerical order.\n\n \u003cp\u003eImplementation note: The sorting algorithm is a Dual-Pivot Quicksort\n by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm\n offers O(n log(n)) performance on many data sets that cause other\n quicksorts to degrade to quadratic performance, and is typically\n faster than traditional (one-pivot) Quicksort implementations.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(char[])","flatSignature":"(char[])","returnType":{"isPrimitive":true,"simpleName":"void","qualifiedName":"void","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"a","type":{"isPrimitive":true,"simpleName":"char","qualifiedName":"char","dimension":"[]","elementType":{"isPrimitive":true,"simpleName":"char","qualifiedName":"char","dimension":"","elementType":{}}}}],"typeParameters":[]},{"name":"sort","comment":"Sorts the specified range of the array into ascending order. The range\n to be sorted extends from the index {@code fromIndex}, inclusive, to\n the index {@code toIndex}, exclusive. If {@code fromIndex \u003d\u003d toIndex},\n the range to be sorted is empty.\n\n \u003cp\u003eImplementation note: The sorting algorithm is a Dual-Pivot Quicksort\n by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm\n offers O(n log(n)) performance on many data sets that cause other\n quicksorts to degrade to quadratic performance, and is typically\n faster than traditional (one-pivot) Quicksort implementations.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(char[], int, int)","flatSignature":"(char[], int, int)","returnType":{"isPrimitive":true,"simpleName":"void","qualifiedName":"void","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"a","type":{"isPrimitive":true,"simpleName":"char","qualifiedName":"char","dimension":"[]","elementType":{"isPrimitive":true,"simpleName":"char","qualifiedName":"char","dimension":"","elementType":{}}}},{"name":"fromIndex","type":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}}},{"name":"toIndex","type":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"sort","comment":"Sorts the specified array into ascending numerical order.\n\n \u003cp\u003eImplementation note: The sorting algorithm is a Dual-Pivot Quicksort\n by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm\n offers O(n log(n)) performance on many data sets that cause other\n quicksorts to degrade to quadratic performance, and is typically\n faster than traditional (one-pivot) Quicksort implementations.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(byte[])","flatSignature":"(byte[])","returnType":{"isPrimitive":true,"simpleName":"void","qualifiedName":"void","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"a","type":{"isPrimitive":true,"simpleName":"byte","qualifiedName":"byte","dimension":"[]","elementType":{"isPrimitive":true,"simpleName":"byte","qualifiedName":"byte","dimension":"","elementType":{}}}}],"typeParameters":[]},{"name":"sort","comment":"Sorts the specified range of the array into ascending order. The range\n to be sorted extends from the index {@code fromIndex}, inclusive, to\n the index {@code toIndex}, exclusive. If {@code fromIndex \u003d\u003d toIndex},\n the range to be sorted is empty.\n\n \u003cp\u003eImplementation note: The sorting algorithm is a Dual-Pivot Quicksort\n by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm\n offers O(n log(n)) performance on many data sets that cause other\n quicksorts to degrade to quadratic performance, and is typically\n faster than traditional (one-pivot) Quicksort implementations.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(byte[], int, int)","flatSignature":"(byte[], int, int)","returnType":{"isPrimitive":true,"simpleName":"void","qualifiedName":"void","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"a","type":{"isPrimitive":true,"simpleName":"byte","qualifiedName":"byte","dimension":"[]","elementType":{"isPrimitive":true,"simpleName":"byte","qualifiedName":"byte","dimension":"","elementType":{}}}},{"name":"fromIndex","type":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}}},{"name":"toIndex","type":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"sort","comment":"Sorts the specified array into ascending numerical order.\n\n \u003cp\u003eThe {@code \u003c} relation does not provide a total order on all float\n values: {@code -0.0f \u003d\u003d 0.0f} is {@code true} and a {@code Float.NaN}\n value compares neither less than, greater than, nor equal to any value,\n even itself. This method uses the total order imposed by the method\n {@link Float#compareTo}: {@code -0.0f} is treated as less than value\n {@code 0.0f} and {@code Float.NaN} is considered greater than any\n other value and all {@code Float.NaN} values are considered equal.\n\n \u003cp\u003eImplementation note: The sorting algorithm is a Dual-Pivot Quicksort\n by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm\n offers O(n log(n)) performance on many data sets that cause other\n quicksorts to degrade to quadratic performance, and is typically\n faster than traditional (one-pivot) Quicksort implementations.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(float[])","flatSignature":"(float[])","returnType":{"isPrimitive":true,"simpleName":"void","qualifiedName":"void","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"a","type":{"isPrimitive":true,"simpleName":"float","qualifiedName":"float","dimension":"[]","elementType":{"isPrimitive":true,"simpleName":"float","qualifiedName":"float","dimension":"","elementType":{}}}}],"typeParameters":[]},{"name":"sort","comment":"Sorts the specified range of the array into ascending order. The range\n to be sorted extends from the index {@code fromIndex}, inclusive, to\n the index {@code toIndex}, exclusive. If {@code fromIndex \u003d\u003d toIndex},\n the range to be sorted is empty.\n\n \u003cp\u003eThe {@code \u003c} relation does not provide a total order on all float\n values: {@code -0.0f \u003d\u003d 0.0f} is {@code true} and a {@code Float.NaN}\n value compares neither less than, greater than, nor equal to any value,\n even itself. This method uses the total order imposed by the method\n {@link Float#compareTo}: {@code -0.0f} is treated as less than value\n {@code 0.0f} and {@code Float.NaN} is considered greater than any\n other value and all {@code Float.NaN} values are considered equal.\n\n \u003cp\u003eImplementation note: The sorting algorithm is a Dual-Pivot Quicksort\n by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm\n offers O(n log(n)) performance on many data sets that cause other\n quicksorts to degrade to quadratic performance, and is typically\n faster than traditional (one-pivot) Quicksort implementations.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(float[], int, int)","flatSignature":"(float[], int, int)","returnType":{"isPrimitive":true,"simpleName":"void","qualifiedName":"void","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"a","type":{"isPrimitive":true,"simpleName":"float","qualifiedName":"float","dimension":"[]","elementType":{"isPrimitive":true,"simpleName":"float","qualifiedName":"float","dimension":"","elementType":{}}}},{"name":"fromIndex","type":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}}},{"name":"toIndex","type":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"sort","comment":"Sorts the specified array into ascending numerical order.\n\n \u003cp\u003eThe {@code \u003c} relation does not provide a total order on all double\n values: {@code -0.0d \u003d\u003d 0.0d} is {@code true} and a {@code Double.NaN}\n value compares neither less than, greater than, nor equal to any value,\n even itself. This method uses the total order imposed by the method\n {@link Double#compareTo}: {@code -0.0d} is treated as less than value\n {@code 0.0d} and {@code Double.NaN} is considered greater than any\n other value and all {@code Double.NaN} values are considered equal.\n\n \u003cp\u003eImplementation note: The sorting algorithm is a Dual-Pivot Quicksort\n by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm\n offers O(n log(n)) performance on many data sets that cause other\n quicksorts to degrade to quadratic performance, and is typically\n faster than traditional (one-pivot) Quicksort implementations.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(double[])","flatSignature":"(double[])","returnType":{"isPrimitive":true,"simpleName":"void","qualifiedName":"void","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"a","type":{"isPrimitive":true,"simpleName":"double","qualifiedName":"double","dimension":"[]","elementType":{"isPrimitive":true,"simpleName":"double","qualifiedName":"double","dimension":"","elementType":{}}}}],"typeParameters":[]},{"name":"sort","comment":"Sorts the specified range of the array into ascending order. The range\n to be sorted extends from the index {@code fromIndex}, inclusive, to\n the index {@code toIndex}, exclusive. If {@code fromIndex \u003d\u003d toIndex},\n the range to be sorted is empty.\n\n \u003cp\u003eThe {@code \u003c} relation does not provide a total order on all double\n values: {@code -0.0d \u003d\u003d 0.0d} is {@code true} and a {@code Double.NaN}\n value compares neither less than, greater than, nor equal to any value,\n even itself. This method uses the total order imposed by the method\n {@link Double#compareTo}: {@code -0.0d} is treated as less than value\n {@code 0.0d} and {@code Double.NaN} is considered greater than any\n other value and all {@code Double.NaN} values are considered equal.\n\n \u003cp\u003eImplementation note: The sorting algorithm is a Dual-Pivot Quicksort\n by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm\n offers O(n log(n)) performance on many data sets that cause other\n quicksorts to degrade to quadratic performance, and is typically\n faster than traditional (one-pivot) Quicksort implementations.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(double[], int, int)","flatSignature":"(double[], int, int)","returnType":{"isPrimitive":true,"simpleName":"void","qualifiedName":"void","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"a","type":{"isPrimitive":true,"simpleName":"double","qualifiedName":"double","dimension":"[]","elementType":{"isPrimitive":true,"simpleName":"double","qualifiedName":"double","dimension":"","elementType":{}}}},{"name":"fromIndex","type":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}}},{"name":"toIndex","type":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"parallelSort","comment":"Sorts the specified array into ascending numerical order.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(byte[])","flatSignature":"(byte[])","returnType":{"isPrimitive":true,"simpleName":"void","qualifiedName":"void","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"a","type":{"isPrimitive":true,"simpleName":"byte","qualifiedName":"byte","dimension":"[]","elementType":{"isPrimitive":true,"simpleName":"byte","qualifiedName":"byte","dimension":"","elementType":{}}}}],"typeParameters":[]},{"name":"parallelSort","comment":"Sorts the specified range of the array into ascending numerical order.\n The range to be sorted extends from the index {@code fromIndex},\n inclusive, to the index {@code toIndex}, exclusive. If\n {@code fromIndex \u003d\u003d toIndex}, the range to be sorted is empty.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(byte[], int, int)","flatSignature":"(byte[], int, int)","returnType":{"isPrimitive":true,"simpleName":"void","qualifiedName":"void","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"a","type":{"isPrimitive":true,"simpleName":"byte","qualifiedName":"byte","dimension":"[]","elementType":{"isPrimitive":true,"simpleName":"byte","qualifiedName":"byte","dimension":"","elementType":{}}}},{"name":"fromIndex","type":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}}},{"name":"toIndex","type":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"parallelSort","comment":"Sorts the specified array into ascending numerical order.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(char[])","flatSignature":"(char[])","returnType":{"isPrimitive":true,"simpleName":"void","qualifiedName":"void","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"a","type":{"isPrimitive":true,"simpleName":"char","qualifiedName":"char","dimension":"[]","elementType":{"isPrimitive":true,"simpleName":"char","qualifiedName":"char","dimension":"","elementType":{}}}}],"typeParameters":[]},{"name":"parallelSort","comment":"Sorts the specified range of the array into ascending numerical order.\n The range to be sorted extends from the index {@code fromIndex},\n inclusive, to the index {@code toIndex}, exclusive. If\n {@code fromIndex \u003d\u003d toIndex}, the range to be sorted is empty.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(char[], int, int)","flatSignature":"(char[], int, int)","returnType":{"isPrimitive":true,"simpleName":"void","qualifiedName":"void","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"a","type":{"isPrimitive":true,"simpleName":"char","qualifiedName":"char","dimension":"[]","elementType":{"isPrimitive":true,"simpleName":"char","qualifiedName":"char","dimension":"","elementType":{}}}},{"name":"fromIndex","type":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}}},{"name":"toIndex","type":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"parallelSort","comment":"Sorts the specified array into ascending numerical order.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(short[])","flatSignature":"(short[])","returnType":{"isPrimitive":true,"simpleName":"void","qualifiedName":"void","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"a","type":{"isPrimitive":true,"simpleName":"short","qualifiedName":"short","dimension":"[]","elementType":{"isPrimitive":true,"simpleName":"short","qualifiedName":"short","dimension":"","elementType":{}}}}],"typeParameters":[]},{"name":"parallelSort","comment":"Sorts the specified range of the array into ascending numerical order.\n The range to be sorted extends from the index {@code fromIndex},\n inclusive, to the index {@code toIndex}, exclusive. If\n {@code fromIndex \u003d\u003d toIndex}, the range to be sorted is empty.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(short[], int, int)","flatSignature":"(short[], int, int)","returnType":{"isPrimitive":true,"simpleName":"void","qualifiedName":"void","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"a","type":{"isPrimitive":true,"simpleName":"short","qualifiedName":"short","dimension":"[]","elementType":{"isPrimitive":true,"simpleName":"short","qualifiedName":"short","dimension":"","elementType":{}}}},{"name":"fromIndex","type":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}}},{"name":"toIndex","type":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"parallelSort","comment":"Sorts the specified array into ascending numerical order.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(int[])","flatSignature":"(int[])","returnType":{"isPrimitive":true,"simpleName":"void","qualifiedName":"void","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"a","type":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"[]","elementType":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}}}}],"typeParameters":[]},{"name":"parallelSort","comment":"Sorts the specified range of the array into ascending numerical order.\n The range to be sorted extends from the index {@code fromIndex},\n inclusive, to the index {@code toIndex}, exclusive. If\n {@code fromIndex \u003d\u003d toIndex}, the range to be sorted is empty.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(int[], int, int)","flatSignature":"(int[], int, int)","returnType":{"isPrimitive":true,"simpleName":"void","qualifiedName":"void","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"a","type":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"[]","elementType":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}}}},{"name":"fromIndex","type":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}}},{"name":"toIndex","type":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"parallelSort","comment":"Sorts the specified array into ascending numerical order.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(long[])","flatSignature":"(long[])","returnType":{"isPrimitive":true,"simpleName":"void","qualifiedName":"void","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"a","type":{"isPrimitive":true,"simpleName":"long","qualifiedName":"long","dimension":"[]","elementType":{"isPrimitive":true,"simpleName":"long","qualifiedName":"long","dimension":"","elementType":{}}}}],"typeParameters":[]},{"name":"parallelSort","comment":"Sorts the specified range of the array into ascending numerical order.\n The range to be sorted extends from the index {@code fromIndex},\n inclusive, to the index {@code toIndex}, exclusive. If\n {@code fromIndex \u003d\u003d toIndex}, the range to be sorted is empty.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(long[], int, int)","flatSignature":"(long[], int, int)","returnType":{"isPrimitive":true,"simpleName":"void","qualifiedName":"void","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"a","type":{"isPrimitive":true,"simpleName":"long","qualifiedName":"long","dimension":"[]","elementType":{"isPrimitive":true,"simpleName":"long","qualifiedName":"long","dimension":"","elementType":{}}}},{"name":"fromIndex","type":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}}},{"name":"toIndex","type":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"parallelSort","comment":"Sorts the specified array into ascending numerical order.\n\n \u003cp\u003eThe {@code \u003c} relation does not provide a total order on all float\n values: {@code -0.0f \u003d\u003d 0.0f} is {@code true} and a {@code Float.NaN}\n value compares neither less than, greater than, nor equal to any value,\n even itself. This method uses the total order imposed by the method\n {@link Float#compareTo}: {@code -0.0f} is treated as less than value\n {@code 0.0f} and {@code Float.NaN} is considered greater than any\n other value and all {@code Float.NaN} values are considered equal.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(float[])","flatSignature":"(float[])","returnType":{"isPrimitive":true,"simpleName":"void","qualifiedName":"void","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"a","type":{"isPrimitive":true,"simpleName":"float","qualifiedName":"float","dimension":"[]","elementType":{"isPrimitive":true,"simpleName":"float","qualifiedName":"float","dimension":"","elementType":{}}}}],"typeParameters":[]},{"name":"parallelSort","comment":"Sorts the specified range of the array into ascending numerical order.\n The range to be sorted extends from the index {@code fromIndex},\n inclusive, to the index {@code toIndex}, exclusive. If\n {@code fromIndex \u003d\u003d toIndex}, the range to be sorted is empty.\n\n \u003cp\u003eThe {@code \u003c} relation does not provide a total order on all float\n values: {@code -0.0f \u003d\u003d 0.0f} is {@code true} and a {@code Float.NaN}\n value compares neither less than, greater than, nor equal to any value,\n even itself. This method uses the total order imposed by the method\n {@link Float#compareTo}: {@code -0.0f} is treated as less than value\n {@code 0.0f} and {@code Float.NaN} is considered greater than any\n other value and all {@code Float.NaN} values are considered equal.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(float[], int, int)","flatSignature":"(float[], int, int)","returnType":{"isPrimitive":true,"simpleName":"void","qualifiedName":"void","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"a","type":{"isPrimitive":true,"simpleName":"float","qualifiedName":"float","dimension":"[]","elementType":{"isPrimitive":true,"simpleName":"float","qualifiedName":"float","dimension":"","elementType":{}}}},{"name":"fromIndex","type":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}}},{"name":"toIndex","type":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"parallelSort","comment":"Sorts the specified array into ascending numerical order.\n\n \u003cp\u003eThe {@code \u003c} relation does not provide a total order on all double\n values: {@code -0.0d \u003d\u003d 0.0d} is {@code true} and a {@code Double.NaN}\n value compares neither less than, greater than, nor equal to any value,\n even itself. This method uses the total order imposed by the method\n {@link Double#compareTo}: {@code -0.0d} is treated as less than value\n {@code 0.0d} and {@code Double.NaN} is considered greater than any\n other value and all {@code Double.NaN} values are considered equal.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(double[])","flatSignature":"(double[])","returnType":{"isPrimitive":true,"simpleName":"void","qualifiedName":"void","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"a","type":{"isPrimitive":true,"simpleName":"double","qualifiedName":"double","dimension":"[]","elementType":{"isPrimitive":true,"simpleName":"double","qualifiedName":"double","dimension":"","elementType":{}}}}],"typeParameters":[]},{"name":"parallelSort","comment":"Sorts the specified range of the array into ascending numerical order.\n The range to be sorted extends from the index {@code fromIndex},\n inclusive, to the index {@code toIndex}, exclusive. If\n {@code fromIndex \u003d\u003d toIndex}, the range to be sorted is empty.\n\n \u003cp\u003eThe {@code \u003c} relation does not provide a total order on all double\n values: {@code -0.0d \u003d\u003d 0.0d} is {@code true} and a {@code Double.NaN}\n value compares neither less than, greater than, nor equal to any value,\n even itself. This method uses the total order imposed by the method\n {@link Double#compareTo}: {@code -0.0d} is treated as less than value\n {@code 0.0d} and {@code Double.NaN} is considered greater than any\n other value and all {@code Double.NaN} values are considered equal.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(double[], int, int)","flatSignature":"(double[], int, int)","returnType":{"isPrimitive":true,"simpleName":"void","qualifiedName":"void","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"a","type":{"isPrimitive":true,"simpleName":"double","qualifiedName":"double","dimension":"[]","elementType":{"isPrimitive":true,"simpleName":"double","qualifiedName":"double","dimension":"","elementType":{}}}},{"name":"fromIndex","type":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}}},{"name":"toIndex","type":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"parallelSort","comment":"Sorts the specified array of objects into ascending order, according\n to the {@linkplain Comparable natural ordering} of its elements.\n All elements in the array must implement the {@link Comparable}\n interface.  Furthermore, all elements in the array must be\n \u003ci\u003emutually comparable\u003c/i\u003e (that is, {@code e1.compareTo(e2)} must\n not throw a {@code ClassCastException} for any elements {@code e1}\n and {@code e2} in the array).\n\n \u003cp\u003eThis sort is guaranteed to be \u003ci\u003estable\u003c/i\u003e:  equal elements will\n not be reordered as a result of the sort.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(T[])","flatSignature":"(T[])","returnType":{"isPrimitive":true,"simpleName":"void","qualifiedName":"void","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"a","type":{"isPrimitive":false,"simpleName":"T","qualifiedName":"T","dimension":"[]","elementType":{"isPrimitive":false,"simpleName":"T","qualifiedName":"T","dimension":"","elementType":{},"typeVariable":{"name":"T","bounds":["java.lang.Comparable"]}},"typeVariable":{"name":"T","bounds":["java.lang.Comparable"]}}}],"typeParameters":[{"name":"T","bounds":["java.lang.Comparable"]}]},{"name":"parallelSort","comment":"Sorts the specified range of the specified array of objects into\n ascending order, according to the\n {@linkplain Comparable natural ordering} of its\n elements.  The range to be sorted extends from index\n {@code fromIndex}, inclusive, to index {@code toIndex}, exclusive.\n (If {@code fromIndex\u003d\u003dtoIndex}, the range to be sorted is empty.)  All\n elements in this range must implement the {@link Comparable}\n interface.  Furthermore, all elements in this range must be \u003ci\u003emutually\n comparable\u003c/i\u003e (that is, {@code e1.compareTo(e2)} must not throw a\n {@code ClassCastException} for any elements {@code e1} and\n {@code e2} in the array).\n\n \u003cp\u003eThis sort is guaranteed to be \u003ci\u003estable\u003c/i\u003e:  equal elements will\n not be reordered as a result of the sort.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(T[], int, int)","flatSignature":"(T[], int, int)","returnType":{"isPrimitive":true,"simpleName":"void","qualifiedName":"void","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"a","type":{"isPrimitive":false,"simpleName":"T","qualifiedName":"T","dimension":"[]","elementType":{"isPrimitive":false,"simpleName":"T","qualifiedName":"T","dimension":"","elementType":{},"typeVariable":{"name":"T","bounds":["java.lang.Comparable"]}},"typeVariable":{"name":"T","bounds":["java.lang.Comparable"]}}},{"name":"fromIndex","type":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}}},{"name":"toIndex","type":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}}}],"typeParameters":[{"name":"T","bounds":["java.lang.Comparable"]}]},{"name":"parallelSort","comment":"Sorts the specified array of objects according to the order induced by\n the specified comparator.  All elements in the array must be\n \u003ci\u003emutually comparable\u003c/i\u003e by the specified comparator (that is,\n {@code c.compare(e1, e2)} must not throw a {@code ClassCastException}\n for any elements {@code e1} and {@code e2} in the array).\n\n \u003cp\u003eThis sort is guaranteed to be \u003ci\u003estable\u003c/i\u003e:  equal elements will\n not be reordered as a result of the sort.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(T[], java.util.Comparator\u003c? super T\u003e)","flatSignature":"(T[], Comparator\u003c? super T\u003e)","returnType":{"isPrimitive":true,"simpleName":"void","qualifiedName":"void","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"a","type":{"isPrimitive":false,"simpleName":"T","qualifiedName":"T","dimension":"[]","elementType":{"isPrimitive":false,"simpleName":"T","qualifiedName":"T","dimension":"","elementType":{},"typeVariable":{"name":"T","bounds":[]}},"typeVariable":{"name":"T","bounds":[]}}},{"name":"cmp","type":{"isPrimitive":false,"simpleName":"Comparator","qualifiedName":"java.util.Comparator","dimension":"","elementType":{}}}],"typeParameters":[{"name":"T","bounds":[]}]},{"name":"parallelSort","comment":"Sorts the specified range of the specified array of objects according\n to the order induced by the specified comparator.  The range to be\n sorted extends from index {@code fromIndex}, inclusive, to index\n {@code toIndex}, exclusive.  (If {@code fromIndex\u003d\u003dtoIndex}, the\n range to be sorted is empty.)  All elements in the range must be\n \u003ci\u003emutually comparable\u003c/i\u003e by the specified comparator (that is,\n {@code c.compare(e1, e2)} must not throw a {@code ClassCastException}\n for any elements {@code e1} and {@code e2} in the range).\n\n \u003cp\u003eThis sort is guaranteed to be \u003ci\u003estable\u003c/i\u003e:  equal elements will\n not be reordered as a result of the sort.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(T[], int, int, java.util.Comparator\u003c? super T\u003e)","flatSignature":"(T[], int, int, Comparator\u003c? super T\u003e)","returnType":{"isPrimitive":true,"simpleName":"void","qualifiedName":"void","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"a","type":{"isPrimitive":false,"simpleName":"T","qualifiedName":"T","dimension":"[]","elementType":{"isPrimitive":false,"simpleName":"T","qualifiedName":"T","dimension":"","elementType":{},"typeVariable":{"name":"T","bounds":[]}},"typeVariable":{"name":"T","bounds":[]}}},{"name":"fromIndex","type":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}}},{"name":"toIndex","type":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}}},{"name":"cmp","type":{"isPrimitive":false,"simpleName":"Comparator","qualifiedName":"java.util.Comparator","dimension":"","elementType":{}}}],"typeParameters":[{"name":"T","bounds":[]}]},{"name":"sort","comment":"Sorts the specified array of objects into ascending order, according\n to the {@linkplain Comparable natural ordering} of its elements.\n All elements in the array must implement the {@link Comparable}\n interface.  Furthermore, all elements in the array must be\n \u003ci\u003emutually comparable\u003c/i\u003e (that is, {@code e1.compareTo(e2)} must\n not throw a {@code ClassCastException} for any elements {@code e1}\n and {@code e2} in the array).\n\n \u003cp\u003eThis sort is guaranteed to be \u003ci\u003estable\u003c/i\u003e:  equal elements will\n not be reordered as a result of the sort.\n\n \u003cp\u003eImplementation note: This implementation is a stable, adaptive,\n iterative mergesort that requires far fewer than n lg(n) comparisons\n when the input array is partially sorted, while offering the\n performance of a traditional mergesort when the input array is\n randomly ordered.  If the input array is nearly sorted, the\n implementation requires approximately n comparisons.  Temporary\n storage requirements vary from a small constant for nearly sorted\n input arrays to n/2 object references for randomly ordered input\n arrays.\n\n \u003cp\u003eThe implementation takes equal advantage of ascending and\n descending order in its input array, and can take advantage of\n ascending and descending order in different parts of the the same\n input array.  It is well-suited to merging two or more sorted arrays:\n simply concatenate the arrays and sort the resulting array.\n\n \u003cp\u003eThe implementation was adapted from Tim Peters\u0027s list sort for Python\n (\u003ca href\u003d\"http://svn.python.org/projects/python/trunk/Objects/listsort.txt\"\u003e\n TimSort\u003c/a\u003e).  It uses techniques from Peter McIlroy\u0027s \"Optimistic\n Sorting and Information Theoretic Complexity\", in Proceedings of the\n Fourth Annual ACM-SIAM Symposium on Discrete Algorithms, pp 467-474,\n January 1993.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.lang.Object[])","flatSignature":"(Object[])","returnType":{"isPrimitive":true,"simpleName":"void","qualifiedName":"void","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"a","type":{"isPrimitive":false,"simpleName":"Object","qualifiedName":"java.lang.Object","dimension":"[]","elementType":{"isPrimitive":false,"simpleName":"Object","qualifiedName":"java.lang.Object","dimension":"","elementType":{}}}}],"typeParameters":[]},{"name":"sort","comment":"Sorts the specified range of the specified array of objects into\n ascending order, according to the\n {@linkplain Comparable natural ordering} of its\n elements.  The range to be sorted extends from index\n {@code fromIndex}, inclusive, to index {@code toIndex}, exclusive.\n (If {@code fromIndex\u003d\u003dtoIndex}, the range to be sorted is empty.)  All\n elements in this range must implement the {@link Comparable}\n interface.  Furthermore, all elements in this range must be \u003ci\u003emutually\n comparable\u003c/i\u003e (that is, {@code e1.compareTo(e2)} must not throw a\n {@code ClassCastException} for any elements {@code e1} and\n {@code e2} in the array).\n\n \u003cp\u003eThis sort is guaranteed to be \u003ci\u003estable\u003c/i\u003e:  equal elements will\n not be reordered as a result of the sort.\n\n \u003cp\u003eImplementation note: This implementation is a stable, adaptive,\n iterative mergesort that requires far fewer than n lg(n) comparisons\n when the input array is partially sorted, while offering the\n performance of a traditional mergesort when the input array is\n randomly ordered.  If the input array is nearly sorted, the\n implementation requires approximately n comparisons.  Temporary\n storage requirements vary from a small constant for nearly sorted\n input arrays to n/2 object references for randomly ordered input\n arrays.\n\n \u003cp\u003eThe implementation takes equal advantage of ascending and\n descending order in its input array, and can take advantage of\n ascending and descending order in different parts of the the same\n input array.  It is well-suited to merging two or more sorted arrays:\n simply concatenate the arrays and sort the resulting array.\n\n \u003cp\u003eThe implementation was adapted from Tim Peters\u0027s list sort for Python\n (\u003ca href\u003d\"http://svn.python.org/projects/python/trunk/Objects/listsort.txt\"\u003e\n TimSort\u003c/a\u003e).  It uses techniques from Peter McIlroy\u0027s \"Optimistic\n Sorting and Information Theoretic Complexity\", in Proceedings of the\n Fourth Annual ACM-SIAM Symposium on Discrete Algorithms, pp 467-474,\n January 1993.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.lang.Object[], int, int)","flatSignature":"(Object[], int, int)","returnType":{"isPrimitive":true,"simpleName":"void","qualifiedName":"void","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"a","type":{"isPrimitive":false,"simpleName":"Object","qualifiedName":"java.lang.Object","dimension":"[]","elementType":{"isPrimitive":false,"simpleName":"Object","qualifiedName":"java.lang.Object","dimension":"","elementType":{}}}},{"name":"fromIndex","type":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}}},{"name":"toIndex","type":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"sort","comment":"Sorts the specified array of objects according to the order induced by\n the specified comparator.  All elements in the array must be\n \u003ci\u003emutually comparable\u003c/i\u003e by the specified comparator (that is,\n {@code c.compare(e1, e2)} must not throw a {@code ClassCastException}\n for any elements {@code e1} and {@code e2} in the array).\n\n \u003cp\u003eThis sort is guaranteed to be \u003ci\u003estable\u003c/i\u003e:  equal elements will\n not be reordered as a result of the sort.\n\n \u003cp\u003eImplementation note: This implementation is a stable, adaptive,\n iterative mergesort that requires far fewer than n lg(n) comparisons\n when the input array is partially sorted, while offering the\n performance of a traditional mergesort when the input array is\n randomly ordered.  If the input array is nearly sorted, the\n implementation requires approximately n comparisons.  Temporary\n storage requirements vary from a small constant for nearly sorted\n input arrays to n/2 object references for randomly ordered input\n arrays.\n\n \u003cp\u003eThe implementation takes equal advantage of ascending and\n descending order in its input array, and can take advantage of\n ascending and descending order in different parts of the the same\n input array.  It is well-suited to merging two or more sorted arrays:\n simply concatenate the arrays and sort the resulting array.\n\n \u003cp\u003eThe implementation was adapted from Tim Peters\u0027s list sort for Python\n (\u003ca href\u003d\"http://svn.python.org/projects/python/trunk/Objects/listsort.txt\"\u003e\n TimSort\u003c/a\u003e).  It uses techniques from Peter McIlroy\u0027s \"Optimistic\n Sorting and Information Theoretic Complexity\", in Proceedings of the\n Fourth Annual ACM-SIAM Symposium on Discrete Algorithms, pp 467-474,\n January 1993.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(T[], java.util.Comparator\u003c? super T\u003e)","flatSignature":"(T[], Comparator\u003c? super T\u003e)","returnType":{"isPrimitive":true,"simpleName":"void","qualifiedName":"void","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"a","type":{"isPrimitive":false,"simpleName":"T","qualifiedName":"T","dimension":"[]","elementType":{"isPrimitive":false,"simpleName":"T","qualifiedName":"T","dimension":"","elementType":{},"typeVariable":{"name":"T","bounds":[]}},"typeVariable":{"name":"T","bounds":[]}}},{"name":"c","type":{"isPrimitive":false,"simpleName":"Comparator","qualifiedName":"java.util.Comparator","dimension":"","elementType":{}}}],"typeParameters":[{"name":"T","bounds":[]}]},{"name":"sort","comment":"Sorts the specified range of the specified array of objects according\n to the order induced by the specified comparator.  The range to be\n sorted extends from index {@code fromIndex}, inclusive, to index\n {@code toIndex}, exclusive.  (If {@code fromIndex\u003d\u003dtoIndex}, the\n range to be sorted is empty.)  All elements in the range must be\n \u003ci\u003emutually comparable\u003c/i\u003e by the specified comparator (that is,\n {@code c.compare(e1, e2)} must not throw a {@code ClassCastException}\n for any elements {@code e1} and {@code e2} in the range).\n\n \u003cp\u003eThis sort is guaranteed to be \u003ci\u003estable\u003c/i\u003e:  equal elements will\n not be reordered as a result of the sort.\n\n \u003cp\u003eImplementation note: This implementation is a stable, adaptive,\n iterative mergesort that requires far fewer than n lg(n) comparisons\n when the input array is partially sorted, while offering the\n performance of a traditional mergesort when the input array is\n randomly ordered.  If the input array is nearly sorted, the\n implementation requires approximately n comparisons.  Temporary\n storage requirements vary from a small constant for nearly sorted\n input arrays to n/2 object references for randomly ordered input\n arrays.\n\n \u003cp\u003eThe implementation takes equal advantage of ascending and\n descending order in its input array, and can take advantage of\n ascending and descending order in different parts of the the same\n input array.  It is well-suited to merging two or more sorted arrays:\n simply concatenate the arrays and sort the resulting array.\n\n \u003cp\u003eThe implementation was adapted from Tim Peters\u0027s list sort for Python\n (\u003ca href\u003d\"http://svn.python.org/projects/python/trunk/Objects/listsort.txt\"\u003e\n TimSort\u003c/a\u003e).  It uses techniques from Peter McIlroy\u0027s \"Optimistic\n Sorting and Information Theoretic Complexity\", in Proceedings of the\n Fourth Annual ACM-SIAM Symposium on Discrete Algorithms, pp 467-474,\n January 1993.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(T[], int, int, java.util.Comparator\u003c? super T\u003e)","flatSignature":"(T[], int, int, Comparator\u003c? super T\u003e)","returnType":{"isPrimitive":true,"simpleName":"void","qualifiedName":"void","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"a","type":{"isPrimitive":false,"simpleName":"T","qualifiedName":"T","dimension":"[]","elementType":{"isPrimitive":false,"simpleName":"T","qualifiedName":"T","dimension":"","elementType":{},"typeVariable":{"name":"T","bounds":[]}},"typeVariable":{"name":"T","bounds":[]}}},{"name":"fromIndex","type":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}}},{"name":"toIndex","type":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}}},{"name":"c","type":{"isPrimitive":false,"simpleName":"Comparator","qualifiedName":"java.util.Comparator","dimension":"","elementType":{}}}],"typeParameters":[{"name":"T","bounds":[]}]},{"name":"parallelPrefix","comment":"Cumulates, in parallel, each element of the given array in place,\n using the supplied function. For example if the array initially\n holds {@code [2, 1, 0, 3]} and the operation performs addition,\n then upon return the array holds {@code [2, 3, 3, 6]}.\n Parallel prefix computation is usually more efficient than\n sequential loops for large arrays.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(T[], java.util.function.BinaryOperator\u003cT\u003e)","flatSignature":"(T[], BinaryOperator\u003cT\u003e)","returnType":{"isPrimitive":true,"simpleName":"void","qualifiedName":"void","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"array","type":{"isPrimitive":false,"simpleName":"T","qualifiedName":"T","dimension":"[]","elementType":{"isPrimitive":false,"simpleName":"T","qualifiedName":"T","dimension":"","elementType":{},"typeVariable":{"name":"T","bounds":[]}},"typeVariable":{"name":"T","bounds":[]}}},{"name":"op","type":{"isPrimitive":false,"simpleName":"BinaryOperator","qualifiedName":"java.util.function.BinaryOperator","dimension":"","elementType":{}}}],"typeParameters":[{"name":"T","bounds":[]}]},{"name":"parallelPrefix","comment":"Performs {@link #parallelPrefix(Object[], BinaryOperator)}\n for the given subrange of the array.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(T[], int, int, java.util.function.BinaryOperator\u003cT\u003e)","flatSignature":"(T[], int, int, BinaryOperator\u003cT\u003e)","returnType":{"isPrimitive":true,"simpleName":"void","qualifiedName":"void","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"array","type":{"isPrimitive":false,"simpleName":"T","qualifiedName":"T","dimension":"[]","elementType":{"isPrimitive":false,"simpleName":"T","qualifiedName":"T","dimension":"","elementType":{},"typeVariable":{"name":"T","bounds":[]}},"typeVariable":{"name":"T","bounds":[]}}},{"name":"fromIndex","type":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}}},{"name":"toIndex","type":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}}},{"name":"op","type":{"isPrimitive":false,"simpleName":"BinaryOperator","qualifiedName":"java.util.function.BinaryOperator","dimension":"","elementType":{}}}],"typeParameters":[{"name":"T","bounds":[]}]},{"name":"parallelPrefix","comment":"Cumulates, in parallel, each element of the given array in place,\n using the supplied function. For example if the array initially\n holds {@code [2, 1, 0, 3]} and the operation performs addition,\n then upon return the array holds {@code [2, 3, 3, 6]}.\n Parallel prefix computation is usually more efficient than\n sequential loops for large arrays.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(long[], java.util.function.LongBinaryOperator)","flatSignature":"(long[], LongBinaryOperator)","returnType":{"isPrimitive":true,"simpleName":"void","qualifiedName":"void","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"array","type":{"isPrimitive":true,"simpleName":"long","qualifiedName":"long","dimension":"[]","elementType":{"isPrimitive":true,"simpleName":"long","qualifiedName":"long","dimension":"","elementType":{}}}},{"name":"op","type":{"isPrimitive":false,"simpleName":"LongBinaryOperator","qualifiedName":"java.util.function.LongBinaryOperator","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"parallelPrefix","comment":"Performs {@link #parallelPrefix(long[], LongBinaryOperator)}\n for the given subrange of the array.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(long[], int, int, java.util.function.LongBinaryOperator)","flatSignature":"(long[], int, int, LongBinaryOperator)","returnType":{"isPrimitive":true,"simpleName":"void","qualifiedName":"void","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"array","type":{"isPrimitive":true,"simpleName":"long","qualifiedName":"long","dimension":"[]","elementType":{"isPrimitive":true,"simpleName":"long","qualifiedName":"long","dimension":"","elementType":{}}}},{"name":"fromIndex","type":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}}},{"name":"toIndex","type":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}}},{"name":"op","type":{"isPrimitive":false,"simpleName":"LongBinaryOperator","qualifiedName":"java.util.function.LongBinaryOperator","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"parallelPrefix","comment":"Cumulates, in parallel, each element of the given array in place,\n using the supplied function. For example if the array initially\n holds {@code [2.0, 1.0, 0.0, 3.0]} and the operation performs addition,\n then upon return the array holds {@code [2.0, 3.0, 3.0, 6.0]}.\n Parallel prefix computation is usually more efficient than\n sequential loops for large arrays.\n\n \u003cp\u003e Because floating-point operations may not be strictly associative,\n the returned result may not be identical to the value that would be\n obtained if the operation was performed sequentially.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(double[], java.util.function.DoubleBinaryOperator)","flatSignature":"(double[], DoubleBinaryOperator)","returnType":{"isPrimitive":true,"simpleName":"void","qualifiedName":"void","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"array","type":{"isPrimitive":true,"simpleName":"double","qualifiedName":"double","dimension":"[]","elementType":{"isPrimitive":true,"simpleName":"double","qualifiedName":"double","dimension":"","elementType":{}}}},{"name":"op","type":{"isPrimitive":false,"simpleName":"DoubleBinaryOperator","qualifiedName":"java.util.function.DoubleBinaryOperator","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"parallelPrefix","comment":"Performs {@link #parallelPrefix(double[], DoubleBinaryOperator)}\n for the given subrange of the array.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(double[], int, int, java.util.function.DoubleBinaryOperator)","flatSignature":"(double[], int, int, DoubleBinaryOperator)","returnType":{"isPrimitive":true,"simpleName":"void","qualifiedName":"void","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"array","type":{"isPrimitive":true,"simpleName":"double","qualifiedName":"double","dimension":"[]","elementType":{"isPrimitive":true,"simpleName":"double","qualifiedName":"double","dimension":"","elementType":{}}}},{"name":"fromIndex","type":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}}},{"name":"toIndex","type":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}}},{"name":"op","type":{"isPrimitive":false,"simpleName":"DoubleBinaryOperator","qualifiedName":"java.util.function.DoubleBinaryOperator","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"parallelPrefix","comment":"Cumulates, in parallel, each element of the given array in place,\n using the supplied function. For example if the array initially\n holds {@code [2, 1, 0, 3]} and the operation performs addition,\n then upon return the array holds {@code [2, 3, 3, 6]}.\n Parallel prefix computation is usually more efficient than\n sequential loops for large arrays.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(int[], java.util.function.IntBinaryOperator)","flatSignature":"(int[], IntBinaryOperator)","returnType":{"isPrimitive":true,"simpleName":"void","qualifiedName":"void","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"array","type":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"[]","elementType":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}}}},{"name":"op","type":{"isPrimitive":false,"simpleName":"IntBinaryOperator","qualifiedName":"java.util.function.IntBinaryOperator","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"parallelPrefix","comment":"Performs {@link #parallelPrefix(int[], IntBinaryOperator)}\n for the given subrange of the array.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(int[], int, int, java.util.function.IntBinaryOperator)","flatSignature":"(int[], int, int, IntBinaryOperator)","returnType":{"isPrimitive":true,"simpleName":"void","qualifiedName":"void","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"array","type":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"[]","elementType":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}}}},{"name":"fromIndex","type":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}}},{"name":"toIndex","type":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}}},{"name":"op","type":{"isPrimitive":false,"simpleName":"IntBinaryOperator","qualifiedName":"java.util.function.IntBinaryOperator","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"binarySearch","comment":"Searches the specified array of longs for the specified value using the\n binary search algorithm.  The array must be sorted (as\n by the {@link #sort(long[])} method) prior to making this call.  If it\n is not sorted, the results are undefined.  If the array contains\n multiple elements with the specified value, there is no guarantee which\n one will be found.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(long[], long)","flatSignature":"(long[], long)","returnType":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"a","type":{"isPrimitive":true,"simpleName":"long","qualifiedName":"long","dimension":"[]","elementType":{"isPrimitive":true,"simpleName":"long","qualifiedName":"long","dimension":"","elementType":{}}}},{"name":"key","type":{"isPrimitive":true,"simpleName":"long","qualifiedName":"long","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"binarySearch","comment":"Searches a range of\n the specified array of longs for the specified value using the\n binary search algorithm.\n The range must be sorted (as\n by the {@link #sort(long[], int, int)} method)\n prior to making this call.  If it\n is not sorted, the results are undefined.  If the range contains\n multiple elements with the specified value, there is no guarantee which\n one will be found.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(long[], int, int, long)","flatSignature":"(long[], int, int, long)","returnType":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"a","type":{"isPrimitive":true,"simpleName":"long","qualifiedName":"long","dimension":"[]","elementType":{"isPrimitive":true,"simpleName":"long","qualifiedName":"long","dimension":"","elementType":{}}}},{"name":"fromIndex","type":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}}},{"name":"toIndex","type":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}}},{"name":"key","type":{"isPrimitive":true,"simpleName":"long","qualifiedName":"long","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"binarySearch","comment":"Searches the specified array of ints for the specified value using the\n binary search algorithm.  The array must be sorted (as\n by the {@link #sort(int[])} method) prior to making this call.  If it\n is not sorted, the results are undefined.  If the array contains\n multiple elements with the specified value, there is no guarantee which\n one will be found.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(int[], int)","flatSignature":"(int[], int)","returnType":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"a","type":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"[]","elementType":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}}}},{"name":"key","type":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"binarySearch","comment":"Searches a range of\n the specified array of ints for the specified value using the\n binary search algorithm.\n The range must be sorted (as\n by the {@link #sort(int[], int, int)} method)\n prior to making this call.  If it\n is not sorted, the results are undefined.  If the range contains\n multiple elements with the specified value, there is no guarantee which\n one will be found.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(int[], int, int, int)","flatSignature":"(int[], int, int, int)","returnType":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"a","type":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"[]","elementType":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}}}},{"name":"fromIndex","type":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}}},{"name":"toIndex","type":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}}},{"name":"key","type":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"binarySearch","comment":"Searches the specified array of shorts for the specified value using\n the binary search algorithm.  The array must be sorted\n (as by the {@link #sort(short[])} method) prior to making this call.  If\n it is not sorted, the results are undefined.  If the array contains\n multiple elements with the specified value, there is no guarantee which\n one will be found.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(short[], short)","flatSignature":"(short[], short)","returnType":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"a","type":{"isPrimitive":true,"simpleName":"short","qualifiedName":"short","dimension":"[]","elementType":{"isPrimitive":true,"simpleName":"short","qualifiedName":"short","dimension":"","elementType":{}}}},{"name":"key","type":{"isPrimitive":true,"simpleName":"short","qualifiedName":"short","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"binarySearch","comment":"Searches a range of\n the specified array of shorts for the specified value using\n the binary search algorithm.\n The range must be sorted\n (as by the {@link #sort(short[], int, int)} method)\n prior to making this call.  If\n it is not sorted, the results are undefined.  If the range contains\n multiple elements with the specified value, there is no guarantee which\n one will be found.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(short[], int, int, short)","flatSignature":"(short[], int, int, short)","returnType":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"a","type":{"isPrimitive":true,"simpleName":"short","qualifiedName":"short","dimension":"[]","elementType":{"isPrimitive":true,"simpleName":"short","qualifiedName":"short","dimension":"","elementType":{}}}},{"name":"fromIndex","type":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}}},{"name":"toIndex","type":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}}},{"name":"key","type":{"isPrimitive":true,"simpleName":"short","qualifiedName":"short","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"binarySearch","comment":"Searches the specified array of chars for the specified value using the\n binary search algorithm.  The array must be sorted (as\n by the {@link #sort(char[])} method) prior to making this call.  If it\n is not sorted, the results are undefined.  If the array contains\n multiple elements with the specified value, there is no guarantee which\n one will be found.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(char[], char)","flatSignature":"(char[], char)","returnType":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"a","type":{"isPrimitive":true,"simpleName":"char","qualifiedName":"char","dimension":"[]","elementType":{"isPrimitive":true,"simpleName":"char","qualifiedName":"char","dimension":"","elementType":{}}}},{"name":"key","type":{"isPrimitive":true,"simpleName":"char","qualifiedName":"char","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"binarySearch","comment":"Searches a range of\n the specified array of chars for the specified value using the\n binary search algorithm.\n The range must be sorted (as\n by the {@link #sort(char[], int, int)} method)\n prior to making this call.  If it\n is not sorted, the results are undefined.  If the range contains\n multiple elements with the specified value, there is no guarantee which\n one will be found.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(char[], int, int, char)","flatSignature":"(char[], int, int, char)","returnType":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"a","type":{"isPrimitive":true,"simpleName":"char","qualifiedName":"char","dimension":"[]","elementType":{"isPrimitive":true,"simpleName":"char","qualifiedName":"char","dimension":"","elementType":{}}}},{"name":"fromIndex","type":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}}},{"name":"toIndex","type":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}}},{"name":"key","type":{"isPrimitive":true,"simpleName":"char","qualifiedName":"char","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"binarySearch","comment":"Searches the specified array of bytes for the specified value using the\n binary search algorithm.  The array must be sorted (as\n by the {@link #sort(byte[])} method) prior to making this call.  If it\n is not sorted, the results are undefined.  If the array contains\n multiple elements with the specified value, there is no guarantee which\n one will be found.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(byte[], byte)","flatSignature":"(byte[], byte)","returnType":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"a","type":{"isPrimitive":true,"simpleName":"byte","qualifiedName":"byte","dimension":"[]","elementType":{"isPrimitive":true,"simpleName":"byte","qualifiedName":"byte","dimension":"","elementType":{}}}},{"name":"key","type":{"isPrimitive":true,"simpleName":"byte","qualifiedName":"byte","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"binarySearch","comment":"Searches a range of\n the specified array of bytes for the specified value using the\n binary search algorithm.\n The range must be sorted (as\n by the {@link #sort(byte[], int, int)} method)\n prior to making this call.  If it\n is not sorted, the results are undefined.  If the range contains\n multiple elements with the specified value, there is no guarantee which\n one will be found.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(byte[], int, int, byte)","flatSignature":"(byte[], int, int, byte)","returnType":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"a","type":{"isPrimitive":true,"simpleName":"byte","qualifiedName":"byte","dimension":"[]","elementType":{"isPrimitive":true,"simpleName":"byte","qualifiedName":"byte","dimension":"","elementType":{}}}},{"name":"fromIndex","type":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}}},{"name":"toIndex","type":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}}},{"name":"key","type":{"isPrimitive":true,"simpleName":"byte","qualifiedName":"byte","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"binarySearch","comment":"Searches the specified array of doubles for the specified value using\n the binary search algorithm.  The array must be sorted\n (as by the {@link #sort(double[])} method) prior to making this call.\n If it is not sorted, the results are undefined.  If the array contains\n multiple elements with the specified value, there is no guarantee which\n one will be found.  This method considers all NaN values to be\n equivalent and equal.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(double[], double)","flatSignature":"(double[], double)","returnType":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"a","type":{"isPrimitive":true,"simpleName":"double","qualifiedName":"double","dimension":"[]","elementType":{"isPrimitive":true,"simpleName":"double","qualifiedName":"double","dimension":"","elementType":{}}}},{"name":"key","type":{"isPrimitive":true,"simpleName":"double","qualifiedName":"double","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"binarySearch","comment":"Searches a range of\n the specified array of doubles for the specified value using\n the binary search algorithm.\n The range must be sorted\n (as by the {@link #sort(double[], int, int)} method)\n prior to making this call.\n If it is not sorted, the results are undefined.  If the range contains\n multiple elements with the specified value, there is no guarantee which\n one will be found.  This method considers all NaN values to be\n equivalent and equal.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(double[], int, int, double)","flatSignature":"(double[], int, int, double)","returnType":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"a","type":{"isPrimitive":true,"simpleName":"double","qualifiedName":"double","dimension":"[]","elementType":{"isPrimitive":true,"simpleName":"double","qualifiedName":"double","dimension":"","elementType":{}}}},{"name":"fromIndex","type":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}}},{"name":"toIndex","type":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}}},{"name":"key","type":{"isPrimitive":true,"simpleName":"double","qualifiedName":"double","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"binarySearch","comment":"Searches the specified array of floats for the specified value using\n the binary search algorithm. The array must be sorted\n (as by the {@link #sort(float[])} method) prior to making this call. If\n it is not sorted, the results are undefined. If the array contains\n multiple elements with the specified value, there is no guarantee which\n one will be found. This method considers all NaN values to be\n equivalent and equal.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(float[], float)","flatSignature":"(float[], float)","returnType":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"a","type":{"isPrimitive":true,"simpleName":"float","qualifiedName":"float","dimension":"[]","elementType":{"isPrimitive":true,"simpleName":"float","qualifiedName":"float","dimension":"","elementType":{}}}},{"name":"key","type":{"isPrimitive":true,"simpleName":"float","qualifiedName":"float","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"binarySearch","comment":"Searches a range of\n the specified array of floats for the specified value using\n the binary search algorithm.\n The range must be sorted\n (as by the {@link #sort(float[], int, int)} method)\n prior to making this call. If\n it is not sorted, the results are undefined. If the range contains\n multiple elements with the specified value, there is no guarantee which\n one will be found. This method considers all NaN values to be\n equivalent and equal.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(float[], int, int, float)","flatSignature":"(float[], int, int, float)","returnType":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"a","type":{"isPrimitive":true,"simpleName":"float","qualifiedName":"float","dimension":"[]","elementType":{"isPrimitive":true,"simpleName":"float","qualifiedName":"float","dimension":"","elementType":{}}}},{"name":"fromIndex","type":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}}},{"name":"toIndex","type":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}}},{"name":"key","type":{"isPrimitive":true,"simpleName":"float","qualifiedName":"float","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"binarySearch","comment":"Searches the specified array for the specified object using the binary\n search algorithm. The array must be sorted into ascending order\n according to the\n {@linkplain Comparable natural ordering}\n of its elements (as by the\n {@link #sort(Object[])} method) prior to making this call.\n If it is not sorted, the results are undefined.\n (If the array contains elements that are not mutually comparable (for\n example, strings and integers), it \u003ci\u003ecannot\u003c/i\u003e be sorted according\n to the natural ordering of its elements, hence results are undefined.)\n If the array contains multiple\n elements equal to the specified object, there is no guarantee which\n one will be found.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.lang.Object[], java.lang.Object)","flatSignature":"(Object[], Object)","returnType":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"a","type":{"isPrimitive":false,"simpleName":"Object","qualifiedName":"java.lang.Object","dimension":"[]","elementType":{"isPrimitive":false,"simpleName":"Object","qualifiedName":"java.lang.Object","dimension":"","elementType":{}}}},{"name":"key","type":{"isPrimitive":false,"simpleName":"Object","qualifiedName":"java.lang.Object","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"binarySearch","comment":"Searches a range of\n the specified array for the specified object using the binary\n search algorithm.\n The range must be sorted into ascending order\n according to the\n {@linkplain Comparable natural ordering}\n of its elements (as by the\n {@link #sort(Object[], int, int)} method) prior to making this\n call.  If it is not sorted, the results are undefined.\n (If the range contains elements that are not mutually comparable (for\n example, strings and integers), it \u003ci\u003ecannot\u003c/i\u003e be sorted according\n to the natural ordering of its elements, hence results are undefined.)\n If the range contains multiple\n elements equal to the specified object, there is no guarantee which\n one will be found.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.lang.Object[], int, int, java.lang.Object)","flatSignature":"(Object[], int, int, Object)","returnType":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"a","type":{"isPrimitive":false,"simpleName":"Object","qualifiedName":"java.lang.Object","dimension":"[]","elementType":{"isPrimitive":false,"simpleName":"Object","qualifiedName":"java.lang.Object","dimension":"","elementType":{}}}},{"name":"fromIndex","type":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}}},{"name":"toIndex","type":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}}},{"name":"key","type":{"isPrimitive":false,"simpleName":"Object","qualifiedName":"java.lang.Object","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"binarySearch","comment":"Searches the specified array for the specified object using the binary\n search algorithm.  The array must be sorted into ascending order\n according to the specified comparator (as by the\n {@link #sort(Object[], Comparator) sort(T[], Comparator)}\n method) prior to making this call.  If it is\n not sorted, the results are undefined.\n If the array contains multiple\n elements equal to the specified object, there is no guarantee which one\n will be found.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(T[], T, java.util.Comparator\u003c? super T\u003e)","flatSignature":"(T[], T, Comparator\u003c? super T\u003e)","returnType":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"a","type":{"isPrimitive":false,"simpleName":"T","qualifiedName":"T","dimension":"[]","elementType":{"isPrimitive":false,"simpleName":"T","qualifiedName":"T","dimension":"","elementType":{},"typeVariable":{"name":"T","bounds":[]}},"typeVariable":{"name":"T","bounds":[]}}},{"name":"key","type":{"isPrimitive":false,"simpleName":"T","qualifiedName":"T","dimension":"","elementType":{},"typeVariable":{"name":"T","bounds":[]}}},{"name":"c","type":{"isPrimitive":false,"simpleName":"Comparator","qualifiedName":"java.util.Comparator","dimension":"","elementType":{}}}],"typeParameters":[{"name":"T","bounds":[]}]},{"name":"binarySearch","comment":"Searches a range of\n the specified array for the specified object using the binary\n search algorithm.\n The range must be sorted into ascending order\n according to the specified comparator (as by the\n {@link #sort(Object[], int, int, Comparator)\n sort(T[], int, int, Comparator)}\n method) prior to making this call.\n If it is not sorted, the results are undefined.\n If the range contains multiple elements equal to the specified object,\n there is no guarantee which one will be found.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(T[], int, int, T, java.util.Comparator\u003c? super T\u003e)","flatSignature":"(T[], int, int, T, Comparator\u003c? super T\u003e)","returnType":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"a","type":{"isPrimitive":false,"simpleName":"T","qualifiedName":"T","dimension":"[]","elementType":{"isPrimitive":false,"simpleName":"T","qualifiedName":"T","dimension":"","elementType":{},"typeVariable":{"name":"T","bounds":[]}},"typeVariable":{"name":"T","bounds":[]}}},{"name":"fromIndex","type":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}}},{"name":"toIndex","type":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}}},{"name":"key","type":{"isPrimitive":false,"simpleName":"T","qualifiedName":"T","dimension":"","elementType":{},"typeVariable":{"name":"T","bounds":[]}}},{"name":"c","type":{"isPrimitive":false,"simpleName":"Comparator","qualifiedName":"java.util.Comparator","dimension":"","elementType":{}}}],"typeParameters":[{"name":"T","bounds":[]}]},{"name":"equals","comment":"Returns \u003ctt\u003etrue\u003c/tt\u003e if the two specified arrays of longs are\n \u003ci\u003eequal\u003c/i\u003e to one another.  Two arrays are considered equal if both\n arrays contain the same number of elements, and all corresponding pairs\n of elements in the two arrays are equal.  In other words, two arrays\n are equal if they contain the same elements in the same order.  Also,\n two array references are considered equal if both are \u003ctt\u003enull\u003c/tt\u003e.\u003cp\u003e","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(long[], long[])","flatSignature":"(long[], long[])","returnType":{"isPrimitive":true,"simpleName":"boolean","qualifiedName":"boolean","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"a","type":{"isPrimitive":true,"simpleName":"long","qualifiedName":"long","dimension":"[]","elementType":{"isPrimitive":true,"simpleName":"long","qualifiedName":"long","dimension":"","elementType":{}}}},{"name":"a2","type":{"isPrimitive":true,"simpleName":"long","qualifiedName":"long","dimension":"[]","elementType":{"isPrimitive":true,"simpleName":"long","qualifiedName":"long","dimension":"","elementType":{}}}}],"typeParameters":[]},{"name":"equals","comment":"Returns \u003ctt\u003etrue\u003c/tt\u003e if the two specified arrays of ints are\n \u003ci\u003eequal\u003c/i\u003e to one another.  Two arrays are considered equal if both\n arrays contain the same number of elements, and all corresponding pairs\n of elements in the two arrays are equal.  In other words, two arrays\n are equal if they contain the same elements in the same order.  Also,\n two array references are considered equal if both are \u003ctt\u003enull\u003c/tt\u003e.\u003cp\u003e","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(int[], int[])","flatSignature":"(int[], int[])","returnType":{"isPrimitive":true,"simpleName":"boolean","qualifiedName":"boolean","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"a","type":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"[]","elementType":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}}}},{"name":"a2","type":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"[]","elementType":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}}}}],"typeParameters":[]},{"name":"equals","comment":"Returns \u003ctt\u003etrue\u003c/tt\u003e if the two specified arrays of shorts are\n \u003ci\u003eequal\u003c/i\u003e to one another.  Two arrays are considered equal if both\n arrays contain the same number of elements, and all corresponding pairs\n of elements in the two arrays are equal.  In other words, two arrays\n are equal if they contain the same elements in the same order.  Also,\n two array references are considered equal if both are \u003ctt\u003enull\u003c/tt\u003e.\u003cp\u003e","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(short[], short[])","flatSignature":"(short[], short[])","returnType":{"isPrimitive":true,"simpleName":"boolean","qualifiedName":"boolean","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"a","type":{"isPrimitive":true,"simpleName":"short","qualifiedName":"short","dimension":"[]","elementType":{"isPrimitive":true,"simpleName":"short","qualifiedName":"short","dimension":"","elementType":{}}}},{"name":"a2","type":{"isPrimitive":true,"simpleName":"short","qualifiedName":"short","dimension":"[]","elementType":{"isPrimitive":true,"simpleName":"short","qualifiedName":"short","dimension":"","elementType":{}}}}],"typeParameters":[]},{"name":"equals","comment":"Returns \u003ctt\u003etrue\u003c/tt\u003e if the two specified arrays of chars are\n \u003ci\u003eequal\u003c/i\u003e to one another.  Two arrays are considered equal if both\n arrays contain the same number of elements, and all corresponding pairs\n of elements in the two arrays are equal.  In other words, two arrays\n are equal if they contain the same elements in the same order.  Also,\n two array references are considered equal if both are \u003ctt\u003enull\u003c/tt\u003e.\u003cp\u003e","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(char[], char[])","flatSignature":"(char[], char[])","returnType":{"isPrimitive":true,"simpleName":"boolean","qualifiedName":"boolean","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"a","type":{"isPrimitive":true,"simpleName":"char","qualifiedName":"char","dimension":"[]","elementType":{"isPrimitive":true,"simpleName":"char","qualifiedName":"char","dimension":"","elementType":{}}}},{"name":"a2","type":{"isPrimitive":true,"simpleName":"char","qualifiedName":"char","dimension":"[]","elementType":{"isPrimitive":true,"simpleName":"char","qualifiedName":"char","dimension":"","elementType":{}}}}],"typeParameters":[]},{"name":"equals","comment":"Returns \u003ctt\u003etrue\u003c/tt\u003e if the two specified arrays of bytes are\n \u003ci\u003eequal\u003c/i\u003e to one another.  Two arrays are considered equal if both\n arrays contain the same number of elements, and all corresponding pairs\n of elements in the two arrays are equal.  In other words, two arrays\n are equal if they contain the same elements in the same order.  Also,\n two array references are considered equal if both are \u003ctt\u003enull\u003c/tt\u003e.\u003cp\u003e","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(byte[], byte[])","flatSignature":"(byte[], byte[])","returnType":{"isPrimitive":true,"simpleName":"boolean","qualifiedName":"boolean","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"a","type":{"isPrimitive":true,"simpleName":"byte","qualifiedName":"byte","dimension":"[]","elementType":{"isPrimitive":true,"simpleName":"byte","qualifiedName":"byte","dimension":"","elementType":{}}}},{"name":"a2","type":{"isPrimitive":true,"simpleName":"byte","qualifiedName":"byte","dimension":"[]","elementType":{"isPrimitive":true,"simpleName":"byte","qualifiedName":"byte","dimension":"","elementType":{}}}}],"typeParameters":[]},{"name":"equals","comment":"Returns \u003ctt\u003etrue\u003c/tt\u003e if the two specified arrays of booleans are\n \u003ci\u003eequal\u003c/i\u003e to one another.  Two arrays are considered equal if both\n arrays contain the same number of elements, and all corresponding pairs\n of elements in the two arrays are equal.  In other words, two arrays\n are equal if they contain the same elements in the same order.  Also,\n two array references are considered equal if both are \u003ctt\u003enull\u003c/tt\u003e.\u003cp\u003e","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(boolean[], boolean[])","flatSignature":"(boolean[], boolean[])","returnType":{"isPrimitive":true,"simpleName":"boolean","qualifiedName":"boolean","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"a","type":{"isPrimitive":true,"simpleName":"boolean","qualifiedName":"boolean","dimension":"[]","elementType":{"isPrimitive":true,"simpleName":"boolean","qualifiedName":"boolean","dimension":"","elementType":{}}}},{"name":"a2","type":{"isPrimitive":true,"simpleName":"boolean","qualifiedName":"boolean","dimension":"[]","elementType":{"isPrimitive":true,"simpleName":"boolean","qualifiedName":"boolean","dimension":"","elementType":{}}}}],"typeParameters":[]},{"name":"equals","comment":"Returns \u003ctt\u003etrue\u003c/tt\u003e if the two specified arrays of doubles are\n \u003ci\u003eequal\u003c/i\u003e to one another.  Two arrays are considered equal if both\n arrays contain the same number of elements, and all corresponding pairs\n of elements in the two arrays are equal.  In other words, two arrays\n are equal if they contain the same elements in the same order.  Also,\n two array references are considered equal if both are \u003ctt\u003enull\u003c/tt\u003e.\u003cp\u003e\n\n Two doubles \u003ctt\u003ed1\u003c/tt\u003e and \u003ctt\u003ed2\u003c/tt\u003e are considered equal if:\n \u003cpre\u003e    \u003ctt\u003enew Double(d1).equals(new Double(d2))\u003c/tt\u003e\u003c/pre\u003e\n (Unlike the \u003ctt\u003e\u003d\u003d\u003c/tt\u003e operator, this method considers\n \u003ctt\u003eNaN\u003c/tt\u003e equals to itself, and 0.0d unequal to -0.0d.)","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(double[], double[])","flatSignature":"(double[], double[])","returnType":{"isPrimitive":true,"simpleName":"boolean","qualifiedName":"boolean","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"a","type":{"isPrimitive":true,"simpleName":"double","qualifiedName":"double","dimension":"[]","elementType":{"isPrimitive":true,"simpleName":"double","qualifiedName":"double","dimension":"","elementType":{}}}},{"name":"a2","type":{"isPrimitive":true,"simpleName":"double","qualifiedName":"double","dimension":"[]","elementType":{"isPrimitive":true,"simpleName":"double","qualifiedName":"double","dimension":"","elementType":{}}}}],"typeParameters":[]},{"name":"equals","comment":"Returns \u003ctt\u003etrue\u003c/tt\u003e if the two specified arrays of floats are\n \u003ci\u003eequal\u003c/i\u003e to one another.  Two arrays are considered equal if both\n arrays contain the same number of elements, and all corresponding pairs\n of elements in the two arrays are equal.  In other words, two arrays\n are equal if they contain the same elements in the same order.  Also,\n two array references are considered equal if both are \u003ctt\u003enull\u003c/tt\u003e.\u003cp\u003e\n\n Two floats \u003ctt\u003ef1\u003c/tt\u003e and \u003ctt\u003ef2\u003c/tt\u003e are considered equal if:\n \u003cpre\u003e    \u003ctt\u003enew Float(f1).equals(new Float(f2))\u003c/tt\u003e\u003c/pre\u003e\n (Unlike the \u003ctt\u003e\u003d\u003d\u003c/tt\u003e operator, this method considers\n \u003ctt\u003eNaN\u003c/tt\u003e equals to itself, and 0.0f unequal to -0.0f.)","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(float[], float[])","flatSignature":"(float[], float[])","returnType":{"isPrimitive":true,"simpleName":"boolean","qualifiedName":"boolean","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"a","type":{"isPrimitive":true,"simpleName":"float","qualifiedName":"float","dimension":"[]","elementType":{"isPrimitive":true,"simpleName":"float","qualifiedName":"float","dimension":"","elementType":{}}}},{"name":"a2","type":{"isPrimitive":true,"simpleName":"float","qualifiedName":"float","dimension":"[]","elementType":{"isPrimitive":true,"simpleName":"float","qualifiedName":"float","dimension":"","elementType":{}}}}],"typeParameters":[]},{"name":"equals","comment":"Returns \u003ctt\u003etrue\u003c/tt\u003e if the two specified arrays of Objects are\n \u003ci\u003eequal\u003c/i\u003e to one another.  The two arrays are considered equal if\n both arrays contain the same number of elements, and all corresponding\n pairs of elements in the two arrays are equal.  Two objects \u003ctt\u003ee1\u003c/tt\u003e\n and \u003ctt\u003ee2\u003c/tt\u003e are considered \u003ci\u003eequal\u003c/i\u003e if \u003ctt\u003e(e1\u003d\u003dnull ? e2\u003d\u003dnull\n : e1.equals(e2))\u003c/tt\u003e.  In other words, the two arrays are equal if\n they contain the same elements in the same order.  Also, two array\n references are considered equal if both are \u003ctt\u003enull\u003c/tt\u003e.\u003cp\u003e","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.lang.Object[], java.lang.Object[])","flatSignature":"(Object[], Object[])","returnType":{"isPrimitive":true,"simpleName":"boolean","qualifiedName":"boolean","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"a","type":{"isPrimitive":false,"simpleName":"Object","qualifiedName":"java.lang.Object","dimension":"[]","elementType":{"isPrimitive":false,"simpleName":"Object","qualifiedName":"java.lang.Object","dimension":"","elementType":{}}}},{"name":"a2","type":{"isPrimitive":false,"simpleName":"Object","qualifiedName":"java.lang.Object","dimension":"[]","elementType":{"isPrimitive":false,"simpleName":"Object","qualifiedName":"java.lang.Object","dimension":"","elementType":{}}}}],"typeParameters":[]},{"name":"fill","comment":"Assigns the specified long value to each element of the specified array\n of longs.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(long[], long)","flatSignature":"(long[], long)","returnType":{"isPrimitive":true,"simpleName":"void","qualifiedName":"void","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"a","type":{"isPrimitive":true,"simpleName":"long","qualifiedName":"long","dimension":"[]","elementType":{"isPrimitive":true,"simpleName":"long","qualifiedName":"long","dimension":"","elementType":{}}}},{"name":"val","type":{"isPrimitive":true,"simpleName":"long","qualifiedName":"long","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"fill","comment":"Assigns the specified long value to each element of the specified\n range of the specified array of longs.  The range to be filled\n extends from index \u003ctt\u003efromIndex\u003c/tt\u003e, inclusive, to index\n \u003ctt\u003etoIndex\u003c/tt\u003e, exclusive.  (If \u003ctt\u003efromIndex\u003d\u003dtoIndex\u003c/tt\u003e, the\n range to be filled is empty.)","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(long[], int, int, long)","flatSignature":"(long[], int, int, long)","returnType":{"isPrimitive":true,"simpleName":"void","qualifiedName":"void","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"a","type":{"isPrimitive":true,"simpleName":"long","qualifiedName":"long","dimension":"[]","elementType":{"isPrimitive":true,"simpleName":"long","qualifiedName":"long","dimension":"","elementType":{}}}},{"name":"fromIndex","type":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}}},{"name":"toIndex","type":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}}},{"name":"val","type":{"isPrimitive":true,"simpleName":"long","qualifiedName":"long","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"fill","comment":"Assigns the specified int value to each element of the specified array\n of ints.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(int[], int)","flatSignature":"(int[], int)","returnType":{"isPrimitive":true,"simpleName":"void","qualifiedName":"void","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"a","type":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"[]","elementType":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}}}},{"name":"val","type":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"fill","comment":"Assigns the specified int value to each element of the specified\n range of the specified array of ints.  The range to be filled\n extends from index \u003ctt\u003efromIndex\u003c/tt\u003e, inclusive, to index\n \u003ctt\u003etoIndex\u003c/tt\u003e, exclusive.  (If \u003ctt\u003efromIndex\u003d\u003dtoIndex\u003c/tt\u003e, the\n range to be filled is empty.)","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(int[], int, int, int)","flatSignature":"(int[], int, int, int)","returnType":{"isPrimitive":true,"simpleName":"void","qualifiedName":"void","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"a","type":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"[]","elementType":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}}}},{"name":"fromIndex","type":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}}},{"name":"toIndex","type":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}}},{"name":"val","type":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"fill","comment":"Assigns the specified short value to each element of the specified array\n of shorts.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(short[], short)","flatSignature":"(short[], short)","returnType":{"isPrimitive":true,"simpleName":"void","qualifiedName":"void","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"a","type":{"isPrimitive":true,"simpleName":"short","qualifiedName":"short","dimension":"[]","elementType":{"isPrimitive":true,"simpleName":"short","qualifiedName":"short","dimension":"","elementType":{}}}},{"name":"val","type":{"isPrimitive":true,"simpleName":"short","qualifiedName":"short","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"fill","comment":"Assigns the specified short value to each element of the specified\n range of the specified array of shorts.  The range to be filled\n extends from index \u003ctt\u003efromIndex\u003c/tt\u003e, inclusive, to index\n \u003ctt\u003etoIndex\u003c/tt\u003e, exclusive.  (If \u003ctt\u003efromIndex\u003d\u003dtoIndex\u003c/tt\u003e, the\n range to be filled is empty.)","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(short[], int, int, short)","flatSignature":"(short[], int, int, short)","returnType":{"isPrimitive":true,"simpleName":"void","qualifiedName":"void","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"a","type":{"isPrimitive":true,"simpleName":"short","qualifiedName":"short","dimension":"[]","elementType":{"isPrimitive":true,"simpleName":"short","qualifiedName":"short","dimension":"","elementType":{}}}},{"name":"fromIndex","type":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}}},{"name":"toIndex","type":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}}},{"name":"val","type":{"isPrimitive":true,"simpleName":"short","qualifiedName":"short","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"fill","comment":"Assigns the specified char value to each element of the specified array\n of chars.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(char[], char)","flatSignature":"(char[], char)","returnType":{"isPrimitive":true,"simpleName":"void","qualifiedName":"void","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"a","type":{"isPrimitive":true,"simpleName":"char","qualifiedName":"char","dimension":"[]","elementType":{"isPrimitive":true,"simpleName":"char","qualifiedName":"char","dimension":"","elementType":{}}}},{"name":"val","type":{"isPrimitive":true,"simpleName":"char","qualifiedName":"char","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"fill","comment":"Assigns the specified char value to each element of the specified\n range of the specified array of chars.  The range to be filled\n extends from index \u003ctt\u003efromIndex\u003c/tt\u003e, inclusive, to index\n \u003ctt\u003etoIndex\u003c/tt\u003e, exclusive.  (If \u003ctt\u003efromIndex\u003d\u003dtoIndex\u003c/tt\u003e, the\n range to be filled is empty.)","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(char[], int, int, char)","flatSignature":"(char[], int, int, char)","returnType":{"isPrimitive":true,"simpleName":"void","qualifiedName":"void","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"a","type":{"isPrimitive":true,"simpleName":"char","qualifiedName":"char","dimension":"[]","elementType":{"isPrimitive":true,"simpleName":"char","qualifiedName":"char","dimension":"","elementType":{}}}},{"name":"fromIndex","type":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}}},{"name":"toIndex","type":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}}},{"name":"val","type":{"isPrimitive":true,"simpleName":"char","qualifiedName":"char","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"fill","comment":"Assigns the specified byte value to each element of the specified array\n of bytes.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(byte[], byte)","flatSignature":"(byte[], byte)","returnType":{"isPrimitive":true,"simpleName":"void","qualifiedName":"void","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"a","type":{"isPrimitive":true,"simpleName":"byte","qualifiedName":"byte","dimension":"[]","elementType":{"isPrimitive":true,"simpleName":"byte","qualifiedName":"byte","dimension":"","elementType":{}}}},{"name":"val","type":{"isPrimitive":true,"simpleName":"byte","qualifiedName":"byte","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"fill","comment":"Assigns the specified byte value to each element of the specified\n range of the specified array of bytes.  The range to be filled\n extends from index \u003ctt\u003efromIndex\u003c/tt\u003e, inclusive, to index\n \u003ctt\u003etoIndex\u003c/tt\u003e, exclusive.  (If \u003ctt\u003efromIndex\u003d\u003dtoIndex\u003c/tt\u003e, the\n range to be filled is empty.)","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(byte[], int, int, byte)","flatSignature":"(byte[], int, int, byte)","returnType":{"isPrimitive":true,"simpleName":"void","qualifiedName":"void","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"a","type":{"isPrimitive":true,"simpleName":"byte","qualifiedName":"byte","dimension":"[]","elementType":{"isPrimitive":true,"simpleName":"byte","qualifiedName":"byte","dimension":"","elementType":{}}}},{"name":"fromIndex","type":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}}},{"name":"toIndex","type":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}}},{"name":"val","type":{"isPrimitive":true,"simpleName":"byte","qualifiedName":"byte","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"fill","comment":"Assigns the specified boolean value to each element of the specified\n array of booleans.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(boolean[], boolean)","flatSignature":"(boolean[], boolean)","returnType":{"isPrimitive":true,"simpleName":"void","qualifiedName":"void","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"a","type":{"isPrimitive":true,"simpleName":"boolean","qualifiedName":"boolean","dimension":"[]","elementType":{"isPrimitive":true,"simpleName":"boolean","qualifiedName":"boolean","dimension":"","elementType":{}}}},{"name":"val","type":{"isPrimitive":true,"simpleName":"boolean","qualifiedName":"boolean","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"fill","comment":"Assigns the specified boolean value to each element of the specified\n range of the specified array of booleans.  The range to be filled\n extends from index \u003ctt\u003efromIndex\u003c/tt\u003e, inclusive, to index\n \u003ctt\u003etoIndex\u003c/tt\u003e, exclusive.  (If \u003ctt\u003efromIndex\u003d\u003dtoIndex\u003c/tt\u003e, the\n range to be filled is empty.)","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(boolean[], int, int, boolean)","flatSignature":"(boolean[], int, int, boolean)","returnType":{"isPrimitive":true,"simpleName":"void","qualifiedName":"void","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"a","type":{"isPrimitive":true,"simpleName":"boolean","qualifiedName":"boolean","dimension":"[]","elementType":{"isPrimitive":true,"simpleName":"boolean","qualifiedName":"boolean","dimension":"","elementType":{}}}},{"name":"fromIndex","type":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}}},{"name":"toIndex","type":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}}},{"name":"val","type":{"isPrimitive":true,"simpleName":"boolean","qualifiedName":"boolean","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"fill","comment":"Assigns the specified double value to each element of the specified\n array of doubles.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(double[], double)","flatSignature":"(double[], double)","returnType":{"isPrimitive":true,"simpleName":"void","qualifiedName":"void","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"a","type":{"isPrimitive":true,"simpleName":"double","qualifiedName":"double","dimension":"[]","elementType":{"isPrimitive":true,"simpleName":"double","qualifiedName":"double","dimension":"","elementType":{}}}},{"name":"val","type":{"isPrimitive":true,"simpleName":"double","qualifiedName":"double","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"fill","comment":"Assigns the specified double value to each element of the specified\n range of the specified array of doubles.  The range to be filled\n extends from index \u003ctt\u003efromIndex\u003c/tt\u003e, inclusive, to index\n \u003ctt\u003etoIndex\u003c/tt\u003e, exclusive.  (If \u003ctt\u003efromIndex\u003d\u003dtoIndex\u003c/tt\u003e, the\n range to be filled is empty.)","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(double[], int, int, double)","flatSignature":"(double[], int, int, double)","returnType":{"isPrimitive":true,"simpleName":"void","qualifiedName":"void","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"a","type":{"isPrimitive":true,"simpleName":"double","qualifiedName":"double","dimension":"[]","elementType":{"isPrimitive":true,"simpleName":"double","qualifiedName":"double","dimension":"","elementType":{}}}},{"name":"fromIndex","type":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}}},{"name":"toIndex","type":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}}},{"name":"val","type":{"isPrimitive":true,"simpleName":"double","qualifiedName":"double","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"fill","comment":"Assigns the specified float value to each element of the specified array\n of floats.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(float[], float)","flatSignature":"(float[], float)","returnType":{"isPrimitive":true,"simpleName":"void","qualifiedName":"void","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"a","type":{"isPrimitive":true,"simpleName":"float","qualifiedName":"float","dimension":"[]","elementType":{"isPrimitive":true,"simpleName":"float","qualifiedName":"float","dimension":"","elementType":{}}}},{"name":"val","type":{"isPrimitive":true,"simpleName":"float","qualifiedName":"float","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"fill","comment":"Assigns the specified float value to each element of the specified\n range of the specified array of floats.  The range to be filled\n extends from index \u003ctt\u003efromIndex\u003c/tt\u003e, inclusive, to index\n \u003ctt\u003etoIndex\u003c/tt\u003e, exclusive.  (If \u003ctt\u003efromIndex\u003d\u003dtoIndex\u003c/tt\u003e, the\n range to be filled is empty.)","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(float[], int, int, float)","flatSignature":"(float[], int, int, float)","returnType":{"isPrimitive":true,"simpleName":"void","qualifiedName":"void","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"a","type":{"isPrimitive":true,"simpleName":"float","qualifiedName":"float","dimension":"[]","elementType":{"isPrimitive":true,"simpleName":"float","qualifiedName":"float","dimension":"","elementType":{}}}},{"name":"fromIndex","type":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}}},{"name":"toIndex","type":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}}},{"name":"val","type":{"isPrimitive":true,"simpleName":"float","qualifiedName":"float","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"fill","comment":"Assigns the specified Object reference to each element of the specified\n array of Objects.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.lang.Object[], java.lang.Object)","flatSignature":"(Object[], Object)","returnType":{"isPrimitive":true,"simpleName":"void","qualifiedName":"void","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"a","type":{"isPrimitive":false,"simpleName":"Object","qualifiedName":"java.lang.Object","dimension":"[]","elementType":{"isPrimitive":false,"simpleName":"Object","qualifiedName":"java.lang.Object","dimension":"","elementType":{}}}},{"name":"val","type":{"isPrimitive":false,"simpleName":"Object","qualifiedName":"java.lang.Object","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"fill","comment":"Assigns the specified Object reference to each element of the specified\n range of the specified array of Objects.  The range to be filled\n extends from index \u003ctt\u003efromIndex\u003c/tt\u003e, inclusive, to index\n \u003ctt\u003etoIndex\u003c/tt\u003e, exclusive.  (If \u003ctt\u003efromIndex\u003d\u003dtoIndex\u003c/tt\u003e, the\n range to be filled is empty.)","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.lang.Object[], int, int, java.lang.Object)","flatSignature":"(Object[], int, int, Object)","returnType":{"isPrimitive":true,"simpleName":"void","qualifiedName":"void","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"a","type":{"isPrimitive":false,"simpleName":"Object","qualifiedName":"java.lang.Object","dimension":"[]","elementType":{"isPrimitive":false,"simpleName":"Object","qualifiedName":"java.lang.Object","dimension":"","elementType":{}}}},{"name":"fromIndex","type":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}}},{"name":"toIndex","type":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}}},{"name":"val","type":{"isPrimitive":false,"simpleName":"Object","qualifiedName":"java.lang.Object","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"copyOf","comment":"Copies the specified array, truncating or padding with nulls (if necessary)\n so the copy has the specified length.  For all indices that are\n valid in both the original array and the copy, the two arrays will\n contain identical values.  For any indices that are valid in the\n copy but not the original, the copy will contain \u003ctt\u003enull\u003c/tt\u003e.\n Such indices will exist if and only if the specified length\n is greater than that of the original array.\n The resulting array is of exactly the same class as the original array.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(T[], int)","flatSignature":"(T[], int)","returnType":{"isPrimitive":false,"simpleName":"T","qualifiedName":"T","dimension":"[]","elementType":{"isPrimitive":false,"simpleName":"T","qualifiedName":"T","dimension":"","elementType":{},"typeVariable":{"name":"T","bounds":[]}},"typeVariable":{"name":"T","bounds":[]}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"original","type":{"isPrimitive":false,"simpleName":"T","qualifiedName":"T","dimension":"[]","elementType":{"isPrimitive":false,"simpleName":"T","qualifiedName":"T","dimension":"","elementType":{},"typeVariable":{"name":"T","bounds":[]}},"typeVariable":{"name":"T","bounds":[]}}},{"name":"newLength","type":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}}}],"typeParameters":[{"name":"T","bounds":[]}]},{"name":"copyOf","comment":"Copies the specified array, truncating or padding with nulls (if necessary)\n so the copy has the specified length.  For all indices that are\n valid in both the original array and the copy, the two arrays will\n contain identical values.  For any indices that are valid in the\n copy but not the original, the copy will contain \u003ctt\u003enull\u003c/tt\u003e.\n Such indices will exist if and only if the specified length\n is greater than that of the original array.\n The resulting array is of the class \u003ctt\u003enewType\u003c/tt\u003e.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(U[], int, java.lang.Class\u003c? extends T[]\u003e)","flatSignature":"(U[], int, Class\u003c? extends T[]\u003e)","returnType":{"isPrimitive":false,"simpleName":"T","qualifiedName":"T","dimension":"[]","elementType":{"isPrimitive":false,"simpleName":"T","qualifiedName":"T","dimension":"","elementType":{},"typeVariable":{"name":"T","bounds":[]}},"typeVariable":{"name":"T","bounds":[]}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"original","type":{"isPrimitive":false,"simpleName":"U","qualifiedName":"U","dimension":"[]","elementType":{"isPrimitive":false,"simpleName":"U","qualifiedName":"U","dimension":"","elementType":{},"typeVariable":{"name":"U","bounds":[]}},"typeVariable":{"name":"U","bounds":[]}}},{"name":"newLength","type":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}}},{"name":"newType","type":{"isPrimitive":false,"simpleName":"Class","qualifiedName":"java.lang.Class","dimension":"","elementType":{}}}],"typeParameters":[{"name":"T","bounds":[]},{"name":"U","bounds":[]}]},{"name":"copyOf","comment":"Copies the specified array, truncating or padding with zeros (if necessary)\n so the copy has the specified length.  For all indices that are\n valid in both the original array and the copy, the two arrays will\n contain identical values.  For any indices that are valid in the\n copy but not the original, the copy will contain \u003ctt\u003e(byte)0\u003c/tt\u003e.\n Such indices will exist if and only if the specified length\n is greater than that of the original array.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(byte[], int)","flatSignature":"(byte[], int)","returnType":{"isPrimitive":true,"simpleName":"byte","qualifiedName":"byte","dimension":"[]","elementType":{"isPrimitive":true,"simpleName":"byte","qualifiedName":"byte","dimension":"","elementType":{}}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"original","type":{"isPrimitive":true,"simpleName":"byte","qualifiedName":"byte","dimension":"[]","elementType":{"isPrimitive":true,"simpleName":"byte","qualifiedName":"byte","dimension":"","elementType":{}}}},{"name":"newLength","type":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"copyOf","comment":"Copies the specified array, truncating or padding with zeros (if necessary)\n so the copy has the specified length.  For all indices that are\n valid in both the original array and the copy, the two arrays will\n contain identical values.  For any indices that are valid in the\n copy but not the original, the copy will contain \u003ctt\u003e(short)0\u003c/tt\u003e.\n Such indices will exist if and only if the specified length\n is greater than that of the original array.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(short[], int)","flatSignature":"(short[], int)","returnType":{"isPrimitive":true,"simpleName":"short","qualifiedName":"short","dimension":"[]","elementType":{"isPrimitive":true,"simpleName":"short","qualifiedName":"short","dimension":"","elementType":{}}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"original","type":{"isPrimitive":true,"simpleName":"short","qualifiedName":"short","dimension":"[]","elementType":{"isPrimitive":true,"simpleName":"short","qualifiedName":"short","dimension":"","elementType":{}}}},{"name":"newLength","type":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"copyOf","comment":"Copies the specified array, truncating or padding with zeros (if necessary)\n so the copy has the specified length.  For all indices that are\n valid in both the original array and the copy, the two arrays will\n contain identical values.  For any indices that are valid in the\n copy but not the original, the copy will contain \u003ctt\u003e0\u003c/tt\u003e.\n Such indices will exist if and only if the specified length\n is greater than that of the original array.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(int[], int)","flatSignature":"(int[], int)","returnType":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"[]","elementType":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"original","type":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"[]","elementType":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}}}},{"name":"newLength","type":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"copyOf","comment":"Copies the specified array, truncating or padding with zeros (if necessary)\n so the copy has the specified length.  For all indices that are\n valid in both the original array and the copy, the two arrays will\n contain identical values.  For any indices that are valid in the\n copy but not the original, the copy will contain \u003ctt\u003e0L\u003c/tt\u003e.\n Such indices will exist if and only if the specified length\n is greater than that of the original array.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(long[], int)","flatSignature":"(long[], int)","returnType":{"isPrimitive":true,"simpleName":"long","qualifiedName":"long","dimension":"[]","elementType":{"isPrimitive":true,"simpleName":"long","qualifiedName":"long","dimension":"","elementType":{}}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"original","type":{"isPrimitive":true,"simpleName":"long","qualifiedName":"long","dimension":"[]","elementType":{"isPrimitive":true,"simpleName":"long","qualifiedName":"long","dimension":"","elementType":{}}}},{"name":"newLength","type":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"copyOf","comment":"Copies the specified array, truncating or padding with null characters (if necessary)\n so the copy has the specified length.  For all indices that are valid\n in both the original array and the copy, the two arrays will contain\n identical values.  For any indices that are valid in the copy but not\n the original, the copy will contain \u003ctt\u003e\u0027\\\\u000\u0027\u003c/tt\u003e.  Such indices\n will exist if and only if the specified length is greater than that of\n the original array.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(char[], int)","flatSignature":"(char[], int)","returnType":{"isPrimitive":true,"simpleName":"char","qualifiedName":"char","dimension":"[]","elementType":{"isPrimitive":true,"simpleName":"char","qualifiedName":"char","dimension":"","elementType":{}}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"original","type":{"isPrimitive":true,"simpleName":"char","qualifiedName":"char","dimension":"[]","elementType":{"isPrimitive":true,"simpleName":"char","qualifiedName":"char","dimension":"","elementType":{}}}},{"name":"newLength","type":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"copyOf","comment":"Copies the specified array, truncating or padding with zeros (if necessary)\n so the copy has the specified length.  For all indices that are\n valid in both the original array and the copy, the two arrays will\n contain identical values.  For any indices that are valid in the\n copy but not the original, the copy will contain \u003ctt\u003e0f\u003c/tt\u003e.\n Such indices will exist if and only if the specified length\n is greater than that of the original array.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(float[], int)","flatSignature":"(float[], int)","returnType":{"isPrimitive":true,"simpleName":"float","qualifiedName":"float","dimension":"[]","elementType":{"isPrimitive":true,"simpleName":"float","qualifiedName":"float","dimension":"","elementType":{}}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"original","type":{"isPrimitive":true,"simpleName":"float","qualifiedName":"float","dimension":"[]","elementType":{"isPrimitive":true,"simpleName":"float","qualifiedName":"float","dimension":"","elementType":{}}}},{"name":"newLength","type":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"copyOf","comment":"Copies the specified array, truncating or padding with zeros (if necessary)\n so the copy has the specified length.  For all indices that are\n valid in both the original array and the copy, the two arrays will\n contain identical values.  For any indices that are valid in the\n copy but not the original, the copy will contain \u003ctt\u003e0d\u003c/tt\u003e.\n Such indices will exist if and only if the specified length\n is greater than that of the original array.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(double[], int)","flatSignature":"(double[], int)","returnType":{"isPrimitive":true,"simpleName":"double","qualifiedName":"double","dimension":"[]","elementType":{"isPrimitive":true,"simpleName":"double","qualifiedName":"double","dimension":"","elementType":{}}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"original","type":{"isPrimitive":true,"simpleName":"double","qualifiedName":"double","dimension":"[]","elementType":{"isPrimitive":true,"simpleName":"double","qualifiedName":"double","dimension":"","elementType":{}}}},{"name":"newLength","type":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"copyOf","comment":"Copies the specified array, truncating or padding with \u003ctt\u003efalse\u003c/tt\u003e (if necessary)\n so the copy has the specified length.  For all indices that are\n valid in both the original array and the copy, the two arrays will\n contain identical values.  For any indices that are valid in the\n copy but not the original, the copy will contain \u003ctt\u003efalse\u003c/tt\u003e.\n Such indices will exist if and only if the specified length\n is greater than that of the original array.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(boolean[], int)","flatSignature":"(boolean[], int)","returnType":{"isPrimitive":true,"simpleName":"boolean","qualifiedName":"boolean","dimension":"[]","elementType":{"isPrimitive":true,"simpleName":"boolean","qualifiedName":"boolean","dimension":"","elementType":{}}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"original","type":{"isPrimitive":true,"simpleName":"boolean","qualifiedName":"boolean","dimension":"[]","elementType":{"isPrimitive":true,"simpleName":"boolean","qualifiedName":"boolean","dimension":"","elementType":{}}}},{"name":"newLength","type":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"copyOfRange","comment":"Copies the specified range of the specified array into a new array.\n The initial index of the range (\u003ctt\u003efrom\u003c/tt\u003e) must lie between zero\n and \u003ctt\u003eoriginal.length\u003c/tt\u003e, inclusive.  The value at\n \u003ctt\u003eoriginal[from]\u003c/tt\u003e is placed into the initial element of the copy\n (unless \u003ctt\u003efrom \u003d\u003d original.length\u003c/tt\u003e or \u003ctt\u003efrom \u003d\u003d to\u003c/tt\u003e).\n Values from subsequent elements in the original array are placed into\n subsequent elements in the copy.  The final index of the range\n (\u003ctt\u003eto\u003c/tt\u003e), which must be greater than or equal to \u003ctt\u003efrom\u003c/tt\u003e,\n may be greater than \u003ctt\u003eoriginal.length\u003c/tt\u003e, in which case\n \u003ctt\u003enull\u003c/tt\u003e is placed in all elements of the copy whose index is\n greater than or equal to \u003ctt\u003eoriginal.length - from\u003c/tt\u003e.  The length\n of the returned array will be \u003ctt\u003eto - from\u003c/tt\u003e.\n \u003cp\u003e\n The resulting array is of exactly the same class as the original array.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(T[], int, int)","flatSignature":"(T[], int, int)","returnType":{"isPrimitive":false,"simpleName":"T","qualifiedName":"T","dimension":"[]","elementType":{"isPrimitive":false,"simpleName":"T","qualifiedName":"T","dimension":"","elementType":{},"typeVariable":{"name":"T","bounds":[]}},"typeVariable":{"name":"T","bounds":[]}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"original","type":{"isPrimitive":false,"simpleName":"T","qualifiedName":"T","dimension":"[]","elementType":{"isPrimitive":false,"simpleName":"T","qualifiedName":"T","dimension":"","elementType":{},"typeVariable":{"name":"T","bounds":[]}},"typeVariable":{"name":"T","bounds":[]}}},{"name":"from","type":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}}},{"name":"to","type":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}}}],"typeParameters":[{"name":"T","bounds":[]}]},{"name":"copyOfRange","comment":"Copies the specified range of the specified array into a new array.\n The initial index of the range (\u003ctt\u003efrom\u003c/tt\u003e) must lie between zero\n and \u003ctt\u003eoriginal.length\u003c/tt\u003e, inclusive.  The value at\n \u003ctt\u003eoriginal[from]\u003c/tt\u003e is placed into the initial element of the copy\n (unless \u003ctt\u003efrom \u003d\u003d original.length\u003c/tt\u003e or \u003ctt\u003efrom \u003d\u003d to\u003c/tt\u003e).\n Values from subsequent elements in the original array are placed into\n subsequent elements in the copy.  The final index of the range\n (\u003ctt\u003eto\u003c/tt\u003e), which must be greater than or equal to \u003ctt\u003efrom\u003c/tt\u003e,\n may be greater than \u003ctt\u003eoriginal.length\u003c/tt\u003e, in which case\n \u003ctt\u003enull\u003c/tt\u003e is placed in all elements of the copy whose index is\n greater than or equal to \u003ctt\u003eoriginal.length - from\u003c/tt\u003e.  The length\n of the returned array will be \u003ctt\u003eto - from\u003c/tt\u003e.\n The resulting array is of the class \u003ctt\u003enewType\u003c/tt\u003e.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(U[], int, int, java.lang.Class\u003c? extends T[]\u003e)","flatSignature":"(U[], int, int, Class\u003c? extends T[]\u003e)","returnType":{"isPrimitive":false,"simpleName":"T","qualifiedName":"T","dimension":"[]","elementType":{"isPrimitive":false,"simpleName":"T","qualifiedName":"T","dimension":"","elementType":{},"typeVariable":{"name":"T","bounds":[]}},"typeVariable":{"name":"T","bounds":[]}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"original","type":{"isPrimitive":false,"simpleName":"U","qualifiedName":"U","dimension":"[]","elementType":{"isPrimitive":false,"simpleName":"U","qualifiedName":"U","dimension":"","elementType":{},"typeVariable":{"name":"U","bounds":[]}},"typeVariable":{"name":"U","bounds":[]}}},{"name":"from","type":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}}},{"name":"to","type":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}}},{"name":"newType","type":{"isPrimitive":false,"simpleName":"Class","qualifiedName":"java.lang.Class","dimension":"","elementType":{}}}],"typeParameters":[{"name":"T","bounds":[]},{"name":"U","bounds":[]}]},{"name":"copyOfRange","comment":"Copies the specified range of the specified array into a new array.\n The initial index of the range (\u003ctt\u003efrom\u003c/tt\u003e) must lie between zero\n and \u003ctt\u003eoriginal.length\u003c/tt\u003e, inclusive.  The value at\n \u003ctt\u003eoriginal[from]\u003c/tt\u003e is placed into the initial element of the copy\n (unless \u003ctt\u003efrom \u003d\u003d original.length\u003c/tt\u003e or \u003ctt\u003efrom \u003d\u003d to\u003c/tt\u003e).\n Values from subsequent elements in the original array are placed into\n subsequent elements in the copy.  The final index of the range\n (\u003ctt\u003eto\u003c/tt\u003e), which must be greater than or equal to \u003ctt\u003efrom\u003c/tt\u003e,\n may be greater than \u003ctt\u003eoriginal.length\u003c/tt\u003e, in which case\n \u003ctt\u003e(byte)0\u003c/tt\u003e is placed in all elements of the copy whose index is\n greater than or equal to \u003ctt\u003eoriginal.length - from\u003c/tt\u003e.  The length\n of the returned array will be \u003ctt\u003eto - from\u003c/tt\u003e.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(byte[], int, int)","flatSignature":"(byte[], int, int)","returnType":{"isPrimitive":true,"simpleName":"byte","qualifiedName":"byte","dimension":"[]","elementType":{"isPrimitive":true,"simpleName":"byte","qualifiedName":"byte","dimension":"","elementType":{}}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"original","type":{"isPrimitive":true,"simpleName":"byte","qualifiedName":"byte","dimension":"[]","elementType":{"isPrimitive":true,"simpleName":"byte","qualifiedName":"byte","dimension":"","elementType":{}}}},{"name":"from","type":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}}},{"name":"to","type":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"copyOfRange","comment":"Copies the specified range of the specified array into a new array.\n The initial index of the range (\u003ctt\u003efrom\u003c/tt\u003e) must lie between zero\n and \u003ctt\u003eoriginal.length\u003c/tt\u003e, inclusive.  The value at\n \u003ctt\u003eoriginal[from]\u003c/tt\u003e is placed into the initial element of the copy\n (unless \u003ctt\u003efrom \u003d\u003d original.length\u003c/tt\u003e or \u003ctt\u003efrom \u003d\u003d to\u003c/tt\u003e).\n Values from subsequent elements in the original array are placed into\n subsequent elements in the copy.  The final index of the range\n (\u003ctt\u003eto\u003c/tt\u003e), which must be greater than or equal to \u003ctt\u003efrom\u003c/tt\u003e,\n may be greater than \u003ctt\u003eoriginal.length\u003c/tt\u003e, in which case\n \u003ctt\u003e(short)0\u003c/tt\u003e is placed in all elements of the copy whose index is\n greater than or equal to \u003ctt\u003eoriginal.length - from\u003c/tt\u003e.  The length\n of the returned array will be \u003ctt\u003eto - from\u003c/tt\u003e.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(short[], int, int)","flatSignature":"(short[], int, int)","returnType":{"isPrimitive":true,"simpleName":"short","qualifiedName":"short","dimension":"[]","elementType":{"isPrimitive":true,"simpleName":"short","qualifiedName":"short","dimension":"","elementType":{}}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"original","type":{"isPrimitive":true,"simpleName":"short","qualifiedName":"short","dimension":"[]","elementType":{"isPrimitive":true,"simpleName":"short","qualifiedName":"short","dimension":"","elementType":{}}}},{"name":"from","type":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}}},{"name":"to","type":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"copyOfRange","comment":"Copies the specified range of the specified array into a new array.\n The initial index of the range (\u003ctt\u003efrom\u003c/tt\u003e) must lie between zero\n and \u003ctt\u003eoriginal.length\u003c/tt\u003e, inclusive.  The value at\n \u003ctt\u003eoriginal[from]\u003c/tt\u003e is placed into the initial element of the copy\n (unless \u003ctt\u003efrom \u003d\u003d original.length\u003c/tt\u003e or \u003ctt\u003efrom \u003d\u003d to\u003c/tt\u003e).\n Values from subsequent elements in the original array are placed into\n subsequent elements in the copy.  The final index of the range\n (\u003ctt\u003eto\u003c/tt\u003e), which must be greater than or equal to \u003ctt\u003efrom\u003c/tt\u003e,\n may be greater than \u003ctt\u003eoriginal.length\u003c/tt\u003e, in which case\n \u003ctt\u003e0\u003c/tt\u003e is placed in all elements of the copy whose index is\n greater than or equal to \u003ctt\u003eoriginal.length - from\u003c/tt\u003e.  The length\n of the returned array will be \u003ctt\u003eto - from\u003c/tt\u003e.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(int[], int, int)","flatSignature":"(int[], int, int)","returnType":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"[]","elementType":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"original","type":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"[]","elementType":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}}}},{"name":"from","type":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}}},{"name":"to","type":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"copyOfRange","comment":"Copies the specified range of the specified array into a new array.\n The initial index of the range (\u003ctt\u003efrom\u003c/tt\u003e) must lie between zero\n and \u003ctt\u003eoriginal.length\u003c/tt\u003e, inclusive.  The value at\n \u003ctt\u003eoriginal[from]\u003c/tt\u003e is placed into the initial element of the copy\n (unless \u003ctt\u003efrom \u003d\u003d original.length\u003c/tt\u003e or \u003ctt\u003efrom \u003d\u003d to\u003c/tt\u003e).\n Values from subsequent elements in the original array are placed into\n subsequent elements in the copy.  The final index of the range\n (\u003ctt\u003eto\u003c/tt\u003e), which must be greater than or equal to \u003ctt\u003efrom\u003c/tt\u003e,\n may be greater than \u003ctt\u003eoriginal.length\u003c/tt\u003e, in which case\n \u003ctt\u003e0L\u003c/tt\u003e is placed in all elements of the copy whose index is\n greater than or equal to \u003ctt\u003eoriginal.length - from\u003c/tt\u003e.  The length\n of the returned array will be \u003ctt\u003eto - from\u003c/tt\u003e.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(long[], int, int)","flatSignature":"(long[], int, int)","returnType":{"isPrimitive":true,"simpleName":"long","qualifiedName":"long","dimension":"[]","elementType":{"isPrimitive":true,"simpleName":"long","qualifiedName":"long","dimension":"","elementType":{}}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"original","type":{"isPrimitive":true,"simpleName":"long","qualifiedName":"long","dimension":"[]","elementType":{"isPrimitive":true,"simpleName":"long","qualifiedName":"long","dimension":"","elementType":{}}}},{"name":"from","type":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}}},{"name":"to","type":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"copyOfRange","comment":"Copies the specified range of the specified array into a new array.\n The initial index of the range (\u003ctt\u003efrom\u003c/tt\u003e) must lie between zero\n and \u003ctt\u003eoriginal.length\u003c/tt\u003e, inclusive.  The value at\n \u003ctt\u003eoriginal[from]\u003c/tt\u003e is placed into the initial element of the copy\n (unless \u003ctt\u003efrom \u003d\u003d original.length\u003c/tt\u003e or \u003ctt\u003efrom \u003d\u003d to\u003c/tt\u003e).\n Values from subsequent elements in the original array are placed into\n subsequent elements in the copy.  The final index of the range\n (\u003ctt\u003eto\u003c/tt\u003e), which must be greater than or equal to \u003ctt\u003efrom\u003c/tt\u003e,\n may be greater than \u003ctt\u003eoriginal.length\u003c/tt\u003e, in which case\n \u003ctt\u003e\u0027\\\\u000\u0027\u003c/tt\u003e is placed in all elements of the copy whose index is\n greater than or equal to \u003ctt\u003eoriginal.length - from\u003c/tt\u003e.  The length\n of the returned array will be \u003ctt\u003eto - from\u003c/tt\u003e.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(char[], int, int)","flatSignature":"(char[], int, int)","returnType":{"isPrimitive":true,"simpleName":"char","qualifiedName":"char","dimension":"[]","elementType":{"isPrimitive":true,"simpleName":"char","qualifiedName":"char","dimension":"","elementType":{}}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"original","type":{"isPrimitive":true,"simpleName":"char","qualifiedName":"char","dimension":"[]","elementType":{"isPrimitive":true,"simpleName":"char","qualifiedName":"char","dimension":"","elementType":{}}}},{"name":"from","type":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}}},{"name":"to","type":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"copyOfRange","comment":"Copies the specified range of the specified array into a new array.\n The initial index of the range (\u003ctt\u003efrom\u003c/tt\u003e) must lie between zero\n and \u003ctt\u003eoriginal.length\u003c/tt\u003e, inclusive.  The value at\n \u003ctt\u003eoriginal[from]\u003c/tt\u003e is placed into the initial element of the copy\n (unless \u003ctt\u003efrom \u003d\u003d original.length\u003c/tt\u003e or \u003ctt\u003efrom \u003d\u003d to\u003c/tt\u003e).\n Values from subsequent elements in the original array are placed into\n subsequent elements in the copy.  The final index of the range\n (\u003ctt\u003eto\u003c/tt\u003e), which must be greater than or equal to \u003ctt\u003efrom\u003c/tt\u003e,\n may be greater than \u003ctt\u003eoriginal.length\u003c/tt\u003e, in which case\n \u003ctt\u003e0f\u003c/tt\u003e is placed in all elements of the copy whose index is\n greater than or equal to \u003ctt\u003eoriginal.length - from\u003c/tt\u003e.  The length\n of the returned array will be \u003ctt\u003eto - from\u003c/tt\u003e.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(float[], int, int)","flatSignature":"(float[], int, int)","returnType":{"isPrimitive":true,"simpleName":"float","qualifiedName":"float","dimension":"[]","elementType":{"isPrimitive":true,"simpleName":"float","qualifiedName":"float","dimension":"","elementType":{}}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"original","type":{"isPrimitive":true,"simpleName":"float","qualifiedName":"float","dimension":"[]","elementType":{"isPrimitive":true,"simpleName":"float","qualifiedName":"float","dimension":"","elementType":{}}}},{"name":"from","type":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}}},{"name":"to","type":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"copyOfRange","comment":"Copies the specified range of the specified array into a new array.\n The initial index of the range (\u003ctt\u003efrom\u003c/tt\u003e) must lie between zero\n and \u003ctt\u003eoriginal.length\u003c/tt\u003e, inclusive.  The value at\n \u003ctt\u003eoriginal[from]\u003c/tt\u003e is placed into the initial element of the copy\n (unless \u003ctt\u003efrom \u003d\u003d original.length\u003c/tt\u003e or \u003ctt\u003efrom \u003d\u003d to\u003c/tt\u003e).\n Values from subsequent elements in the original array are placed into\n subsequent elements in the copy.  The final index of the range\n (\u003ctt\u003eto\u003c/tt\u003e), which must be greater than or equal to \u003ctt\u003efrom\u003c/tt\u003e,\n may be greater than \u003ctt\u003eoriginal.length\u003c/tt\u003e, in which case\n \u003ctt\u003e0d\u003c/tt\u003e is placed in all elements of the copy whose index is\n greater than or equal to \u003ctt\u003eoriginal.length - from\u003c/tt\u003e.  The length\n of the returned array will be \u003ctt\u003eto - from\u003c/tt\u003e.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(double[], int, int)","flatSignature":"(double[], int, int)","returnType":{"isPrimitive":true,"simpleName":"double","qualifiedName":"double","dimension":"[]","elementType":{"isPrimitive":true,"simpleName":"double","qualifiedName":"double","dimension":"","elementType":{}}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"original","type":{"isPrimitive":true,"simpleName":"double","qualifiedName":"double","dimension":"[]","elementType":{"isPrimitive":true,"simpleName":"double","qualifiedName":"double","dimension":"","elementType":{}}}},{"name":"from","type":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}}},{"name":"to","type":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"copyOfRange","comment":"Copies the specified range of the specified array into a new array.\n The initial index of the range (\u003ctt\u003efrom\u003c/tt\u003e) must lie between zero\n and \u003ctt\u003eoriginal.length\u003c/tt\u003e, inclusive.  The value at\n \u003ctt\u003eoriginal[from]\u003c/tt\u003e is placed into the initial element of the copy\n (unless \u003ctt\u003efrom \u003d\u003d original.length\u003c/tt\u003e or \u003ctt\u003efrom \u003d\u003d to\u003c/tt\u003e).\n Values from subsequent elements in the original array are placed into\n subsequent elements in the copy.  The final index of the range\n (\u003ctt\u003eto\u003c/tt\u003e), which must be greater than or equal to \u003ctt\u003efrom\u003c/tt\u003e,\n may be greater than \u003ctt\u003eoriginal.length\u003c/tt\u003e, in which case\n \u003ctt\u003efalse\u003c/tt\u003e is placed in all elements of the copy whose index is\n greater than or equal to \u003ctt\u003eoriginal.length - from\u003c/tt\u003e.  The length\n of the returned array will be \u003ctt\u003eto - from\u003c/tt\u003e.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(boolean[], int, int)","flatSignature":"(boolean[], int, int)","returnType":{"isPrimitive":true,"simpleName":"boolean","qualifiedName":"boolean","dimension":"[]","elementType":{"isPrimitive":true,"simpleName":"boolean","qualifiedName":"boolean","dimension":"","elementType":{}}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"original","type":{"isPrimitive":true,"simpleName":"boolean","qualifiedName":"boolean","dimension":"[]","elementType":{"isPrimitive":true,"simpleName":"boolean","qualifiedName":"boolean","dimension":"","elementType":{}}}},{"name":"from","type":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}}},{"name":"to","type":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"asList","comment":"Returns a fixed-size list backed by the specified array.  (Changes to\n the returned list \"write through\" to the array.)  This method acts\n as bridge between array-based and collection-based APIs, in\n combination with {@link Collection#toArray}.  The returned list is\n serializable and implements {@link RandomAccess}.\n\n \u003cp\u003eThis method also provides a convenient way to create a fixed-size\n list initialized to contain several elements:\n \u003cpre\u003e\n     List\u0026lt;String\u0026gt; stooges \u003d Arrays.asList(\"Larry\", \"Moe\", \"Curly\");\n \u003c/pre\u003e","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(T...)","flatSignature":"(T...)","returnType":{"isPrimitive":false,"simpleName":"List","qualifiedName":"java.util.List","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"a","type":{"isPrimitive":false,"simpleName":"T","qualifiedName":"T","dimension":"[]","elementType":{"isPrimitive":false,"simpleName":"T","qualifiedName":"T","dimension":"","elementType":{},"typeVariable":{"name":"T","bounds":[]}},"typeVariable":{"name":"T","bounds":[]}}}],"typeParameters":[{"name":"T","bounds":[]}]},{"name":"hashCode","comment":"Returns a hash code based on the contents of the specified array.\n For any two \u003ctt\u003elong\u003c/tt\u003e arrays \u003ctt\u003ea\u003c/tt\u003e and \u003ctt\u003eb\u003c/tt\u003e\n such that \u003ctt\u003eArrays.equals(a, b)\u003c/tt\u003e, it is also the case that\n \u003ctt\u003eArrays.hashCode(a) \u003d\u003d Arrays.hashCode(b)\u003c/tt\u003e.\n\n \u003cp\u003eThe value returned by this method is the same value that would be\n obtained by invoking the {@link List#hashCode() \u003ctt\u003ehashCode\u003c/tt\u003e}\n method on a {@link List} containing a sequence of {@link Long}\n instances representing the elements of \u003ctt\u003ea\u003c/tt\u003e in the same order.\n If \u003ctt\u003ea\u003c/tt\u003e is \u003ctt\u003enull\u003c/tt\u003e, this method returns 0.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(long[])","flatSignature":"(long[])","returnType":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"a","type":{"isPrimitive":true,"simpleName":"long","qualifiedName":"long","dimension":"[]","elementType":{"isPrimitive":true,"simpleName":"long","qualifiedName":"long","dimension":"","elementType":{}}}}],"typeParameters":[]},{"name":"hashCode","comment":"Returns a hash code based on the contents of the specified array.\n For any two non-null \u003ctt\u003eint\u003c/tt\u003e arrays \u003ctt\u003ea\u003c/tt\u003e and \u003ctt\u003eb\u003c/tt\u003e\n such that \u003ctt\u003eArrays.equals(a, b)\u003c/tt\u003e, it is also the case that\n \u003ctt\u003eArrays.hashCode(a) \u003d\u003d Arrays.hashCode(b)\u003c/tt\u003e.\n\n \u003cp\u003eThe value returned by this method is the same value that would be\n obtained by invoking the {@link List#hashCode() \u003ctt\u003ehashCode\u003c/tt\u003e}\n method on a {@link List} containing a sequence of {@link Integer}\n instances representing the elements of \u003ctt\u003ea\u003c/tt\u003e in the same order.\n If \u003ctt\u003ea\u003c/tt\u003e is \u003ctt\u003enull\u003c/tt\u003e, this method returns 0.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(int[])","flatSignature":"(int[])","returnType":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"a","type":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"[]","elementType":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}}}}],"typeParameters":[]},{"name":"hashCode","comment":"Returns a hash code based on the contents of the specified array.\n For any two \u003ctt\u003eshort\u003c/tt\u003e arrays \u003ctt\u003ea\u003c/tt\u003e and \u003ctt\u003eb\u003c/tt\u003e\n such that \u003ctt\u003eArrays.equals(a, b)\u003c/tt\u003e, it is also the case that\n \u003ctt\u003eArrays.hashCode(a) \u003d\u003d Arrays.hashCode(b)\u003c/tt\u003e.\n\n \u003cp\u003eThe value returned by this method is the same value that would be\n obtained by invoking the {@link List#hashCode() \u003ctt\u003ehashCode\u003c/tt\u003e}\n method on a {@link List} containing a sequence of {@link Short}\n instances representing the elements of \u003ctt\u003ea\u003c/tt\u003e in the same order.\n If \u003ctt\u003ea\u003c/tt\u003e is \u003ctt\u003enull\u003c/tt\u003e, this method returns 0.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(short[])","flatSignature":"(short[])","returnType":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"a","type":{"isPrimitive":true,"simpleName":"short","qualifiedName":"short","dimension":"[]","elementType":{"isPrimitive":true,"simpleName":"short","qualifiedName":"short","dimension":"","elementType":{}}}}],"typeParameters":[]},{"name":"hashCode","comment":"Returns a hash code based on the contents of the specified array.\n For any two \u003ctt\u003echar\u003c/tt\u003e arrays \u003ctt\u003ea\u003c/tt\u003e and \u003ctt\u003eb\u003c/tt\u003e\n such that \u003ctt\u003eArrays.equals(a, b)\u003c/tt\u003e, it is also the case that\n \u003ctt\u003eArrays.hashCode(a) \u003d\u003d Arrays.hashCode(b)\u003c/tt\u003e.\n\n \u003cp\u003eThe value returned by this method is the same value that would be\n obtained by invoking the {@link List#hashCode() \u003ctt\u003ehashCode\u003c/tt\u003e}\n method on a {@link List} containing a sequence of {@link Character}\n instances representing the elements of \u003ctt\u003ea\u003c/tt\u003e in the same order.\n If \u003ctt\u003ea\u003c/tt\u003e is \u003ctt\u003enull\u003c/tt\u003e, this method returns 0.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(char[])","flatSignature":"(char[])","returnType":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"a","type":{"isPrimitive":true,"simpleName":"char","qualifiedName":"char","dimension":"[]","elementType":{"isPrimitive":true,"simpleName":"char","qualifiedName":"char","dimension":"","elementType":{}}}}],"typeParameters":[]},{"name":"hashCode","comment":"Returns a hash code based on the contents of the specified array.\n For any two \u003ctt\u003ebyte\u003c/tt\u003e arrays \u003ctt\u003ea\u003c/tt\u003e and \u003ctt\u003eb\u003c/tt\u003e\n such that \u003ctt\u003eArrays.equals(a, b)\u003c/tt\u003e, it is also the case that\n \u003ctt\u003eArrays.hashCode(a) \u003d\u003d Arrays.hashCode(b)\u003c/tt\u003e.\n\n \u003cp\u003eThe value returned by this method is the same value that would be\n obtained by invoking the {@link List#hashCode() \u003ctt\u003ehashCode\u003c/tt\u003e}\n method on a {@link List} containing a sequence of {@link Byte}\n instances representing the elements of \u003ctt\u003ea\u003c/tt\u003e in the same order.\n If \u003ctt\u003ea\u003c/tt\u003e is \u003ctt\u003enull\u003c/tt\u003e, this method returns 0.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(byte[])","flatSignature":"(byte[])","returnType":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"a","type":{"isPrimitive":true,"simpleName":"byte","qualifiedName":"byte","dimension":"[]","elementType":{"isPrimitive":true,"simpleName":"byte","qualifiedName":"byte","dimension":"","elementType":{}}}}],"typeParameters":[]},{"name":"hashCode","comment":"Returns a hash code based on the contents of the specified array.\n For any two \u003ctt\u003eboolean\u003c/tt\u003e arrays \u003ctt\u003ea\u003c/tt\u003e and \u003ctt\u003eb\u003c/tt\u003e\n such that \u003ctt\u003eArrays.equals(a, b)\u003c/tt\u003e, it is also the case that\n \u003ctt\u003eArrays.hashCode(a) \u003d\u003d Arrays.hashCode(b)\u003c/tt\u003e.\n\n \u003cp\u003eThe value returned by this method is the same value that would be\n obtained by invoking the {@link List#hashCode() \u003ctt\u003ehashCode\u003c/tt\u003e}\n method on a {@link List} containing a sequence of {@link Boolean}\n instances representing the elements of \u003ctt\u003ea\u003c/tt\u003e in the same order.\n If \u003ctt\u003ea\u003c/tt\u003e is \u003ctt\u003enull\u003c/tt\u003e, this method returns 0.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(boolean[])","flatSignature":"(boolean[])","returnType":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"a","type":{"isPrimitive":true,"simpleName":"boolean","qualifiedName":"boolean","dimension":"[]","elementType":{"isPrimitive":true,"simpleName":"boolean","qualifiedName":"boolean","dimension":"","elementType":{}}}}],"typeParameters":[]},{"name":"hashCode","comment":"Returns a hash code based on the contents of the specified array.\n For any two \u003ctt\u003efloat\u003c/tt\u003e arrays \u003ctt\u003ea\u003c/tt\u003e and \u003ctt\u003eb\u003c/tt\u003e\n such that \u003ctt\u003eArrays.equals(a, b)\u003c/tt\u003e, it is also the case that\n \u003ctt\u003eArrays.hashCode(a) \u003d\u003d Arrays.hashCode(b)\u003c/tt\u003e.\n\n \u003cp\u003eThe value returned by this method is the same value that would be\n obtained by invoking the {@link List#hashCode() \u003ctt\u003ehashCode\u003c/tt\u003e}\n method on a {@link List} containing a sequence of {@link Float}\n instances representing the elements of \u003ctt\u003ea\u003c/tt\u003e in the same order.\n If \u003ctt\u003ea\u003c/tt\u003e is \u003ctt\u003enull\u003c/tt\u003e, this method returns 0.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(float[])","flatSignature":"(float[])","returnType":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"a","type":{"isPrimitive":true,"simpleName":"float","qualifiedName":"float","dimension":"[]","elementType":{"isPrimitive":true,"simpleName":"float","qualifiedName":"float","dimension":"","elementType":{}}}}],"typeParameters":[]},{"name":"hashCode","comment":"Returns a hash code based on the contents of the specified array.\n For any two \u003ctt\u003edouble\u003c/tt\u003e arrays \u003ctt\u003ea\u003c/tt\u003e and \u003ctt\u003eb\u003c/tt\u003e\n such that \u003ctt\u003eArrays.equals(a, b)\u003c/tt\u003e, it is also the case that\n \u003ctt\u003eArrays.hashCode(a) \u003d\u003d Arrays.hashCode(b)\u003c/tt\u003e.\n\n \u003cp\u003eThe value returned by this method is the same value that would be\n obtained by invoking the {@link List#hashCode() \u003ctt\u003ehashCode\u003c/tt\u003e}\n method on a {@link List} containing a sequence of {@link Double}\n instances representing the elements of \u003ctt\u003ea\u003c/tt\u003e in the same order.\n If \u003ctt\u003ea\u003c/tt\u003e is \u003ctt\u003enull\u003c/tt\u003e, this method returns 0.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(double[])","flatSignature":"(double[])","returnType":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"a","type":{"isPrimitive":true,"simpleName":"double","qualifiedName":"double","dimension":"[]","elementType":{"isPrimitive":true,"simpleName":"double","qualifiedName":"double","dimension":"","elementType":{}}}}],"typeParameters":[]},{"name":"hashCode","comment":"Returns a hash code based on the contents of the specified array.  If\n the array contains other arrays as elements, the hash code is based on\n their identities rather than their contents.  It is therefore\n acceptable to invoke this method on an array that contains itself as an\n element,  either directly or indirectly through one or more levels of\n arrays.\n\n \u003cp\u003eFor any two arrays \u003ctt\u003ea\u003c/tt\u003e and \u003ctt\u003eb\u003c/tt\u003e such that\n \u003ctt\u003eArrays.equals(a, b)\u003c/tt\u003e, it is also the case that\n \u003ctt\u003eArrays.hashCode(a) \u003d\u003d Arrays.hashCode(b)\u003c/tt\u003e.\n\n \u003cp\u003eThe value returned by this method is equal to the value that would\n be returned by \u003ctt\u003eArrays.asList(a).hashCode()\u003c/tt\u003e, unless \u003ctt\u003ea\u003c/tt\u003e\n is \u003ctt\u003enull\u003c/tt\u003e, in which case \u003ctt\u003e0\u003c/tt\u003e is returned.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.lang.Object[])","flatSignature":"(Object[])","returnType":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"a","type":{"isPrimitive":false,"simpleName":"Object","qualifiedName":"java.lang.Object","dimension":"[]","elementType":{"isPrimitive":false,"simpleName":"Object","qualifiedName":"java.lang.Object","dimension":"","elementType":{}}}}],"typeParameters":[]},{"name":"deepHashCode","comment":"Returns a hash code based on the \"deep contents\" of the specified\n array.  If the array contains other arrays as elements, the\n hash code is based on their contents and so on, ad infinitum.\n It is therefore unacceptable to invoke this method on an array that\n contains itself as an element, either directly or indirectly through\n one or more levels of arrays.  The behavior of such an invocation is\n undefined.\n\n \u003cp\u003eFor any two arrays \u003ctt\u003ea\u003c/tt\u003e and \u003ctt\u003eb\u003c/tt\u003e such that\n \u003ctt\u003eArrays.deepEquals(a, b)\u003c/tt\u003e, it is also the case that\n \u003ctt\u003eArrays.deepHashCode(a) \u003d\u003d Arrays.deepHashCode(b)\u003c/tt\u003e.\n\n \u003cp\u003eThe computation of the value returned by this method is similar to\n that of the value returned by {@link List#hashCode()} on a list\n containing the same elements as \u003ctt\u003ea\u003c/tt\u003e in the same order, with one\n difference: If an element \u003ctt\u003ee\u003c/tt\u003e of \u003ctt\u003ea\u003c/tt\u003e is itself an array,\n its hash code is computed not by calling \u003ctt\u003ee.hashCode()\u003c/tt\u003e, but as\n by calling the appropriate overloading of \u003ctt\u003eArrays.hashCode(e)\u003c/tt\u003e\n if \u003ctt\u003ee\u003c/tt\u003e is an array of a primitive type, or as by calling\n \u003ctt\u003eArrays.deepHashCode(e)\u003c/tt\u003e recursively if \u003ctt\u003ee\u003c/tt\u003e is an array\n of a reference type.  If \u003ctt\u003ea\u003c/tt\u003e is \u003ctt\u003enull\u003c/tt\u003e, this method\n returns 0.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.lang.Object[])","flatSignature":"(Object[])","returnType":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"a","type":{"isPrimitive":false,"simpleName":"Object","qualifiedName":"java.lang.Object","dimension":"[]","elementType":{"isPrimitive":false,"simpleName":"Object","qualifiedName":"java.lang.Object","dimension":"","elementType":{}}}}],"typeParameters":[]},{"name":"deepEquals","comment":"Returns \u003ctt\u003etrue\u003c/tt\u003e if the two specified arrays are \u003ci\u003edeeply\n equal\u003c/i\u003e to one another.  Unlike the {@link #equals(Object[],Object[])}\n method, this method is appropriate for use with nested arrays of\n arbitrary depth.\n\n \u003cp\u003eTwo array references are considered deeply equal if both\n are \u003ctt\u003enull\u003c/tt\u003e, or if they refer to arrays that contain the same\n number of elements and all corresponding pairs of elements in the two\n arrays are deeply equal.\n\n \u003cp\u003eTwo possibly \u003ctt\u003enull\u003c/tt\u003e elements \u003ctt\u003ee1\u003c/tt\u003e and \u003ctt\u003ee2\u003c/tt\u003e are\n deeply equal if any of the following conditions hold:\n \u003cul\u003e\n    \u003cli\u003e \u003ctt\u003ee1\u003c/tt\u003e and \u003ctt\u003ee2\u003c/tt\u003e are both arrays of object reference\n         types, and \u003ctt\u003eArrays.deepEquals(e1, e2) would return true\u003c/tt\u003e\n    \u003cli\u003e \u003ctt\u003ee1\u003c/tt\u003e and \u003ctt\u003ee2\u003c/tt\u003e are arrays of the same primitive\n         type, and the appropriate overloading of\n         \u003ctt\u003eArrays.equals(e1, e2)\u003c/tt\u003e would return true.\n    \u003cli\u003e \u003ctt\u003ee1 \u003d\u003d e2\u003c/tt\u003e\n    \u003cli\u003e \u003ctt\u003ee1.equals(e2)\u003c/tt\u003e would return true.\n \u003c/ul\u003e\n Note that this definition permits \u003ctt\u003enull\u003c/tt\u003e elements at any depth.\n\n \u003cp\u003eIf either of the specified arrays contain themselves as elements\n either directly or indirectly through one or more levels of arrays,\n the behavior of this method is undefined.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.lang.Object[], java.lang.Object[])","flatSignature":"(Object[], Object[])","returnType":{"isPrimitive":true,"simpleName":"boolean","qualifiedName":"boolean","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"a1","type":{"isPrimitive":false,"simpleName":"Object","qualifiedName":"java.lang.Object","dimension":"[]","elementType":{"isPrimitive":false,"simpleName":"Object","qualifiedName":"java.lang.Object","dimension":"","elementType":{}}}},{"name":"a2","type":{"isPrimitive":false,"simpleName":"Object","qualifiedName":"java.lang.Object","dimension":"[]","elementType":{"isPrimitive":false,"simpleName":"Object","qualifiedName":"java.lang.Object","dimension":"","elementType":{}}}}],"typeParameters":[]},{"name":"toString","comment":"Returns a string representation of the contents of the specified array.\n The string representation consists of a list of the array\u0027s elements,\n enclosed in square brackets (\u003ctt\u003e\"[]\"\u003c/tt\u003e).  Adjacent elements are\n separated by the characters \u003ctt\u003e\", \"\u003c/tt\u003e (a comma followed by a\n space).  Elements are converted to strings as by\n \u003ctt\u003eString.valueOf(long)\u003c/tt\u003e.  Returns \u003ctt\u003e\"null\"\u003c/tt\u003e if \u003ctt\u003ea\u003c/tt\u003e\n is \u003ctt\u003enull\u003c/tt\u003e.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(long[])","flatSignature":"(long[])","returnType":{"isPrimitive":false,"simpleName":"String","qualifiedName":"java.lang.String","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"a","type":{"isPrimitive":true,"simpleName":"long","qualifiedName":"long","dimension":"[]","elementType":{"isPrimitive":true,"simpleName":"long","qualifiedName":"long","dimension":"","elementType":{}}}}],"typeParameters":[]},{"name":"toString","comment":"Returns a string representation of the contents of the specified array.\n The string representation consists of a list of the array\u0027s elements,\n enclosed in square brackets (\u003ctt\u003e\"[]\"\u003c/tt\u003e).  Adjacent elements are\n separated by the characters \u003ctt\u003e\", \"\u003c/tt\u003e (a comma followed by a\n space).  Elements are converted to strings as by\n \u003ctt\u003eString.valueOf(int)\u003c/tt\u003e.  Returns \u003ctt\u003e\"null\"\u003c/tt\u003e if \u003ctt\u003ea\u003c/tt\u003e is\n \u003ctt\u003enull\u003c/tt\u003e.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(int[])","flatSignature":"(int[])","returnType":{"isPrimitive":false,"simpleName":"String","qualifiedName":"java.lang.String","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"a","type":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"[]","elementType":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}}}}],"typeParameters":[]},{"name":"toString","comment":"Returns a string representation of the contents of the specified array.\n The string representation consists of a list of the array\u0027s elements,\n enclosed in square brackets (\u003ctt\u003e\"[]\"\u003c/tt\u003e).  Adjacent elements are\n separated by the characters \u003ctt\u003e\", \"\u003c/tt\u003e (a comma followed by a\n space).  Elements are converted to strings as by\n \u003ctt\u003eString.valueOf(short)\u003c/tt\u003e.  Returns \u003ctt\u003e\"null\"\u003c/tt\u003e if \u003ctt\u003ea\u003c/tt\u003e\n is \u003ctt\u003enull\u003c/tt\u003e.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(short[])","flatSignature":"(short[])","returnType":{"isPrimitive":false,"simpleName":"String","qualifiedName":"java.lang.String","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"a","type":{"isPrimitive":true,"simpleName":"short","qualifiedName":"short","dimension":"[]","elementType":{"isPrimitive":true,"simpleName":"short","qualifiedName":"short","dimension":"","elementType":{}}}}],"typeParameters":[]},{"name":"toString","comment":"Returns a string representation of the contents of the specified array.\n The string representation consists of a list of the array\u0027s elements,\n enclosed in square brackets (\u003ctt\u003e\"[]\"\u003c/tt\u003e).  Adjacent elements are\n separated by the characters \u003ctt\u003e\", \"\u003c/tt\u003e (a comma followed by a\n space).  Elements are converted to strings as by\n \u003ctt\u003eString.valueOf(char)\u003c/tt\u003e.  Returns \u003ctt\u003e\"null\"\u003c/tt\u003e if \u003ctt\u003ea\u003c/tt\u003e\n is \u003ctt\u003enull\u003c/tt\u003e.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(char[])","flatSignature":"(char[])","returnType":{"isPrimitive":false,"simpleName":"String","qualifiedName":"java.lang.String","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"a","type":{"isPrimitive":true,"simpleName":"char","qualifiedName":"char","dimension":"[]","elementType":{"isPrimitive":true,"simpleName":"char","qualifiedName":"char","dimension":"","elementType":{}}}}],"typeParameters":[]},{"name":"toString","comment":"Returns a string representation of the contents of the specified array.\n The string representation consists of a list of the array\u0027s elements,\n enclosed in square brackets (\u003ctt\u003e\"[]\"\u003c/tt\u003e).  Adjacent elements\n are separated by the characters \u003ctt\u003e\", \"\u003c/tt\u003e (a comma followed\n by a space).  Elements are converted to strings as by\n \u003ctt\u003eString.valueOf(byte)\u003c/tt\u003e.  Returns \u003ctt\u003e\"null\"\u003c/tt\u003e if\n \u003ctt\u003ea\u003c/tt\u003e is \u003ctt\u003enull\u003c/tt\u003e.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(byte[])","flatSignature":"(byte[])","returnType":{"isPrimitive":false,"simpleName":"String","qualifiedName":"java.lang.String","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"a","type":{"isPrimitive":true,"simpleName":"byte","qualifiedName":"byte","dimension":"[]","elementType":{"isPrimitive":true,"simpleName":"byte","qualifiedName":"byte","dimension":"","elementType":{}}}}],"typeParameters":[]},{"name":"toString","comment":"Returns a string representation of the contents of the specified array.\n The string representation consists of a list of the array\u0027s elements,\n enclosed in square brackets (\u003ctt\u003e\"[]\"\u003c/tt\u003e).  Adjacent elements are\n separated by the characters \u003ctt\u003e\", \"\u003c/tt\u003e (a comma followed by a\n space).  Elements are converted to strings as by\n \u003ctt\u003eString.valueOf(boolean)\u003c/tt\u003e.  Returns \u003ctt\u003e\"null\"\u003c/tt\u003e if\n \u003ctt\u003ea\u003c/tt\u003e is \u003ctt\u003enull\u003c/tt\u003e.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(boolean[])","flatSignature":"(boolean[])","returnType":{"isPrimitive":false,"simpleName":"String","qualifiedName":"java.lang.String","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"a","type":{"isPrimitive":true,"simpleName":"boolean","qualifiedName":"boolean","dimension":"[]","elementType":{"isPrimitive":true,"simpleName":"boolean","qualifiedName":"boolean","dimension":"","elementType":{}}}}],"typeParameters":[]},{"name":"toString","comment":"Returns a string representation of the contents of the specified array.\n The string representation consists of a list of the array\u0027s elements,\n enclosed in square brackets (\u003ctt\u003e\"[]\"\u003c/tt\u003e).  Adjacent elements are\n separated by the characters \u003ctt\u003e\", \"\u003c/tt\u003e (a comma followed by a\n space).  Elements are converted to strings as by\n \u003ctt\u003eString.valueOf(float)\u003c/tt\u003e.  Returns \u003ctt\u003e\"null\"\u003c/tt\u003e if \u003ctt\u003ea\u003c/tt\u003e\n is \u003ctt\u003enull\u003c/tt\u003e.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(float[])","flatSignature":"(float[])","returnType":{"isPrimitive":false,"simpleName":"String","qualifiedName":"java.lang.String","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"a","type":{"isPrimitive":true,"simpleName":"float","qualifiedName":"float","dimension":"[]","elementType":{"isPrimitive":true,"simpleName":"float","qualifiedName":"float","dimension":"","elementType":{}}}}],"typeParameters":[]},{"name":"toString","comment":"Returns a string representation of the contents of the specified array.\n The string representation consists of a list of the array\u0027s elements,\n enclosed in square brackets (\u003ctt\u003e\"[]\"\u003c/tt\u003e).  Adjacent elements are\n separated by the characters \u003ctt\u003e\", \"\u003c/tt\u003e (a comma followed by a\n space).  Elements are converted to strings as by\n \u003ctt\u003eString.valueOf(double)\u003c/tt\u003e.  Returns \u003ctt\u003e\"null\"\u003c/tt\u003e if \u003ctt\u003ea\u003c/tt\u003e\n is \u003ctt\u003enull\u003c/tt\u003e.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(double[])","flatSignature":"(double[])","returnType":{"isPrimitive":false,"simpleName":"String","qualifiedName":"java.lang.String","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"a","type":{"isPrimitive":true,"simpleName":"double","qualifiedName":"double","dimension":"[]","elementType":{"isPrimitive":true,"simpleName":"double","qualifiedName":"double","dimension":"","elementType":{}}}}],"typeParameters":[]},{"name":"toString","comment":"Returns a string representation of the contents of the specified array.\n If the array contains other arrays as elements, they are converted to\n strings by the {@link Object#toString} method inherited from\n \u003ctt\u003eObject\u003c/tt\u003e, which describes their \u003ci\u003eidentities\u003c/i\u003e rather than\n their contents.\n\n \u003cp\u003eThe value returned by this method is equal to the value that would\n be returned by \u003ctt\u003eArrays.asList(a).toString()\u003c/tt\u003e, unless \u003ctt\u003ea\u003c/tt\u003e\n is \u003ctt\u003enull\u003c/tt\u003e, in which case \u003ctt\u003e\"null\"\u003c/tt\u003e is returned.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.lang.Object[])","flatSignature":"(Object[])","returnType":{"isPrimitive":false,"simpleName":"String","qualifiedName":"java.lang.String","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"a","type":{"isPrimitive":false,"simpleName":"Object","qualifiedName":"java.lang.Object","dimension":"[]","elementType":{"isPrimitive":false,"simpleName":"Object","qualifiedName":"java.lang.Object","dimension":"","elementType":{}}}}],"typeParameters":[]},{"name":"deepToString","comment":"Returns a string representation of the \"deep contents\" of the specified\n array.  If the array contains other arrays as elements, the string\n representation contains their contents and so on.  This method is\n designed for converting multidimensional arrays to strings.\n\n \u003cp\u003eThe string representation consists of a list of the array\u0027s\n elements, enclosed in square brackets (\u003ctt\u003e\"[]\"\u003c/tt\u003e).  Adjacent\n elements are separated by the characters \u003ctt\u003e\", \"\u003c/tt\u003e (a comma\n followed by a space).  Elements are converted to strings as by\n \u003ctt\u003eString.valueOf(Object)\u003c/tt\u003e, unless they are themselves\n arrays.\n\n \u003cp\u003eIf an element \u003ctt\u003ee\u003c/tt\u003e is an array of a primitive type, it is\n converted to a string as by invoking the appropriate overloading of\n \u003ctt\u003eArrays.toString(e)\u003c/tt\u003e.  If an element \u003ctt\u003ee\u003c/tt\u003e is an array of a\n reference type, it is converted to a string as by invoking\n this method recursively.\n\n \u003cp\u003eTo avoid infinite recursion, if the specified array contains itself\n as an element, or contains an indirect reference to itself through one\n or more levels of arrays, the self-reference is converted to the string\n \u003ctt\u003e\"[...]\"\u003c/tt\u003e.  For example, an array containing only a reference\n to itself would be rendered as \u003ctt\u003e\"[[...]]\"\u003c/tt\u003e.\n\n \u003cp\u003eThis method returns \u003ctt\u003e\"null\"\u003c/tt\u003e if the specified array\n is \u003ctt\u003enull\u003c/tt\u003e.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.lang.Object[])","flatSignature":"(Object[])","returnType":{"isPrimitive":false,"simpleName":"String","qualifiedName":"java.lang.String","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"a","type":{"isPrimitive":false,"simpleName":"Object","qualifiedName":"java.lang.Object","dimension":"[]","elementType":{"isPrimitive":false,"simpleName":"Object","qualifiedName":"java.lang.Object","dimension":"","elementType":{}}}}],"typeParameters":[]},{"name":"setAll","comment":"Set all elements of the specified array, using the provided\n generator function to compute each element.\n\n \u003cp\u003eIf the generator function throws an exception, it is relayed to\n the caller and the array is left in an indeterminate state.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(T[], java.util.function.IntFunction\u003c? extends T\u003e)","flatSignature":"(T[], IntFunction\u003c? extends T\u003e)","returnType":{"isPrimitive":true,"simpleName":"void","qualifiedName":"void","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"array","type":{"isPrimitive":false,"simpleName":"T","qualifiedName":"T","dimension":"[]","elementType":{"isPrimitive":false,"simpleName":"T","qualifiedName":"T","dimension":"","elementType":{},"typeVariable":{"name":"T","bounds":[]}},"typeVariable":{"name":"T","bounds":[]}}},{"name":"generator","type":{"isPrimitive":false,"simpleName":"IntFunction","qualifiedName":"java.util.function.IntFunction","dimension":"","elementType":{}}}],"typeParameters":[{"name":"T","bounds":[]}]},{"name":"parallelSetAll","comment":"Set all elements of the specified array, in parallel, using the\n provided generator function to compute each element.\n\n \u003cp\u003eIf the generator function throws an exception, an unchecked exception\n is thrown from {@code parallelSetAll} and the array is left in an\n indeterminate state.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(T[], java.util.function.IntFunction\u003c? extends T\u003e)","flatSignature":"(T[], IntFunction\u003c? extends T\u003e)","returnType":{"isPrimitive":true,"simpleName":"void","qualifiedName":"void","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"array","type":{"isPrimitive":false,"simpleName":"T","qualifiedName":"T","dimension":"[]","elementType":{"isPrimitive":false,"simpleName":"T","qualifiedName":"T","dimension":"","elementType":{},"typeVariable":{"name":"T","bounds":[]}},"typeVariable":{"name":"T","bounds":[]}}},{"name":"generator","type":{"isPrimitive":false,"simpleName":"IntFunction","qualifiedName":"java.util.function.IntFunction","dimension":"","elementType":{}}}],"typeParameters":[{"name":"T","bounds":[]}]},{"name":"setAll","comment":"Set all elements of the specified array, using the provided\n generator function to compute each element.\n\n \u003cp\u003eIf the generator function throws an exception, it is relayed to\n the caller and the array is left in an indeterminate state.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(int[], java.util.function.IntUnaryOperator)","flatSignature":"(int[], IntUnaryOperator)","returnType":{"isPrimitive":true,"simpleName":"void","qualifiedName":"void","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"array","type":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"[]","elementType":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}}}},{"name":"generator","type":{"isPrimitive":false,"simpleName":"IntUnaryOperator","qualifiedName":"java.util.function.IntUnaryOperator","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"parallelSetAll","comment":"Set all elements of the specified array, in parallel, using the\n provided generator function to compute each element.\n\n \u003cp\u003eIf the generator function throws an exception, an unchecked exception\n is thrown from {@code parallelSetAll} and the array is left in an\n indeterminate state.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(int[], java.util.function.IntUnaryOperator)","flatSignature":"(int[], IntUnaryOperator)","returnType":{"isPrimitive":true,"simpleName":"void","qualifiedName":"void","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"array","type":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"[]","elementType":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}}}},{"name":"generator","type":{"isPrimitive":false,"simpleName":"IntUnaryOperator","qualifiedName":"java.util.function.IntUnaryOperator","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"setAll","comment":"Set all elements of the specified array, using the provided\n generator function to compute each element.\n\n \u003cp\u003eIf the generator function throws an exception, it is relayed to\n the caller and the array is left in an indeterminate state.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(long[], java.util.function.IntToLongFunction)","flatSignature":"(long[], IntToLongFunction)","returnType":{"isPrimitive":true,"simpleName":"void","qualifiedName":"void","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"array","type":{"isPrimitive":true,"simpleName":"long","qualifiedName":"long","dimension":"[]","elementType":{"isPrimitive":true,"simpleName":"long","qualifiedName":"long","dimension":"","elementType":{}}}},{"name":"generator","type":{"isPrimitive":false,"simpleName":"IntToLongFunction","qualifiedName":"java.util.function.IntToLongFunction","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"parallelSetAll","comment":"Set all elements of the specified array, in parallel, using the\n provided generator function to compute each element.\n\n \u003cp\u003eIf the generator function throws an exception, an unchecked exception\n is thrown from {@code parallelSetAll} and the array is left in an\n indeterminate state.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(long[], java.util.function.IntToLongFunction)","flatSignature":"(long[], IntToLongFunction)","returnType":{"isPrimitive":true,"simpleName":"void","qualifiedName":"void","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"array","type":{"isPrimitive":true,"simpleName":"long","qualifiedName":"long","dimension":"[]","elementType":{"isPrimitive":true,"simpleName":"long","qualifiedName":"long","dimension":"","elementType":{}}}},{"name":"generator","type":{"isPrimitive":false,"simpleName":"IntToLongFunction","qualifiedName":"java.util.function.IntToLongFunction","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"setAll","comment":"Set all elements of the specified array, using the provided\n generator function to compute each element.\n\n \u003cp\u003eIf the generator function throws an exception, it is relayed to\n the caller and the array is left in an indeterminate state.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(double[], java.util.function.IntToDoubleFunction)","flatSignature":"(double[], IntToDoubleFunction)","returnType":{"isPrimitive":true,"simpleName":"void","qualifiedName":"void","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"array","type":{"isPrimitive":true,"simpleName":"double","qualifiedName":"double","dimension":"[]","elementType":{"isPrimitive":true,"simpleName":"double","qualifiedName":"double","dimension":"","elementType":{}}}},{"name":"generator","type":{"isPrimitive":false,"simpleName":"IntToDoubleFunction","qualifiedName":"java.util.function.IntToDoubleFunction","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"parallelSetAll","comment":"Set all elements of the specified array, in parallel, using the\n provided generator function to compute each element.\n\n \u003cp\u003eIf the generator function throws an exception, an unchecked exception\n is thrown from {@code parallelSetAll} and the array is left in an\n indeterminate state.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(double[], java.util.function.IntToDoubleFunction)","flatSignature":"(double[], IntToDoubleFunction)","returnType":{"isPrimitive":true,"simpleName":"void","qualifiedName":"void","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"array","type":{"isPrimitive":true,"simpleName":"double","qualifiedName":"double","dimension":"[]","elementType":{"isPrimitive":true,"simpleName":"double","qualifiedName":"double","dimension":"","elementType":{}}}},{"name":"generator","type":{"isPrimitive":false,"simpleName":"IntToDoubleFunction","qualifiedName":"java.util.function.IntToDoubleFunction","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"spliterator","comment":"Returns a {@link Spliterator} covering all of the specified array.\n\n \u003cp\u003eThe spliterator reports {@link Spliterator#SIZED},\n {@link Spliterator#SUBSIZED}, {@link Spliterator#ORDERED}, and\n {@link Spliterator#IMMUTABLE}.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(T[])","flatSignature":"(T[])","returnType":{"isPrimitive":false,"simpleName":"Spliterator","qualifiedName":"java.util.Spliterator","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"array","type":{"isPrimitive":false,"simpleName":"T","qualifiedName":"T","dimension":"[]","elementType":{"isPrimitive":false,"simpleName":"T","qualifiedName":"T","dimension":"","elementType":{},"typeVariable":{"name":"T","bounds":[]}},"typeVariable":{"name":"T","bounds":[]}}}],"typeParameters":[{"name":"T","bounds":[]}]},{"name":"spliterator","comment":"Returns a {@link Spliterator} covering the specified range of the\n specified array.\n\n \u003cp\u003eThe spliterator reports {@link Spliterator#SIZED},\n {@link Spliterator#SUBSIZED}, {@link Spliterator#ORDERED}, and\n {@link Spliterator#IMMUTABLE}.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(T[], int, int)","flatSignature":"(T[], int, int)","returnType":{"isPrimitive":false,"simpleName":"Spliterator","qualifiedName":"java.util.Spliterator","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"array","type":{"isPrimitive":false,"simpleName":"T","qualifiedName":"T","dimension":"[]","elementType":{"isPrimitive":false,"simpleName":"T","qualifiedName":"T","dimension":"","elementType":{},"typeVariable":{"name":"T","bounds":[]}},"typeVariable":{"name":"T","bounds":[]}}},{"name":"startInclusive","type":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}}},{"name":"endExclusive","type":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}}}],"typeParameters":[{"name":"T","bounds":[]}]},{"name":"spliterator","comment":"Returns a {@link Spliterator.OfInt} covering all of the specified array.\n\n \u003cp\u003eThe spliterator reports {@link Spliterator#SIZED},\n {@link Spliterator#SUBSIZED}, {@link Spliterator#ORDERED}, and\n {@link Spliterator#IMMUTABLE}.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(int[])","flatSignature":"(int[])","returnType":{"isPrimitive":false,"simpleName":"OfInt","qualifiedName":"java.util.Spliterator.OfInt","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"array","type":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"[]","elementType":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}}}}],"typeParameters":[]},{"name":"spliterator","comment":"Returns a {@link Spliterator.OfInt} covering the specified range of the\n specified array.\n\n \u003cp\u003eThe spliterator reports {@link Spliterator#SIZED},\n {@link Spliterator#SUBSIZED}, {@link Spliterator#ORDERED}, and\n {@link Spliterator#IMMUTABLE}.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(int[], int, int)","flatSignature":"(int[], int, int)","returnType":{"isPrimitive":false,"simpleName":"OfInt","qualifiedName":"java.util.Spliterator.OfInt","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"array","type":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"[]","elementType":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}}}},{"name":"startInclusive","type":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}}},{"name":"endExclusive","type":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"spliterator","comment":"Returns a {@link Spliterator.OfLong} covering all of the specified array.\n\n \u003cp\u003eThe spliterator reports {@link Spliterator#SIZED},\n {@link Spliterator#SUBSIZED}, {@link Spliterator#ORDERED}, and\n {@link Spliterator#IMMUTABLE}.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(long[])","flatSignature":"(long[])","returnType":{"isPrimitive":false,"simpleName":"OfLong","qualifiedName":"java.util.Spliterator.OfLong","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"array","type":{"isPrimitive":true,"simpleName":"long","qualifiedName":"long","dimension":"[]","elementType":{"isPrimitive":true,"simpleName":"long","qualifiedName":"long","dimension":"","elementType":{}}}}],"typeParameters":[]},{"name":"spliterator","comment":"Returns a {@link Spliterator.OfLong} covering the specified range of the\n specified array.\n\n \u003cp\u003eThe spliterator reports {@link Spliterator#SIZED},\n {@link Spliterator#SUBSIZED}, {@link Spliterator#ORDERED}, and\n {@link Spliterator#IMMUTABLE}.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(long[], int, int)","flatSignature":"(long[], int, int)","returnType":{"isPrimitive":false,"simpleName":"OfLong","qualifiedName":"java.util.Spliterator.OfLong","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"array","type":{"isPrimitive":true,"simpleName":"long","qualifiedName":"long","dimension":"[]","elementType":{"isPrimitive":true,"simpleName":"long","qualifiedName":"long","dimension":"","elementType":{}}}},{"name":"startInclusive","type":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}}},{"name":"endExclusive","type":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"spliterator","comment":"Returns a {@link Spliterator.OfDouble} covering all of the specified\n array.\n\n \u003cp\u003eThe spliterator reports {@link Spliterator#SIZED},\n {@link Spliterator#SUBSIZED}, {@link Spliterator#ORDERED}, and\n {@link Spliterator#IMMUTABLE}.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(double[])","flatSignature":"(double[])","returnType":{"isPrimitive":false,"simpleName":"OfDouble","qualifiedName":"java.util.Spliterator.OfDouble","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"array","type":{"isPrimitive":true,"simpleName":"double","qualifiedName":"double","dimension":"[]","elementType":{"isPrimitive":true,"simpleName":"double","qualifiedName":"double","dimension":"","elementType":{}}}}],"typeParameters":[]},{"name":"spliterator","comment":"Returns a {@link Spliterator.OfDouble} covering the specified range of\n the specified array.\n\n \u003cp\u003eThe spliterator reports {@link Spliterator#SIZED},\n {@link Spliterator#SUBSIZED}, {@link Spliterator#ORDERED}, and\n {@link Spliterator#IMMUTABLE}.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(double[], int, int)","flatSignature":"(double[], int, int)","returnType":{"isPrimitive":false,"simpleName":"OfDouble","qualifiedName":"java.util.Spliterator.OfDouble","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"array","type":{"isPrimitive":true,"simpleName":"double","qualifiedName":"double","dimension":"[]","elementType":{"isPrimitive":true,"simpleName":"double","qualifiedName":"double","dimension":"","elementType":{}}}},{"name":"startInclusive","type":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}}},{"name":"endExclusive","type":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"stream","comment":"Returns a sequential {@link Stream} with the specified array as its\n source.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(T[])","flatSignature":"(T[])","returnType":{"isPrimitive":false,"simpleName":"Stream","qualifiedName":"java.util.stream.Stream","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"array","type":{"isPrimitive":false,"simpleName":"T","qualifiedName":"T","dimension":"[]","elementType":{"isPrimitive":false,"simpleName":"T","qualifiedName":"T","dimension":"","elementType":{},"typeVariable":{"name":"T","bounds":[]}},"typeVariable":{"name":"T","bounds":[]}}}],"typeParameters":[{"name":"T","bounds":[]}]},{"name":"stream","comment":"Returns a sequential {@link Stream} with the specified range of the\n specified array as its source.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(T[], int, int)","flatSignature":"(T[], int, int)","returnType":{"isPrimitive":false,"simpleName":"Stream","qualifiedName":"java.util.stream.Stream","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"array","type":{"isPrimitive":false,"simpleName":"T","qualifiedName":"T","dimension":"[]","elementType":{"isPrimitive":false,"simpleName":"T","qualifiedName":"T","dimension":"","elementType":{},"typeVariable":{"name":"T","bounds":[]}},"typeVariable":{"name":"T","bounds":[]}}},{"name":"startInclusive","type":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}}},{"name":"endExclusive","type":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}}}],"typeParameters":[{"name":"T","bounds":[]}]},{"name":"stream","comment":"Returns a sequential {@link IntStream} with the specified array as its\n source.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(int[])","flatSignature":"(int[])","returnType":{"isPrimitive":false,"simpleName":"IntStream","qualifiedName":"java.util.stream.IntStream","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"array","type":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"[]","elementType":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}}}}],"typeParameters":[]},{"name":"stream","comment":"Returns a sequential {@link IntStream} with the specified range of the\n specified array as its source.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(int[], int, int)","flatSignature":"(int[], int, int)","returnType":{"isPrimitive":false,"simpleName":"IntStream","qualifiedName":"java.util.stream.IntStream","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"array","type":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"[]","elementType":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}}}},{"name":"startInclusive","type":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}}},{"name":"endExclusive","type":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"stream","comment":"Returns a sequential {@link LongStream} with the specified array as its\n source.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(long[])","flatSignature":"(long[])","returnType":{"isPrimitive":false,"simpleName":"LongStream","qualifiedName":"java.util.stream.LongStream","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"array","type":{"isPrimitive":true,"simpleName":"long","qualifiedName":"long","dimension":"[]","elementType":{"isPrimitive":true,"simpleName":"long","qualifiedName":"long","dimension":"","elementType":{}}}}],"typeParameters":[]},{"name":"stream","comment":"Returns a sequential {@link LongStream} with the specified range of the\n specified array as its source.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(long[], int, int)","flatSignature":"(long[], int, int)","returnType":{"isPrimitive":false,"simpleName":"LongStream","qualifiedName":"java.util.stream.LongStream","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"array","type":{"isPrimitive":true,"simpleName":"long","qualifiedName":"long","dimension":"[]","elementType":{"isPrimitive":true,"simpleName":"long","qualifiedName":"long","dimension":"","elementType":{}}}},{"name":"startInclusive","type":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}}},{"name":"endExclusive","type":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"stream","comment":"Returns a sequential {@link DoubleStream} with the specified array as its\n source.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(double[])","flatSignature":"(double[])","returnType":{"isPrimitive":false,"simpleName":"DoubleStream","qualifiedName":"java.util.stream.DoubleStream","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"array","type":{"isPrimitive":true,"simpleName":"double","qualifiedName":"double","dimension":"[]","elementType":{"isPrimitive":true,"simpleName":"double","qualifiedName":"double","dimension":"","elementType":{}}}}],"typeParameters":[]},{"name":"stream","comment":"Returns a sequential {@link DoubleStream} with the specified range of the\n specified array as its source.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(double[], int, int)","flatSignature":"(double[], int, int)","returnType":{"isPrimitive":false,"simpleName":"DoubleStream","qualifiedName":"java.util.stream.DoubleStream","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"array","type":{"isPrimitive":true,"simpleName":"double","qualifiedName":"double","dimension":"[]","elementType":{"isPrimitive":true,"simpleName":"double","qualifiedName":"double","dimension":"","elementType":{}}}},{"name":"startInclusive","type":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}}},{"name":"endExclusive","type":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}}}],"typeParameters":[]}],"typeParameters":[],"enumConstants":[]}