{"name":"MemoryHandler","comment":"\u003ctt\u003eHandler\u003c/tt\u003e that buffers requests in a circular buffer in memory.\n \u003cp\u003e\n Normally this \u003ctt\u003eHandler\u003c/tt\u003e simply stores incoming \u003ctt\u003eLogRecords\u003c/tt\u003e\n into its memory buffer and discards earlier records.  This buffering\n is very cheap and avoids formatting costs.  On certain trigger\n conditions, the \u003ctt\u003eMemoryHandler\u003c/tt\u003e will push out its current buffer\n contents to a target \u003ctt\u003eHandler\u003c/tt\u003e, which will typically publish\n them to the outside world.\n \u003cp\u003e\n There are three main models for triggering a push of the buffer:\n \u003cul\u003e\n \u003cli\u003e\n An incoming \u003ctt\u003eLogRecord\u003c/tt\u003e has a type that is greater than\n a pre-defined level, the \u003ctt\u003epushLevel\u003c/tt\u003e. \u003c/li\u003e\n \u003cli\u003e\n An external class calls the \u003ctt\u003epush\u003c/tt\u003e method explicitly. \u003c/li\u003e\n \u003cli\u003e\n A subclass overrides the \u003ctt\u003elog\u003c/tt\u003e method and scans each incoming\n \u003ctt\u003eLogRecord\u003c/tt\u003e and calls \u003ctt\u003epush\u003c/tt\u003e if a record matches some\n desired criteria. \u003c/li\u003e\n \u003c/ul\u003e\n \u003cp\u003e\n \u003cb\u003eConfiguration:\u003c/b\u003e\n By default each \u003ctt\u003eMemoryHandler\u003c/tt\u003e is initialized using the following\n \u003ctt\u003eLogManager\u003c/tt\u003e configuration properties where \u003ctt\u003e\u0026lt;handler-name\u0026gt;\u003c/tt\u003e\n refers to the fully-qualified class name of the handler.\n If properties are not defined\n (or have invalid values) then the specified default values are used.\n If no default value is defined then a RuntimeException is thrown.\n \u003cul\u003e\n \u003cli\u003e   \u0026lt;handler-name\u0026gt;.level\n        specifies the level for the \u003ctt\u003eHandler\u003c/tt\u003e\n        (defaults to \u003ctt\u003eLevel.ALL\u003c/tt\u003e). \u003c/li\u003e\n \u003cli\u003e   \u0026lt;handler-name\u0026gt;.filter\n        specifies the name of a \u003ctt\u003eFilter\u003c/tt\u003e class to use\n        (defaults to no \u003ctt\u003eFilter\u003c/tt\u003e). \u003c/li\u003e\n \u003cli\u003e   \u0026lt;handler-name\u0026gt;.size\n        defines the buffer size (defaults to 1000). \u003c/li\u003e\n \u003cli\u003e   \u0026lt;handler-name\u0026gt;.push\n        defines the \u003ctt\u003epushLevel\u003c/tt\u003e (defaults to \u003ctt\u003elevel.SEVERE\u003c/tt\u003e). \u003c/li\u003e\n \u003cli\u003e   \u0026lt;handler-name\u0026gt;.target\n        specifies the name of the target \u003ctt\u003eHandler \u003c/tt\u003e class.\n        (no default). \u003c/li\u003e\n \u003c/ul\u003e\n \u003cp\u003e\n For example, the properties for {@code MemoryHandler} would be:\n \u003cul\u003e\n \u003cli\u003e   java.util.logging.MemoryHandler.level\u003dINFO \u003c/li\u003e\n \u003cli\u003e   java.util.logging.MemoryHandler.formatter\u003djava.util.logging.SimpleFormatter \u003c/li\u003e\n \u003c/ul\u003e\n \u003cp\u003e\n For a custom handler, e.g. com.foo.MyHandler, the properties would be:\n \u003cul\u003e\n \u003cli\u003e   com.foo.MyHandler.level\u003dINFO \u003c/li\u003e\n \u003cli\u003e   com.foo.MyHandler.formatter\u003djava.util.logging.SimpleFormatter \u003c/li\u003e\n \u003c/ul\u003e\n \u003cp\u003e","isClass":true,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":false,"isOrdinaryClass":true,"isPrimitive":false,"simpleName":"MemoryHandler","qualifiedName":"java.util.logging.MemoryHandler","dimension":"","elementType":{},"package":"java.util.logging","superclass":"java.util.logging.Handler","interfaces":[],"isAbstract":false,"isStatic":false,"since":"1.4","innerClasses":[],"isInnerClass":false,"constructors":[{"name":"MemoryHandler","comment":"Create a \u003ctt\u003eMemoryHandler\u003c/tt\u003e and configure it based on\n \u003ctt\u003eLogManager\u003c/tt\u003e configuration properties.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":true,"isField":false,"isMethod":false,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","parameters":[],"typeParameters":[]},{"name":"MemoryHandler","comment":"Create a \u003ctt\u003eMemoryHandler\u003c/tt\u003e.\n \u003cp\u003e\n The \u003ctt\u003eMemoryHandler\u003c/tt\u003e is configured based on \u003ctt\u003eLogManager\u003c/tt\u003e\n properties (or their default values) except that the given \u003ctt\u003epushLevel\u003c/tt\u003e\n argument and buffer size argument are used.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":true,"isField":false,"isMethod":false,"isOrdinaryClass":false,"signature":"(java.util.logging.Handler, int, java.util.logging.Level)","flatSignature":"(Handler, int, Level)","parameters":[{"name":"target","type":{"isPrimitive":false,"simpleName":"Handler","qualifiedName":"java.util.logging.Handler","dimension":"","elementType":{}}},{"name":"size","type":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}}},{"name":"pushLevel","type":{"isPrimitive":false,"simpleName":"Level","qualifiedName":"java.util.logging.Level","dimension":"","elementType":{}}}],"typeParameters":[]}],"fields":[],"methods":[{"name":"publish","comment":"Store a \u003ctt\u003eLogRecord\u003c/tt\u003e in an internal buffer.\n \u003cp\u003e\n If there is a \u003ctt\u003eFilter\u003c/tt\u003e, its \u003ctt\u003eisLoggable\u003c/tt\u003e\n method is called to check if the given log record is loggable.\n If not we return.  Otherwise the given record is copied into\n an internal circular buffer.  Then the record\u0027s level property is\n compared with the \u003ctt\u003epushLevel\u003c/tt\u003e. If the given level is\n greater than or equal to the \u003ctt\u003epushLevel\u003c/tt\u003e then \u003ctt\u003epush\u003c/tt\u003e\n is called to write all buffered records to the target output\n \u003ctt\u003eHandler\u003c/tt\u003e.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.util.logging.LogRecord)","flatSignature":"(LogRecord)","returnType":{"isPrimitive":true,"simpleName":"void","qualifiedName":"void","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[{"name":"record","type":{"isPrimitive":false,"simpleName":"LogRecord","qualifiedName":"java.util.logging.LogRecord","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"push","comment":"Push any buffered output to the target \u003ctt\u003eHandler\u003c/tt\u003e.\n \u003cp\u003e\n The buffer is then cleared.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":true,"simpleName":"void","qualifiedName":"void","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[],"typeParameters":[]},{"name":"flush","comment":"Causes a flush on the target \u003ctt\u003eHandler\u003c/tt\u003e.\n \u003cp\u003e\n Note that the current contents of the \u003ctt\u003eMemoryHandler\u003c/tt\u003e\n buffer are \u003cb\u003enot\u003c/b\u003e written out.  That requires a \"push\".","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":true,"simpleName":"void","qualifiedName":"void","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[],"typeParameters":[]},{"name":"close","comment":"Close the \u003ctt\u003eHandler\u003c/tt\u003e and free all associated resources.\n This will also close the target \u003ctt\u003eHandler\u003c/tt\u003e.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":true,"simpleName":"void","qualifiedName":"void","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[],"typeParameters":[]},{"name":"setPushLevel","comment":"Set the \u003ctt\u003epushLevel\u003c/tt\u003e.  After a \u003ctt\u003eLogRecord\u003c/tt\u003e is copied\n into our internal buffer, if its level is greater than or equal to\n the \u003ctt\u003epushLevel\u003c/tt\u003e, then \u003ctt\u003epush\u003c/tt\u003e will be called.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.util.logging.Level)","flatSignature":"(Level)","returnType":{"isPrimitive":true,"simpleName":"void","qualifiedName":"void","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[{"name":"newLevel","type":{"isPrimitive":false,"simpleName":"Level","qualifiedName":"java.util.logging.Level","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"getPushLevel","comment":"Get the \u003ctt\u003epushLevel\u003c/tt\u003e.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":false,"simpleName":"Level","qualifiedName":"java.util.logging.Level","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[],"typeParameters":[]},{"name":"isLoggable","comment":"Check if this \u003ctt\u003eHandler\u003c/tt\u003e would actually log a given\n \u003ctt\u003eLogRecord\u003c/tt\u003e into its internal buffer.\n \u003cp\u003e\n This method checks if the \u003ctt\u003eLogRecord\u003c/tt\u003e has an appropriate level and\n whether it satisfies any \u003ctt\u003eFilter\u003c/tt\u003e.  However it does \u003cb\u003enot\u003c/b\u003e\n check whether the \u003ctt\u003eLogRecord\u003c/tt\u003e would result in a \"push\" of the\n buffer contents. It will return false if the \u003ctt\u003eLogRecord\u003c/tt\u003e is null.\n \u003cp\u003e","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.util.logging.LogRecord)","flatSignature":"(LogRecord)","returnType":{"isPrimitive":true,"simpleName":"boolean","qualifiedName":"boolean","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[{"name":"record","type":{"isPrimitive":false,"simpleName":"LogRecord","qualifiedName":"java.util.logging.LogRecord","dimension":"","elementType":{}}}],"typeParameters":[]}],"typeParameters":[],"enumConstants":[]}