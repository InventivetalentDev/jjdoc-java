{"name":"Formattable","comment":"The \u003ctt\u003eFormattable\u003c/tt\u003e interface must be implemented by any class that\n needs to perform custom formatting using the \u003ctt\u003e\u0027s\u0027\u003c/tt\u003e conversion\n specifier of {@link java.util.Formatter}.  This interface allows basic\n control for formatting arbitrary objects.\n\n For example, the following class prints out different representations of a\n stock\u0027s name depending on the flags and length constraints:\n\n {@code\n   import java.nio.CharBuffer;\n   import java.util.Formatter;\n   import java.util.Formattable;\n   import java.util.Locale;\n   import static java.util.FormattableFlags.*;\n\n  ...\n\n   public class StockName implements Formattable {\n       private String symbol, companyName, frenchCompanyName;\n       public StockName(String symbol, String companyName,\n                        String frenchCompanyName) {\n           ...\n       }\n\n       ...\n\n       public void formatTo(Formatter fmt, int f, int width, int precision) {\n           StringBuilder sb \u003d new StringBuilder();\n\n           // decide form of name\n           String name \u003d companyName;\n           if (fmt.locale().equals(Locale.FRANCE))\n               name \u003d frenchCompanyName;\n           boolean alternate \u003d (f \u0026 ALTERNATE) \u003d\u003d ALTERNATE;\n           boolean usesymbol \u003d alternate || (precision !\u003d -1 \u0026\u0026 precision \u003c 10);\n           String out \u003d (usesymbol ? symbol : name);\n\n           // apply precision\n           if (precision \u003d\u003d -1 || out.length() \u003c precision) {\n               // write it all\n               sb.append(out);\n           } else {\n               sb.append(out.substring(0, precision - 1)).append(\u0027*\u0027);\n           }\n\n           // apply width and justification\n           int len \u003d sb.length();\n           if (len \u003c width)\n               for (int i \u003d 0; i \u003c width - len; i++)\n                   if ((f \u0026 LEFT_JUSTIFY) \u003d\u003d LEFT_JUSTIFY)\n                       sb.append(\u0027 \u0027);\n                   else\n                       sb.insert(0, \u0027 \u0027);\n\n           fmt.format(sb.toString());\n       }\n\n       public String toString() {\n           return String.format(\"%s - %s\", symbol, companyName);\n       }\n   }\n }\n\n \u003cp\u003e When used in conjunction with the {@link java.util.Formatter}, the above\n class produces the following output for various format strings.\n\n {@code\n   Formatter fmt \u003d new Formatter();\n   StockName sn \u003d new StockName(\"HUGE\", \"Huge Fruit, Inc.\",\n                                \"Fruit Titanesque, Inc.\");\n   fmt.format(\"%s\", sn);                   //   -\u003e \"Huge Fruit, Inc.\"\n   fmt.format(\"%s\", sn.toString());        //   -\u003e \"HUGE - Huge Fruit, Inc.\"\n   fmt.format(\"%#s\", sn);                  //   -\u003e \"HUGE\"\n   fmt.format(\"%-10.8s\", sn);              //   -\u003e \"HUGE      \"\n   fmt.format(\"%.12s\", sn);                //   -\u003e \"Huge Fruit,*\"\n   fmt.format(Locale.FRANCE, \"%25s\", sn);  //   -\u003e \"   Fruit Titanesque, Inc.\"\n }\n\n \u003cp\u003e Formattables are not necessarily safe for multithreaded access.  Thread\n safety is optional and may be enforced by classes that extend and implement\n this interface.\n\n \u003cp\u003e Unless otherwise specified, passing a \u003ctt\u003enull\u003c/tt\u003e argument to\n any method in this interface will cause a {@link\n NullPointerException} to be thrown.","isClass":false,"isInterface":true,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":false,"isOrdinaryClass":false,"isPrimitive":false,"simpleName":"Formattable","qualifiedName":"java.util.Formattable","dimension":"","elementType":{},"package":"java.util","interfaces":[],"isAbstract":true,"isStatic":false,"since":"1.5","innerClasses":[],"isInnerClass":false,"constructors":[],"fields":[],"methods":[{"name":"formatTo","comment":"Formats the object using the provided {@link Formatter formatter}.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.util.Formatter, int, int, int)","flatSignature":"(Formatter, int, int, int)","returnType":{"isPrimitive":true,"simpleName":"void","qualifiedName":"void","dimension":"","elementType":{}},"isAbstract":true,"isDefault":false,"isStatic":false,"parameters":[{"name":"formatter","type":{"isPrimitive":false,"simpleName":"Formatter","qualifiedName":"java.util.Formatter","dimension":"","elementType":{}}},{"name":"flags","type":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}}},{"name":"width","type":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}}},{"name":"precision","type":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}}}],"typeParameters":[]}],"typeParameters":[],"enumConstants":[]}