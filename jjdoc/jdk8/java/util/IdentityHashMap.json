{"name":"IdentityHashMap","comment":"This class implements the \u003ctt\u003eMap\u003c/tt\u003e interface with a hash table, using\n reference-equality in place of object-equality when comparing keys (and\n values).  In other words, in an \u003ctt\u003eIdentityHashMap\u003c/tt\u003e, two keys\n \u003ctt\u003ek1\u003c/tt\u003e and \u003ctt\u003ek2\u003c/tt\u003e are considered equal if and only if\n \u003ctt\u003e(k1\u003d\u003dk2)\u003c/tt\u003e.  (In normal \u003ctt\u003eMap\u003c/tt\u003e implementations (like\n \u003ctt\u003eHashMap\u003c/tt\u003e) two keys \u003ctt\u003ek1\u003c/tt\u003e and \u003ctt\u003ek2\u003c/tt\u003e are considered equal\n if and only if \u003ctt\u003e(k1\u003d\u003dnull ? k2\u003d\u003dnull : k1.equals(k2))\u003c/tt\u003e.)\n\n \u003cp\u003e\u003cb\u003eThis class is \u003ci\u003enot\u003c/i\u003e a general-purpose \u003ctt\u003eMap\u003c/tt\u003e\n implementation!  While this class implements the \u003ctt\u003eMap\u003c/tt\u003e interface, it\n intentionally violates \u003ctt\u003eMap\u0027s\u003c/tt\u003e general contract, which mandates the\n use of the \u003ctt\u003eequals\u003c/tt\u003e method when comparing objects.  This class is\n designed for use only in the rare cases wherein reference-equality\n semantics are required.\u003c/b\u003e\n\n \u003cp\u003eA typical use of this class is \u003ci\u003etopology-preserving object graph\n transformations\u003c/i\u003e, such as serialization or deep-copying.  To perform such\n a transformation, a program must maintain a \"node table\" that keeps track\n of all the object references that have already been processed.  The node\n table must not equate distinct objects even if they happen to be equal.\n Another typical use of this class is to maintain \u003ci\u003eproxy objects\u003c/i\u003e.  For\n example, a debugging facility might wish to maintain a proxy object for\n each object in the program being debugged.\n\n \u003cp\u003eThis class provides all of the optional map operations, and permits\n \u003ctt\u003enull\u003c/tt\u003e values and the \u003ctt\u003enull\u003c/tt\u003e key.  This class makes no\n guarantees as to the order of the map; in particular, it does not guarantee\n that the order will remain constant over time.\n\n \u003cp\u003eThis class provides constant-time performance for the basic\n operations (\u003ctt\u003eget\u003c/tt\u003e and \u003ctt\u003eput\u003c/tt\u003e), assuming the system\n identity hash function ({@link System#identityHashCode(Object)})\n disperses elements properly among the buckets.\n\n \u003cp\u003eThis class has one tuning parameter (which affects performance but not\n semantics): \u003ci\u003eexpected maximum size\u003c/i\u003e.  This parameter is the maximum\n number of key-value mappings that the map is expected to hold.  Internally,\n this parameter is used to determine the number of buckets initially\n comprising the hash table.  The precise relationship between the expected\n maximum size and the number of buckets is unspecified.\n\n \u003cp\u003eIf the size of the map (the number of key-value mappings) sufficiently\n exceeds the expected maximum size, the number of buckets is increased.\n Increasing the number of buckets (\"rehashing\") may be fairly expensive, so\n it pays to create identity hash maps with a sufficiently large expected\n maximum size.  On the other hand, iteration over collection views requires\n time proportional to the number of buckets in the hash table, so it\n pays not to set the expected maximum size too high if you are especially\n concerned with iteration performance or memory usage.\n\n \u003cp\u003e\u003cstrong\u003eNote that this implementation is not synchronized.\u003c/strong\u003e\n If multiple threads access an identity hash map concurrently, and at\n least one of the threads modifies the map structurally, it \u003ci\u003emust\u003c/i\u003e\n be synchronized externally.  (A structural modification is any operation\n that adds or deletes one or more mappings; merely changing the value\n associated with a key that an instance already contains is not a\n structural modification.)  This is typically accomplished by\n synchronizing on some object that naturally encapsulates the map.\n\n If no such object exists, the map should be \"wrapped\" using the\n {@link Collections#synchronizedMap Collections.synchronizedMap}\n method.  This is best done at creation time, to prevent accidental\n unsynchronized access to the map:\u003cpre\u003e\n   Map m \u003d Collections.synchronizedMap(new IdentityHashMap(...));\u003c/pre\u003e\n\n \u003cp\u003eThe iterators returned by the \u003ctt\u003eiterator\u003c/tt\u003e method of the\n collections returned by all of this class\u0027s \"collection view\n methods\" are \u003ci\u003efail-fast\u003c/i\u003e: if the map is structurally modified\n at any time after the iterator is created, in any way except\n through the iterator\u0027s own \u003ctt\u003eremove\u003c/tt\u003e method, the iterator\n will throw a {@link ConcurrentModificationException}.  Thus, in the\n face of concurrent modification, the iterator fails quickly and\n cleanly, rather than risking arbitrary, non-deterministic behavior\n at an undetermined time in the future.\n\n \u003cp\u003eNote that the fail-fast behavior of an iterator cannot be guaranteed\n as it is, generally speaking, impossible to make any hard guarantees in the\n presence of unsynchronized concurrent modification.  Fail-fast iterators\n throw \u003ctt\u003eConcurrentModificationException\u003c/tt\u003e on a best-effort basis.\n Therefore, it would be wrong to write a program that depended on this\n exception for its correctness: \u003ci\u003efail-fast iterators should be used only\n to detect bugs.\u003c/i\u003e\n\n \u003cp\u003eImplementation note: This is a simple \u003ci\u003elinear-probe\u003c/i\u003e hash table,\n as described for example in texts by Sedgewick and Knuth.  The array\n alternates holding keys and values.  (This has better locality for large\n tables than does using separate arrays.)  For many JRE implementations\n and operation mixes, this class will yield better performance than\n {@link HashMap} (which uses \u003ci\u003echaining\u003c/i\u003e rather than linear-probing).\n\n \u003cp\u003eThis class is a member of the\n \u003ca href\u003d\"{@docRoot}/../technotes/guides/collections/index.html\"\u003e\n Java Collections Framework\u003c/a\u003e.","isClass":true,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":false,"isOrdinaryClass":true,"isPrimitive":false,"simpleName":"IdentityHashMap","qualifiedName":"java.util.IdentityHashMap","dimension":"","elementType":{},"package":"java.util","superclass":"java.util.AbstractMap","interfaces":["java.util.Map","java.io.Serializable","java.lang.Cloneable"],"isAbstract":false,"isStatic":false,"since":"1.4","innerClasses":[],"isInnerClass":false,"constructors":[{"name":"IdentityHashMap","comment":"Constructs a new, empty identity hash map with a default expected\n maximum size (21).","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":true,"isField":false,"isMethod":false,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","parameters":[],"typeParameters":[]},{"name":"IdentityHashMap","comment":"Constructs a new, empty map with the specified expected maximum size.\n Putting more than the expected number of key-value mappings into\n the map may cause the internal data structure to grow, which may be\n somewhat time-consuming.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":true,"isField":false,"isMethod":false,"isOrdinaryClass":false,"signature":"(int)","flatSignature":"(int)","parameters":[{"name":"expectedMaxSize","type":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"IdentityHashMap","comment":"Constructs a new identity hash map containing the keys-value mappings\n in the specified map.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":true,"isField":false,"isMethod":false,"isOrdinaryClass":false,"signature":"(java.util.Map\u003c? extends K, ? extends V\u003e)","flatSignature":"(Map\u003c? extends K, ? extends V\u003e)","parameters":[{"name":"m","type":{"isPrimitive":false,"simpleName":"Map","qualifiedName":"java.util.Map","dimension":"","elementType":{}}}],"typeParameters":[]}],"fields":[],"methods":[{"name":"size","comment":"Returns the number of key-value mappings in this identity hash map.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[],"typeParameters":[]},{"name":"isEmpty","comment":"Returns \u003ctt\u003etrue\u003c/tt\u003e if this identity hash map contains no key-value\n mappings.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":true,"simpleName":"boolean","qualifiedName":"boolean","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[],"typeParameters":[]},{"name":"get","comment":"Returns the value to which the specified key is mapped,\n or {@code null} if this map contains no mapping for the key.\n\n \u003cp\u003eMore formally, if this map contains a mapping from a key\n {@code k} to a value {@code v} such that {@code (key \u003d\u003d k)},\n then this method returns {@code v}; otherwise it returns\n {@code null}.  (There can be at most one such mapping.)\n\n \u003cp\u003eA return value of {@code null} does not \u003ci\u003enecessarily\u003c/i\u003e\n indicate that the map contains no mapping for the key; it\u0027s also\n possible that the map explicitly maps the key to {@code null}.\n The {@link #containsKey containsKey} operation may be used to\n distinguish these two cases.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.lang.Object)","flatSignature":"(Object)","returnType":{"isPrimitive":false,"simpleName":"V","qualifiedName":"V","dimension":"","elementType":{},"typeVariable":{"name":"V","bounds":[]}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[{"name":"key","type":{"isPrimitive":false,"simpleName":"Object","qualifiedName":"java.lang.Object","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"containsKey","comment":"Tests whether the specified object reference is a key in this identity\n hash map.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.lang.Object)","flatSignature":"(Object)","returnType":{"isPrimitive":true,"simpleName":"boolean","qualifiedName":"boolean","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[{"name":"key","type":{"isPrimitive":false,"simpleName":"Object","qualifiedName":"java.lang.Object","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"containsValue","comment":"Tests whether the specified object reference is a value in this identity\n hash map.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.lang.Object)","flatSignature":"(Object)","returnType":{"isPrimitive":true,"simpleName":"boolean","qualifiedName":"boolean","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[{"name":"value","type":{"isPrimitive":false,"simpleName":"Object","qualifiedName":"java.lang.Object","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"put","comment":"Associates the specified value with the specified key in this identity\n hash map.  If the map previously contained a mapping for the key, the\n old value is replaced.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(K, V)","flatSignature":"(K, V)","returnType":{"isPrimitive":false,"simpleName":"V","qualifiedName":"V","dimension":"","elementType":{},"typeVariable":{"name":"V","bounds":[]}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[{"name":"key","type":{"isPrimitive":false,"simpleName":"K","qualifiedName":"K","dimension":"","elementType":{},"typeVariable":{"name":"K","bounds":[]}}},{"name":"value","type":{"isPrimitive":false,"simpleName":"V","qualifiedName":"V","dimension":"","elementType":{},"typeVariable":{"name":"V","bounds":[]}}}],"typeParameters":[]},{"name":"putAll","comment":"Copies all of the mappings from the specified map to this map.\n These mappings will replace any mappings that this map had for\n any of the keys currently in the specified map.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.util.Map\u003c? extends K, ? extends V\u003e)","flatSignature":"(Map\u003c? extends K, ? extends V\u003e)","returnType":{"isPrimitive":true,"simpleName":"void","qualifiedName":"void","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[{"name":"m","type":{"isPrimitive":false,"simpleName":"Map","qualifiedName":"java.util.Map","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"remove","comment":"Removes the mapping for this key from this map if present.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.lang.Object)","flatSignature":"(Object)","returnType":{"isPrimitive":false,"simpleName":"V","qualifiedName":"V","dimension":"","elementType":{},"typeVariable":{"name":"V","bounds":[]}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[{"name":"key","type":{"isPrimitive":false,"simpleName":"Object","qualifiedName":"java.lang.Object","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"clear","comment":"Removes all of the mappings from this map.\n The map will be empty after this call returns.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":true,"simpleName":"void","qualifiedName":"void","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[],"typeParameters":[]},{"name":"equals","comment":"Compares the specified object with this map for equality.  Returns\n \u003ctt\u003etrue\u003c/tt\u003e if the given object is also a map and the two maps\n represent identical object-reference mappings.  More formally, this\n map is equal to another map \u003ctt\u003em\u003c/tt\u003e if and only if\n \u003ctt\u003ethis.entrySet().equals(m.entrySet())\u003c/tt\u003e.\n\n \u003cp\u003e\u003cb\u003eOwing to the reference-equality-based semantics of this map it is\n possible that the symmetry and transitivity requirements of the\n \u003ctt\u003eObject.equals\u003c/tt\u003e contract may be violated if this map is compared\n to a normal map.  However, the \u003ctt\u003eObject.equals\u003c/tt\u003e contract is\n guaranteed to hold among \u003ctt\u003eIdentityHashMap\u003c/tt\u003e instances.\u003c/b\u003e","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.lang.Object)","flatSignature":"(Object)","returnType":{"isPrimitive":true,"simpleName":"boolean","qualifiedName":"boolean","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[{"name":"o","type":{"isPrimitive":false,"simpleName":"Object","qualifiedName":"java.lang.Object","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"hashCode","comment":"Returns the hash code value for this map.  The hash code of a map is\n defined to be the sum of the hash codes of each entry in the map\u0027s\n \u003ctt\u003eentrySet()\u003c/tt\u003e view.  This ensures that \u003ctt\u003em1.equals(m2)\u003c/tt\u003e\n implies that \u003ctt\u003em1.hashCode()\u003d\u003dm2.hashCode()\u003c/tt\u003e for any two\n \u003ctt\u003eIdentityHashMap\u003c/tt\u003e instances \u003ctt\u003em1\u003c/tt\u003e and \u003ctt\u003em2\u003c/tt\u003e, as\n required by the general contract of {@link Object#hashCode}.\n\n \u003cp\u003e\u003cb\u003eOwing to the reference-equality-based semantics of the\n \u003ctt\u003eMap.Entry\u003c/tt\u003e instances in the set returned by this map\u0027s\n \u003ctt\u003eentrySet\u003c/tt\u003e method, it is possible that the contractual\n requirement of \u003ctt\u003eObject.hashCode\u003c/tt\u003e mentioned in the previous\n paragraph will be violated if one of the two objects being compared is\n an \u003ctt\u003eIdentityHashMap\u003c/tt\u003e instance and the other is a normal map.\u003c/b\u003e","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[],"typeParameters":[]},{"name":"clone","comment":"Returns a shallow copy of this identity hash map: the keys and values\n themselves are not cloned.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":false,"simpleName":"Object","qualifiedName":"java.lang.Object","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[],"typeParameters":[]},{"name":"keySet","comment":"Returns an identity-based set view of the keys contained in this map.\n The set is backed by the map, so changes to the map are reflected in\n the set, and vice-versa.  If the map is modified while an iteration\n over the set is in progress, the results of the iteration are\n undefined.  The set supports element removal, which removes the\n corresponding mapping from the map, via the \u003ctt\u003eIterator.remove\u003c/tt\u003e,\n \u003ctt\u003eSet.remove\u003c/tt\u003e, \u003ctt\u003eremoveAll\u003c/tt\u003e, \u003ctt\u003eretainAll\u003c/tt\u003e, and\n \u003ctt\u003eclear\u003c/tt\u003e methods.  It does not support the \u003ctt\u003eadd\u003c/tt\u003e or\n \u003ctt\u003eaddAll\u003c/tt\u003e methods.\n\n \u003cp\u003e\u003cb\u003eWhile the object returned by this method implements the\n \u003ctt\u003eSet\u003c/tt\u003e interface, it does \u003ci\u003enot\u003c/i\u003e obey \u003ctt\u003eSet\u0027s\u003c/tt\u003e general\n contract.  Like its backing map, the set returned by this method\n defines element equality as reference-equality rather than\n object-equality.  This affects the behavior of its \u003ctt\u003econtains\u003c/tt\u003e,\n \u003ctt\u003eremove\u003c/tt\u003e, \u003ctt\u003econtainsAll\u003c/tt\u003e, \u003ctt\u003eequals\u003c/tt\u003e, and\n \u003ctt\u003ehashCode\u003c/tt\u003e methods.\u003c/b\u003e\n\n \u003cp\u003e\u003cb\u003eThe \u003ctt\u003eequals\u003c/tt\u003e method of the returned set returns \u003ctt\u003etrue\u003c/tt\u003e\n only if the specified object is a set containing exactly the same\n object references as the returned set.  The symmetry and transitivity\n requirements of the \u003ctt\u003eObject.equals\u003c/tt\u003e contract may be violated if\n the set returned by this method is compared to a normal set.  However,\n the \u003ctt\u003eObject.equals\u003c/tt\u003e contract is guaranteed to hold among sets\n returned by this method.\u003c/b\u003e\n\n \u003cp\u003eThe \u003ctt\u003ehashCode\u003c/tt\u003e method of the returned set returns the sum of\n the \u003ci\u003eidentity hashcodes\u003c/i\u003e of the elements in the set, rather than\n the sum of their hashcodes.  This is mandated by the change in the\n semantics of the \u003ctt\u003eequals\u003c/tt\u003e method, in order to enforce the\n general contract of the \u003ctt\u003eObject.hashCode\u003c/tt\u003e method among sets\n returned by this method.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":false,"simpleName":"Set","qualifiedName":"java.util.Set","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[],"typeParameters":[]},{"name":"values","comment":"Returns a {@link Collection} view of the values contained in this map.\n The collection is backed by the map, so changes to the map are\n reflected in the collection, and vice-versa.  If the map is\n modified while an iteration over the collection is in progress,\n the results of the iteration are undefined.  The collection\n supports element removal, which removes the corresponding\n mapping from the map, via the \u003ctt\u003eIterator.remove\u003c/tt\u003e,\n \u003ctt\u003eCollection.remove\u003c/tt\u003e, \u003ctt\u003eremoveAll\u003c/tt\u003e,\n \u003ctt\u003eretainAll\u003c/tt\u003e and \u003ctt\u003eclear\u003c/tt\u003e methods.  It does not\n support the \u003ctt\u003eadd\u003c/tt\u003e or \u003ctt\u003eaddAll\u003c/tt\u003e methods.\n\n \u003cp\u003e\u003cb\u003eWhile the object returned by this method implements the\n \u003ctt\u003eCollection\u003c/tt\u003e interface, it does \u003ci\u003enot\u003c/i\u003e obey\n \u003ctt\u003eCollection\u0027s\u003c/tt\u003e general contract.  Like its backing map,\n the collection returned by this method defines element equality as\n reference-equality rather than object-equality.  This affects the\n behavior of its \u003ctt\u003econtains\u003c/tt\u003e, \u003ctt\u003eremove\u003c/tt\u003e and\n \u003ctt\u003econtainsAll\u003c/tt\u003e methods.\u003c/b\u003e","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":false,"simpleName":"Collection","qualifiedName":"java.util.Collection","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[],"typeParameters":[]},{"name":"entrySet","comment":"Returns a {@link Set} view of the mappings contained in this map.\n Each element in the returned set is a reference-equality-based\n \u003ctt\u003eMap.Entry\u003c/tt\u003e.  The set is backed by the map, so changes\n to the map are reflected in the set, and vice-versa.  If the\n map is modified while an iteration over the set is in progress,\n the results of the iteration are undefined.  The set supports\n element removal, which removes the corresponding mapping from\n the map, via the \u003ctt\u003eIterator.remove\u003c/tt\u003e, \u003ctt\u003eSet.remove\u003c/tt\u003e,\n \u003ctt\u003eremoveAll\u003c/tt\u003e, \u003ctt\u003eretainAll\u003c/tt\u003e and \u003ctt\u003eclear\u003c/tt\u003e\n methods.  It does not support the \u003ctt\u003eadd\u003c/tt\u003e or\n \u003ctt\u003eaddAll\u003c/tt\u003e methods.\n\n \u003cp\u003eLike the backing map, the \u003ctt\u003eMap.Entry\u003c/tt\u003e objects in the set\n returned by this method define key and value equality as\n reference-equality rather than object-equality.  This affects the\n behavior of the \u003ctt\u003eequals\u003c/tt\u003e and \u003ctt\u003ehashCode\u003c/tt\u003e methods of these\n \u003ctt\u003eMap.Entry\u003c/tt\u003e objects.  A reference-equality based \u003ctt\u003eMap.Entry\n e\u003c/tt\u003e is equal to an object \u003ctt\u003eo\u003c/tt\u003e if and only if \u003ctt\u003eo\u003c/tt\u003e is a\n \u003ctt\u003eMap.Entry\u003c/tt\u003e and \u003ctt\u003ee.getKey()\u003d\u003do.getKey() \u0026amp;\u0026amp;\n e.getValue()\u003d\u003do.getValue()\u003c/tt\u003e.  To accommodate these equals\n semantics, the \u003ctt\u003ehashCode\u003c/tt\u003e method returns\n \u003ctt\u003eSystem.identityHashCode(e.getKey()) ^\n System.identityHashCode(e.getValue())\u003c/tt\u003e.\n\n \u003cp\u003e\u003cb\u003eOwing to the reference-equality-based semantics of the\n \u003ctt\u003eMap.Entry\u003c/tt\u003e instances in the set returned by this method,\n it is possible that the symmetry and transitivity requirements of\n the {@link Object#equals(Object)} contract may be violated if any of\n the entries in the set is compared to a normal map entry, or if\n the set returned by this method is compared to a set of normal map\n entries (such as would be returned by a call to this method on a normal\n map).  However, the \u003ctt\u003eObject.equals\u003c/tt\u003e contract is guaranteed to\n hold among identity-based map entries, and among sets of such entries.\n \u003c/b\u003e","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":false,"simpleName":"Set","qualifiedName":"java.util.Set","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[],"typeParameters":[]},{"name":"forEach","comment":"","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.util.function.BiConsumer\u003c? super K, ? super V\u003e)","flatSignature":"(BiConsumer\u003c? super K, ? super V\u003e)","returnType":{"isPrimitive":true,"simpleName":"void","qualifiedName":"void","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[{"name":"action","type":{"isPrimitive":false,"simpleName":"BiConsumer","qualifiedName":"java.util.function.BiConsumer","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"replaceAll","comment":"","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.util.function.BiFunction\u003c? super K, ? super V, ? extends V\u003e)","flatSignature":"(BiFunction\u003c? super K, ? super V, ? extends V\u003e)","returnType":{"isPrimitive":true,"simpleName":"void","qualifiedName":"void","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[{"name":"function","type":{"isPrimitive":false,"simpleName":"BiFunction","qualifiedName":"java.util.function.BiFunction","dimension":"","elementType":{}}}],"typeParameters":[]}],"typeParameters":[{"name":"K","bounds":[]},{"name":"V","bounds":[]}],"enumConstants":[]}