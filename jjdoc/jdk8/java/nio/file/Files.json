{"name":"Files","comment":"This class consists exclusively of static methods that operate on files,\n directories, or other types of files.\n\n \u003cp\u003e In most cases, the methods defined here will delegate to the associated\n file system provider to perform the file operations.","isClass":true,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":false,"isOrdinaryClass":true,"isPrimitive":false,"simpleName":"Files","qualifiedName":"java.nio.file.Files","dimension":"","elementType":{},"package":"java.nio.file","superclass":"java.lang.Object","interfaces":[],"isAbstract":false,"isStatic":false,"since":"1.7","innerClasses":[],"isInnerClass":false,"constructors":[],"fields":[],"methods":[{"name":"newInputStream","comment":"Opens a file, returning an input stream to read from the file. The stream\n will not be buffered, and is not required to support the {@link\n InputStream#mark mark} or {@link InputStream#reset reset} methods. The\n stream will be safe for access by multiple concurrent threads. Reading\n commences at the beginning of the file. Whether the returned stream is\n \u003ci\u003easynchronously closeable\u003c/i\u003e and/or \u003ci\u003einterruptible\u003c/i\u003e is highly\n file system provider specific and therefore not specified.\n\n \u003cp\u003e The {@code options} parameter determines how the file is opened.\n If no options are present then it is equivalent to opening the file with\n the {@link StandardOpenOption#READ READ} option. In addition to the {@code\n READ} option, an implementation may also support additional implementation\n specific options.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.nio.file.Path, java.nio.file.OpenOption...)","flatSignature":"(Path, OpenOption...)","returnType":{"isPrimitive":false,"simpleName":"InputStream","qualifiedName":"java.io.InputStream","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"path","type":{"isPrimitive":false,"simpleName":"Path","qualifiedName":"java.nio.file.Path","dimension":"","elementType":{}}},{"name":"options","type":{"isPrimitive":false,"simpleName":"OpenOption","qualifiedName":"java.nio.file.OpenOption","dimension":"[]","elementType":{"isPrimitive":false,"simpleName":"OpenOption","qualifiedName":"java.nio.file.OpenOption","dimension":"","elementType":{}}}}],"typeParameters":[]},{"name":"newOutputStream","comment":"Opens or creates a file, returning an output stream that may be used to\n write bytes to the file. The resulting stream will not be buffered. The\n stream will be safe for access by multiple concurrent threads. Whether\n the returned stream is \u003ci\u003easynchronously closeable\u003c/i\u003e and/or\n \u003ci\u003einterruptible\u003c/i\u003e is highly file system provider specific and\n therefore not specified.\n\n \u003cp\u003e This method opens or creates a file in exactly the manner specified\n by the {@link #newByteChannel(Path,Set,FileAttribute[]) newByteChannel}\n method with the exception that the {@link StandardOpenOption#READ READ}\n option may not be present in the array of options. If no options are\n present then this method works as if the {@link StandardOpenOption#CREATE\n CREATE}, {@link StandardOpenOption#TRUNCATE_EXISTING TRUNCATE_EXISTING},\n and {@link StandardOpenOption#WRITE WRITE} options are present. In other\n words, it opens the file for writing, creating the file if it doesn\u0027t\n exist, or initially truncating an existing {@link #isRegularFile\n regular-file} to a size of {@code 0} if it exists.\n\n \u003cp\u003e \u003cb\u003eUsage Examples:\u003c/b\u003e\n \u003cpre\u003e\n     Path path \u003d ...\n\n     // truncate and overwrite an existing file, or create the file if\n     // it doesn\u0027t initially exist\n     OutputStream out \u003d Files.newOutputStream(path);\n\n     // append to an existing file, fail if the file does not exist\n     out \u003d Files.newOutputStream(path, APPEND);\n\n     // append to an existing file, create file if it doesn\u0027t initially exist\n     out \u003d Files.newOutputStream(path, CREATE, APPEND);\n\n     // always create new file, failing if it already exists\n     out \u003d Files.newOutputStream(path, CREATE_NEW);\n \u003c/pre\u003e","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.nio.file.Path, java.nio.file.OpenOption...)","flatSignature":"(Path, OpenOption...)","returnType":{"isPrimitive":false,"simpleName":"OutputStream","qualifiedName":"java.io.OutputStream","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"path","type":{"isPrimitive":false,"simpleName":"Path","qualifiedName":"java.nio.file.Path","dimension":"","elementType":{}}},{"name":"options","type":{"isPrimitive":false,"simpleName":"OpenOption","qualifiedName":"java.nio.file.OpenOption","dimension":"[]","elementType":{"isPrimitive":false,"simpleName":"OpenOption","qualifiedName":"java.nio.file.OpenOption","dimension":"","elementType":{}}}}],"typeParameters":[]},{"name":"newByteChannel","comment":"Opens or creates a file, returning a seekable byte channel to access the\n file.\n\n \u003cp\u003e The {@code options} parameter determines how the file is opened.\n The {@link StandardOpenOption#READ READ} and {@link\n StandardOpenOption#WRITE WRITE} options determine if the file should be\n opened for reading and/or writing. If neither option (or the {@link\n StandardOpenOption#APPEND APPEND} option) is present then the file is\n opened for reading. By default reading or writing commence at the\n beginning of the file.\n\n \u003cp\u003e In the addition to {@code READ} and {@code WRITE}, the following\n options may be present:\n\n \u003ctable border\u003d1 cellpadding\u003d5 summary\u003d\"Options\"\u003e\n \u003ctr\u003e \u003cth\u003eOption\u003c/th\u003e \u003cth\u003eDescription\u003c/th\u003e \u003c/tr\u003e\n \u003ctr\u003e\n   \u003ctd\u003e {@link StandardOpenOption#APPEND APPEND} \u003c/td\u003e\n   \u003ctd\u003e If this option is present then the file is opened for writing and\n     each invocation of the channel\u0027s {@code write} method first advances\n     the position to the end of the file and then writes the requested\n     data. Whether the advancement of the position and the writing of the\n     data are done in a single atomic operation is system-dependent and\n     therefore unspecified. This option may not be used in conjunction\n     with the {@code READ} or {@code TRUNCATE_EXISTING} options. \u003c/td\u003e\n \u003c/tr\u003e\n \u003ctr\u003e\n   \u003ctd\u003e {@link StandardOpenOption#TRUNCATE_EXISTING TRUNCATE_EXISTING} \u003c/td\u003e\n   \u003ctd\u003e If this option is present then the existing file is truncated to\n   a size of 0 bytes. This option is ignored when the file is opened only\n   for reading. \u003c/td\u003e\n \u003c/tr\u003e\n \u003ctr\u003e\n   \u003ctd\u003e {@link StandardOpenOption#CREATE_NEW CREATE_NEW} \u003c/td\u003e\n   \u003ctd\u003e If this option is present then a new file is created, failing if\n   the file already exists or is a symbolic link. When creating a file the\n   check for the existence of the file and the creation of the file if it\n   does not exist is atomic with respect to other file system operations.\n   This option is ignored when the file is opened only for reading. \u003c/td\u003e\n \u003c/tr\u003e\n \u003ctr\u003e\n   \u003ctd \u003e {@link StandardOpenOption#CREATE CREATE} \u003c/td\u003e\n   \u003ctd\u003e If this option is present then an existing file is opened if it\n   exists, otherwise a new file is created. This option is ignored if the\n   {@code CREATE_NEW} option is also present or the file is opened only\n   for reading. \u003c/td\u003e\n \u003c/tr\u003e\n \u003ctr\u003e\n   \u003ctd \u003e {@link StandardOpenOption#DELETE_ON_CLOSE DELETE_ON_CLOSE} \u003c/td\u003e\n   \u003ctd\u003e When this option is present then the implementation makes a\n   \u003cem\u003ebest effort\u003c/em\u003e attempt to delete the file when closed by the\n   {@link SeekableByteChannel#close close} method. If the {@code close}\n   method is not invoked then a \u003cem\u003ebest effort\u003c/em\u003e attempt is made to\n   delete the file when the Java virtual machine terminates. \u003c/td\u003e\n \u003c/tr\u003e\n \u003ctr\u003e\n   \u003ctd\u003e{@link StandardOpenOption#SPARSE SPARSE} \u003c/td\u003e\n   \u003ctd\u003e When creating a new file this option is a \u003cem\u003ehint\u003c/em\u003e that the\n   new file will be sparse. This option is ignored when not creating\n   a new file. \u003c/td\u003e\n \u003c/tr\u003e\n \u003ctr\u003e\n   \u003ctd\u003e {@link StandardOpenOption#SYNC SYNC} \u003c/td\u003e\n   \u003ctd\u003e Requires that every update to the file\u0027s content or metadata be\n   written synchronously to the underlying storage device. (see \u003ca\n   href\u003d\"package-summary.html#integrity\"\u003e Synchronized I/O file\n   integrity\u003c/a\u003e). \u003c/td\u003e\n \u003c/tr\u003e\n \u003ctr\u003e\n   \u003ctd\u003e {@link StandardOpenOption#DSYNC DSYNC} \u003c/td\u003e\n   \u003ctd\u003e Requires that every update to the file\u0027s content be written\n   synchronously to the underlying storage device. (see \u003ca\n   href\u003d\"package-summary.html#integrity\"\u003e Synchronized I/O file\n   integrity\u003c/a\u003e). \u003c/td\u003e\n \u003c/tr\u003e\n \u003c/table\u003e\n\n \u003cp\u003e An implementation may also support additional implementation specific\n options.\n\n \u003cp\u003e The {@code attrs} parameter is optional {@link FileAttribute\n file-attributes} to set atomically when a new file is created.\n\n \u003cp\u003e In the case of the default provider, the returned seekable byte channel\n is a {@link java.nio.channels.FileChannel}.\n\n \u003cp\u003e \u003cb\u003eUsage Examples:\u003c/b\u003e\n \u003cpre\u003e\n     Path path \u003d ...\n\n     // open file for reading\n     ReadableByteChannel rbc \u003d Files.newByteChannel(path, EnumSet.of(READ)));\n\n     // open file for writing to the end of an existing file, creating\n     // the file if it doesn\u0027t already exist\n     WritableByteChannel wbc \u003d Files.newByteChannel(path, EnumSet.of(CREATE,APPEND));\n\n     // create file with initial permissions, opening it for both reading and writing\n     {@code FileAttribute\u003cSet\u003cPosixFilePermission\u003e\u003e perms \u003d ...}\n     SeekableByteChannel sbc \u003d Files.newByteChannel(path, EnumSet.of(CREATE_NEW,READ,WRITE), perms);\n \u003c/pre\u003e","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.nio.file.Path, java.util.Set\u003c? extends java.nio.file.OpenOption\u003e, java.nio.file.attribute.FileAttribute\u003c?\u003e...)","flatSignature":"(Path, Set\u003c? extends OpenOption\u003e, FileAttribute\u003c?\u003e...)","returnType":{"isPrimitive":false,"simpleName":"SeekableByteChannel","qualifiedName":"java.nio.channels.SeekableByteChannel","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"path","type":{"isPrimitive":false,"simpleName":"Path","qualifiedName":"java.nio.file.Path","dimension":"","elementType":{}}},{"name":"options","type":{"isPrimitive":false,"simpleName":"Set","qualifiedName":"java.util.Set","dimension":"","elementType":{}}},{"name":"attrs","type":{"isPrimitive":false,"simpleName":"FileAttribute","qualifiedName":"java.nio.file.attribute.FileAttribute","dimension":"[]","elementType":{"isPrimitive":false,"simpleName":"FileAttribute","qualifiedName":"java.nio.file.attribute.FileAttribute","dimension":"","elementType":{}}}}],"typeParameters":[]},{"name":"newByteChannel","comment":"Opens or creates a file, returning a seekable byte channel to access the\n file.\n\n \u003cp\u003e This method opens or creates a file in exactly the manner specified\n by the {@link #newByteChannel(Path,Set,FileAttribute[]) newByteChannel}\n method.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.nio.file.Path, java.nio.file.OpenOption...)","flatSignature":"(Path, OpenOption...)","returnType":{"isPrimitive":false,"simpleName":"SeekableByteChannel","qualifiedName":"java.nio.channels.SeekableByteChannel","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"path","type":{"isPrimitive":false,"simpleName":"Path","qualifiedName":"java.nio.file.Path","dimension":"","elementType":{}}},{"name":"options","type":{"isPrimitive":false,"simpleName":"OpenOption","qualifiedName":"java.nio.file.OpenOption","dimension":"[]","elementType":{"isPrimitive":false,"simpleName":"OpenOption","qualifiedName":"java.nio.file.OpenOption","dimension":"","elementType":{}}}}],"typeParameters":[]},{"name":"newDirectoryStream","comment":"Opens a directory, returning a {@link DirectoryStream} to iterate over\n all entries in the directory. The elements returned by the directory\n stream\u0027s {@link DirectoryStream#iterator iterator} are of type {@code\n Path}, each one representing an entry in the directory. The {@code Path}\n objects are obtained as if by {@link Path#resolve(Path) resolving} the\n name of the directory entry against {@code dir}.\n\n \u003cp\u003e When not using the try-with-resources construct, then directory\n stream\u0027s {@code close} method should be invoked after iteration is\n completed so as to free any resources held for the open directory.\n\n \u003cp\u003e When an implementation supports operations on entries in the\n directory that execute in a race-free manner then the returned directory\n stream is a {@link SecureDirectoryStream}.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.nio.file.Path)","flatSignature":"(Path)","returnType":{"isPrimitive":false,"simpleName":"DirectoryStream","qualifiedName":"java.nio.file.DirectoryStream","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"dir","type":{"isPrimitive":false,"simpleName":"Path","qualifiedName":"java.nio.file.Path","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"newDirectoryStream","comment":"Opens a directory, returning a {@link DirectoryStream} to iterate over\n the entries in the directory. The elements returned by the directory\n stream\u0027s {@link DirectoryStream#iterator iterator} are of type {@code\n Path}, each one representing an entry in the directory. The {@code Path}\n objects are obtained as if by {@link Path#resolve(Path) resolving} the\n name of the directory entry against {@code dir}. The entries returned by\n the iterator are filtered by matching the {@code String} representation\n of their file names against the given \u003cem\u003eglobbing\u003c/em\u003e pattern.\n\n \u003cp\u003e For example, suppose we want to iterate over the files ending with\n \".java\" in a directory:\n \u003cpre\u003e\n     Path dir \u003d ...\n     try (DirectoryStream\u0026lt;Path\u0026gt; stream \u003d Files.newDirectoryStream(dir, \"*.java\")) {\n         :\n     }\n \u003c/pre\u003e\n\n \u003cp\u003e The globbing pattern is specified by the {@link\n FileSystem#getPathMatcher getPathMatcher} method.\n\n \u003cp\u003e When not using the try-with-resources construct, then directory\n stream\u0027s {@code close} method should be invoked after iteration is\n completed so as to free any resources held for the open directory.\n\n \u003cp\u003e When an implementation supports operations on entries in the\n directory that execute in a race-free manner then the returned directory\n stream is a {@link SecureDirectoryStream}.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.nio.file.Path, java.lang.String)","flatSignature":"(Path, String)","returnType":{"isPrimitive":false,"simpleName":"DirectoryStream","qualifiedName":"java.nio.file.DirectoryStream","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"dir","type":{"isPrimitive":false,"simpleName":"Path","qualifiedName":"java.nio.file.Path","dimension":"","elementType":{}}},{"name":"glob","type":{"isPrimitive":false,"simpleName":"String","qualifiedName":"java.lang.String","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"newDirectoryStream","comment":"Opens a directory, returning a {@link DirectoryStream} to iterate over\n the entries in the directory. The elements returned by the directory\n stream\u0027s {@link DirectoryStream#iterator iterator} are of type {@code\n Path}, each one representing an entry in the directory. The {@code Path}\n objects are obtained as if by {@link Path#resolve(Path) resolving} the\n name of the directory entry against {@code dir}. The entries returned by\n the iterator are filtered by the given {@link DirectoryStream.Filter\n filter}.\n\n \u003cp\u003e When not using the try-with-resources construct, then directory\n stream\u0027s {@code close} method should be invoked after iteration is\n completed so as to free any resources held for the open directory.\n\n \u003cp\u003e Where the filter terminates due to an uncaught error or runtime\n exception then it is propagated to the {@link Iterator#hasNext()\n hasNext} or {@link Iterator#next() next} method. Where an {@code\n IOException} is thrown, it results in the {@code hasNext} or {@code\n next} method throwing a {@link DirectoryIteratorException} with the\n {@code IOException} as the cause.\n\n \u003cp\u003e When an implementation supports operations on entries in the\n directory that execute in a race-free manner then the returned directory\n stream is a {@link SecureDirectoryStream}.\n\n \u003cp\u003e \u003cb\u003eUsage Example:\u003c/b\u003e\n Suppose we want to iterate over the files in a directory that are\n larger than 8K.\n \u003cpre\u003e\n     DirectoryStream.Filter\u0026lt;Path\u0026gt; filter \u003d new DirectoryStream.Filter\u0026lt;Path\u0026gt;() {\n         public boolean accept(Path file) throws IOException {\n             return (Files.size(file) \u0026gt; 8192L);\n         }\n     };\n     Path dir \u003d ...\n     try (DirectoryStream\u0026lt;Path\u0026gt; stream \u003d Files.newDirectoryStream(dir, filter)) {\n         :\n     }\n \u003c/pre\u003e","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.nio.file.Path, java.nio.file.DirectoryStream.Filter\u003c? super java.nio.file.Path\u003e)","flatSignature":"(Path, DirectoryStream.Filter\u003c? super Path\u003e)","returnType":{"isPrimitive":false,"simpleName":"DirectoryStream","qualifiedName":"java.nio.file.DirectoryStream","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"dir","type":{"isPrimitive":false,"simpleName":"Path","qualifiedName":"java.nio.file.Path","dimension":"","elementType":{}}},{"name":"filter","type":{"isPrimitive":false,"simpleName":"Filter","qualifiedName":"java.nio.file.DirectoryStream.Filter","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"createFile","comment":"Creates a new and empty file, failing if the file already exists. The\n check for the existence of the file and the creation of the new file if\n it does not exist are a single operation that is atomic with respect to\n all other filesystem activities that might affect the directory.\n\n \u003cp\u003e The {@code attrs} parameter is optional {@link FileAttribute\n file-attributes} to set atomically when creating the file. Each attribute\n is identified by its {@link FileAttribute#name name}. If more than one\n attribute of the same name is included in the array then all but the last\n occurrence is ignored.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.nio.file.Path, java.nio.file.attribute.FileAttribute\u003c?\u003e...)","flatSignature":"(Path, FileAttribute\u003c?\u003e...)","returnType":{"isPrimitive":false,"simpleName":"Path","qualifiedName":"java.nio.file.Path","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"path","type":{"isPrimitive":false,"simpleName":"Path","qualifiedName":"java.nio.file.Path","dimension":"","elementType":{}}},{"name":"attrs","type":{"isPrimitive":false,"simpleName":"FileAttribute","qualifiedName":"java.nio.file.attribute.FileAttribute","dimension":"[]","elementType":{"isPrimitive":false,"simpleName":"FileAttribute","qualifiedName":"java.nio.file.attribute.FileAttribute","dimension":"","elementType":{}}}}],"typeParameters":[]},{"name":"createDirectory","comment":"Creates a new directory. The check for the existence of the file and the\n creation of the directory if it does not exist are a single operation\n that is atomic with respect to all other filesystem activities that might\n affect the directory. The {@link #createDirectories createDirectories}\n method should be used where it is required to create all nonexistent\n parent directories first.\n\n \u003cp\u003e The {@code attrs} parameter is optional {@link FileAttribute\n file-attributes} to set atomically when creating the directory. Each\n attribute is identified by its {@link FileAttribute#name name}. If more\n than one attribute of the same name is included in the array then all but\n the last occurrence is ignored.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.nio.file.Path, java.nio.file.attribute.FileAttribute\u003c?\u003e...)","flatSignature":"(Path, FileAttribute\u003c?\u003e...)","returnType":{"isPrimitive":false,"simpleName":"Path","qualifiedName":"java.nio.file.Path","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"dir","type":{"isPrimitive":false,"simpleName":"Path","qualifiedName":"java.nio.file.Path","dimension":"","elementType":{}}},{"name":"attrs","type":{"isPrimitive":false,"simpleName":"FileAttribute","qualifiedName":"java.nio.file.attribute.FileAttribute","dimension":"[]","elementType":{"isPrimitive":false,"simpleName":"FileAttribute","qualifiedName":"java.nio.file.attribute.FileAttribute","dimension":"","elementType":{}}}}],"typeParameters":[]},{"name":"createDirectories","comment":"Creates a directory by creating all nonexistent parent directories first.\n Unlike the {@link #createDirectory createDirectory} method, an exception\n is not thrown if the directory could not be created because it already\n exists.\n\n \u003cp\u003e The {@code attrs} parameter is optional {@link FileAttribute\n file-attributes} to set atomically when creating the nonexistent\n directories. Each file attribute is identified by its {@link\n FileAttribute#name name}. If more than one attribute of the same name is\n included in the array then all but the last occurrence is ignored.\n\n \u003cp\u003e If this method fails, then it may do so after creating some, but not\n all, of the parent directories.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.nio.file.Path, java.nio.file.attribute.FileAttribute\u003c?\u003e...)","flatSignature":"(Path, FileAttribute\u003c?\u003e...)","returnType":{"isPrimitive":false,"simpleName":"Path","qualifiedName":"java.nio.file.Path","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"dir","type":{"isPrimitive":false,"simpleName":"Path","qualifiedName":"java.nio.file.Path","dimension":"","elementType":{}}},{"name":"attrs","type":{"isPrimitive":false,"simpleName":"FileAttribute","qualifiedName":"java.nio.file.attribute.FileAttribute","dimension":"[]","elementType":{"isPrimitive":false,"simpleName":"FileAttribute","qualifiedName":"java.nio.file.attribute.FileAttribute","dimension":"","elementType":{}}}}],"typeParameters":[]},{"name":"createTempFile","comment":"Creates a new empty file in the specified directory, using the given\n prefix and suffix strings to generate its name. The resulting\n {@code Path} is associated with the same {@code FileSystem} as the given\n directory.\n\n \u003cp\u003e The details as to how the name of the file is constructed is\n implementation dependent and therefore not specified. Where possible\n the {@code prefix} and {@code suffix} are used to construct candidate\n names in the same manner as the {@link\n java.io.File#createTempFile(String,String,File)} method.\n\n \u003cp\u003e As with the {@code File.createTempFile} methods, this method is only\n part of a temporary-file facility. Where used as a \u003cem\u003ework files\u003c/em\u003e,\n the resulting file may be opened using the {@link\n StandardOpenOption#DELETE_ON_CLOSE DELETE_ON_CLOSE} option so that the\n file is deleted when the appropriate {@code close} method is invoked.\n Alternatively, a {@link Runtime#addShutdownHook shutdown-hook}, or the\n {@link java.io.File#deleteOnExit} mechanism may be used to delete the\n file automatically.\n\n \u003cp\u003e The {@code attrs} parameter is optional {@link FileAttribute\n file-attributes} to set atomically when creating the file. Each attribute\n is identified by its {@link FileAttribute#name name}. If more than one\n attribute of the same name is included in the array then all but the last\n occurrence is ignored. When no file attributes are specified, then the\n resulting file may have more restrictive access permissions to files\n created by the {@link java.io.File#createTempFile(String,String,File)}\n method.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.nio.file.Path, java.lang.String, java.lang.String, java.nio.file.attribute.FileAttribute\u003c?\u003e...)","flatSignature":"(Path, String, String, FileAttribute\u003c?\u003e...)","returnType":{"isPrimitive":false,"simpleName":"Path","qualifiedName":"java.nio.file.Path","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"dir","type":{"isPrimitive":false,"simpleName":"Path","qualifiedName":"java.nio.file.Path","dimension":"","elementType":{}}},{"name":"prefix","type":{"isPrimitive":false,"simpleName":"String","qualifiedName":"java.lang.String","dimension":"","elementType":{}}},{"name":"suffix","type":{"isPrimitive":false,"simpleName":"String","qualifiedName":"java.lang.String","dimension":"","elementType":{}}},{"name":"attrs","type":{"isPrimitive":false,"simpleName":"FileAttribute","qualifiedName":"java.nio.file.attribute.FileAttribute","dimension":"[]","elementType":{"isPrimitive":false,"simpleName":"FileAttribute","qualifiedName":"java.nio.file.attribute.FileAttribute","dimension":"","elementType":{}}}}],"typeParameters":[]},{"name":"createTempFile","comment":"Creates an empty file in the default temporary-file directory, using\n the given prefix and suffix to generate its name. The resulting {@code\n Path} is associated with the default {@code FileSystem}.\n\n \u003cp\u003e This method works in exactly the manner specified by the\n {@link #createTempFile(Path,String,String,FileAttribute[])} method for\n the case that the {@code dir} parameter is the temporary-file directory.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.lang.String, java.lang.String, java.nio.file.attribute.FileAttribute\u003c?\u003e...)","flatSignature":"(String, String, FileAttribute\u003c?\u003e...)","returnType":{"isPrimitive":false,"simpleName":"Path","qualifiedName":"java.nio.file.Path","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"prefix","type":{"isPrimitive":false,"simpleName":"String","qualifiedName":"java.lang.String","dimension":"","elementType":{}}},{"name":"suffix","type":{"isPrimitive":false,"simpleName":"String","qualifiedName":"java.lang.String","dimension":"","elementType":{}}},{"name":"attrs","type":{"isPrimitive":false,"simpleName":"FileAttribute","qualifiedName":"java.nio.file.attribute.FileAttribute","dimension":"[]","elementType":{"isPrimitive":false,"simpleName":"FileAttribute","qualifiedName":"java.nio.file.attribute.FileAttribute","dimension":"","elementType":{}}}}],"typeParameters":[]},{"name":"createTempDirectory","comment":"Creates a new directory in the specified directory, using the given\n prefix to generate its name.  The resulting {@code Path} is associated\n with the same {@code FileSystem} as the given directory.\n\n \u003cp\u003e The details as to how the name of the directory is constructed is\n implementation dependent and therefore not specified. Where possible\n the {@code prefix} is used to construct candidate names.\n\n \u003cp\u003e As with the {@code createTempFile} methods, this method is only\n part of a temporary-file facility. A {@link Runtime#addShutdownHook\n shutdown-hook}, or the {@link java.io.File#deleteOnExit} mechanism may be\n used to delete the directory automatically.\n\n \u003cp\u003e The {@code attrs} parameter is optional {@link FileAttribute\n file-attributes} to set atomically when creating the directory. Each\n attribute is identified by its {@link FileAttribute#name name}. If more\n than one attribute of the same name is included in the array then all but\n the last occurrence is ignored.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.nio.file.Path, java.lang.String, java.nio.file.attribute.FileAttribute\u003c?\u003e...)","flatSignature":"(Path, String, FileAttribute\u003c?\u003e...)","returnType":{"isPrimitive":false,"simpleName":"Path","qualifiedName":"java.nio.file.Path","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"dir","type":{"isPrimitive":false,"simpleName":"Path","qualifiedName":"java.nio.file.Path","dimension":"","elementType":{}}},{"name":"prefix","type":{"isPrimitive":false,"simpleName":"String","qualifiedName":"java.lang.String","dimension":"","elementType":{}}},{"name":"attrs","type":{"isPrimitive":false,"simpleName":"FileAttribute","qualifiedName":"java.nio.file.attribute.FileAttribute","dimension":"[]","elementType":{"isPrimitive":false,"simpleName":"FileAttribute","qualifiedName":"java.nio.file.attribute.FileAttribute","dimension":"","elementType":{}}}}],"typeParameters":[]},{"name":"createTempDirectory","comment":"Creates a new directory in the default temporary-file directory, using\n the given prefix to generate its name. The resulting {@code Path} is\n associated with the default {@code FileSystem}.\n\n \u003cp\u003e This method works in exactly the manner specified by {@link\n #createTempDirectory(Path,String,FileAttribute[])} method for the case\n that the {@code dir} parameter is the temporary-file directory.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.lang.String, java.nio.file.attribute.FileAttribute\u003c?\u003e...)","flatSignature":"(String, FileAttribute\u003c?\u003e...)","returnType":{"isPrimitive":false,"simpleName":"Path","qualifiedName":"java.nio.file.Path","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"prefix","type":{"isPrimitive":false,"simpleName":"String","qualifiedName":"java.lang.String","dimension":"","elementType":{}}},{"name":"attrs","type":{"isPrimitive":false,"simpleName":"FileAttribute","qualifiedName":"java.nio.file.attribute.FileAttribute","dimension":"[]","elementType":{"isPrimitive":false,"simpleName":"FileAttribute","qualifiedName":"java.nio.file.attribute.FileAttribute","dimension":"","elementType":{}}}}],"typeParameters":[]},{"name":"createSymbolicLink","comment":"Creates a symbolic link to a target \u003ci\u003e(optional operation)\u003c/i\u003e.\n\n \u003cp\u003e The {@code target} parameter is the target of the link. It may be an\n {@link Path#isAbsolute absolute} or relative path and may not exist. When\n the target is a relative path then file system operations on the resulting\n link are relative to the path of the link.\n\n \u003cp\u003e The {@code attrs} parameter is optional {@link FileAttribute\n attributes} to set atomically when creating the link. Each attribute is\n identified by its {@link FileAttribute#name name}. If more than one attribute\n of the same name is included in the array then all but the last occurrence\n is ignored.\n\n \u003cp\u003e Where symbolic links are supported, but the underlying {@link FileStore}\n does not support symbolic links, then this may fail with an {@link\n IOException}. Additionally, some operating systems may require that the\n Java virtual machine be started with implementation specific privileges to\n create symbolic links, in which case this method may throw {@code IOException}.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.nio.file.Path, java.nio.file.Path, java.nio.file.attribute.FileAttribute\u003c?\u003e...)","flatSignature":"(Path, Path, FileAttribute\u003c?\u003e...)","returnType":{"isPrimitive":false,"simpleName":"Path","qualifiedName":"java.nio.file.Path","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"link","type":{"isPrimitive":false,"simpleName":"Path","qualifiedName":"java.nio.file.Path","dimension":"","elementType":{}}},{"name":"target","type":{"isPrimitive":false,"simpleName":"Path","qualifiedName":"java.nio.file.Path","dimension":"","elementType":{}}},{"name":"attrs","type":{"isPrimitive":false,"simpleName":"FileAttribute","qualifiedName":"java.nio.file.attribute.FileAttribute","dimension":"[]","elementType":{"isPrimitive":false,"simpleName":"FileAttribute","qualifiedName":"java.nio.file.attribute.FileAttribute","dimension":"","elementType":{}}}}],"typeParameters":[]},{"name":"createLink","comment":"Creates a new link (directory entry) for an existing file \u003ci\u003e(optional\n operation)\u003c/i\u003e.\n\n \u003cp\u003e The {@code link} parameter locates the directory entry to create.\n The {@code existing} parameter is the path to an existing file. This\n method creates a new directory entry for the file so that it can be\n accessed using {@code link} as the path. On some file systems this is\n known as creating a \"hard link\". Whether the file attributes are\n maintained for the file or for each directory entry is file system\n specific and therefore not specified. Typically, a file system requires\n that all links (directory entries) for a file be on the same file system.\n Furthermore, on some platforms, the Java virtual machine may require to\n be started with implementation specific privileges to create hard links\n or to create links to directories.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.nio.file.Path, java.nio.file.Path)","flatSignature":"(Path, Path)","returnType":{"isPrimitive":false,"simpleName":"Path","qualifiedName":"java.nio.file.Path","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"link","type":{"isPrimitive":false,"simpleName":"Path","qualifiedName":"java.nio.file.Path","dimension":"","elementType":{}}},{"name":"existing","type":{"isPrimitive":false,"simpleName":"Path","qualifiedName":"java.nio.file.Path","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"delete","comment":"Deletes a file.\n\n \u003cp\u003e An implementation may require to examine the file to determine if the\n file is a directory. Consequently this method may not be atomic with respect\n to other file system operations.  If the file is a symbolic link then the\n symbolic link itself, not the final target of the link, is deleted.\n\n \u003cp\u003e If the file is a directory then the directory must be empty. In some\n implementations a directory has entries for special files or links that\n are created when the directory is created. In such implementations a\n directory is considered empty when only the special entries exist.\n This method can be used with the {@link #walkFileTree walkFileTree}\n method to delete a directory and all entries in the directory, or an\n entire \u003ci\u003efile-tree\u003c/i\u003e where required.\n\n \u003cp\u003e On some operating systems it may not be possible to remove a file when\n it is open and in use by this Java virtual machine or other programs.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.nio.file.Path)","flatSignature":"(Path)","returnType":{"isPrimitive":true,"simpleName":"void","qualifiedName":"void","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"path","type":{"isPrimitive":false,"simpleName":"Path","qualifiedName":"java.nio.file.Path","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"deleteIfExists","comment":"Deletes a file if it exists.\n\n \u003cp\u003e As with the {@link #delete(Path) delete(Path)} method, an\n implementation may need to examine the file to determine if the file is a\n directory. Consequently this method may not be atomic with respect to\n other file system operations.  If the file is a symbolic link, then the\n symbolic link itself, not the final target of the link, is deleted.\n\n \u003cp\u003e If the file is a directory then the directory must be empty. In some\n implementations a directory has entries for special files or links that\n are created when the directory is created. In such implementations a\n directory is considered empty when only the special entries exist.\n\n \u003cp\u003e On some operating systems it may not be possible to remove a file when\n it is open and in use by this Java virtual machine or other programs.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.nio.file.Path)","flatSignature":"(Path)","returnType":{"isPrimitive":true,"simpleName":"boolean","qualifiedName":"boolean","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"path","type":{"isPrimitive":false,"simpleName":"Path","qualifiedName":"java.nio.file.Path","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"copy","comment":"Copy a file to a target file.\n\n \u003cp\u003e This method copies a file to the target file with the {@code\n options} parameter specifying how the copy is performed. By default, the\n copy fails if the target file already exists or is a symbolic link,\n except if the source and target are the {@link #isSameFile same} file, in\n which case the method completes without copying the file. File attributes\n are not required to be copied to the target file. If symbolic links are\n supported, and the file is a symbolic link, then the final target of the\n link is copied. If the file is a directory then it creates an empty\n directory in the target location (entries in the directory are not\n copied). This method can be used with the {@link #walkFileTree\n walkFileTree} method to copy a directory and all entries in the directory,\n or an entire \u003ci\u003efile-tree\u003c/i\u003e where required.\n\n \u003cp\u003e The {@code options} parameter may include any of the following:\n\n \u003ctable border\u003d1 cellpadding\u003d5 summary\u003d\"\"\u003e\n \u003ctr\u003e \u003cth\u003eOption\u003c/th\u003e \u003cth\u003eDescription\u003c/th\u003e \u003c/tr\u003e\n \u003ctr\u003e\n   \u003ctd\u003e {@link StandardCopyOption#REPLACE_EXISTING REPLACE_EXISTING} \u003c/td\u003e\n   \u003ctd\u003e If the target file exists, then the target file is replaced if it\n     is not a non-empty directory. If the target file exists and is a\n     symbolic link, then the symbolic link itself, not the target of\n     the link, is replaced. \u003c/td\u003e\n \u003c/tr\u003e\n \u003ctr\u003e\n   \u003ctd\u003e {@link StandardCopyOption#COPY_ATTRIBUTES COPY_ATTRIBUTES} \u003c/td\u003e\n   \u003ctd\u003e Attempts to copy the file attributes associated with this file to\n     the target file. The exact file attributes that are copied is platform\n     and file system dependent and therefore unspecified. Minimally, the\n     {@link BasicFileAttributes#lastModifiedTime last-modified-time} is\n     copied to the target file if supported by both the source and target\n     file stores. Copying of file timestamps may result in precision\n     loss. \u003c/td\u003e\n \u003c/tr\u003e\n \u003ctr\u003e\n   \u003ctd\u003e {@link LinkOption#NOFOLLOW_LINKS NOFOLLOW_LINKS} \u003c/td\u003e\n   \u003ctd\u003e Symbolic links are not followed. If the file is a symbolic link,\n     then the symbolic link itself, not the target of the link, is copied.\n     It is implementation specific if file attributes can be copied to the\n     new link. In other words, the {@code COPY_ATTRIBUTES} option may be\n     ignored when copying a symbolic link. \u003c/td\u003e\n \u003c/tr\u003e\n \u003c/table\u003e\n\n \u003cp\u003e An implementation of this interface may support additional\n implementation specific options.\n\n \u003cp\u003e Copying a file is not an atomic operation. If an {@link IOException}\n is thrown, then it is possible that the target file is incomplete or some\n of its file attributes have not been copied from the source file. When\n the {@code REPLACE_EXISTING} option is specified and the target file\n exists, then the target file is replaced. The check for the existence of\n the file and the creation of the new file may not be atomic with respect\n to other file system activities.\n\n \u003cp\u003e \u003cb\u003eUsage Example:\u003c/b\u003e\n Suppose we want to copy a file into a directory, giving it the same file\n name as the source file:\n \u003cpre\u003e\n     Path source \u003d ...\n     Path newdir \u003d ...\n     Files.copy(source, newdir.resolve(source.getFileName());\n \u003c/pre\u003e","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.nio.file.Path, java.nio.file.Path, java.nio.file.CopyOption...)","flatSignature":"(Path, Path, CopyOption...)","returnType":{"isPrimitive":false,"simpleName":"Path","qualifiedName":"java.nio.file.Path","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"source","type":{"isPrimitive":false,"simpleName":"Path","qualifiedName":"java.nio.file.Path","dimension":"","elementType":{}}},{"name":"target","type":{"isPrimitive":false,"simpleName":"Path","qualifiedName":"java.nio.file.Path","dimension":"","elementType":{}}},{"name":"options","type":{"isPrimitive":false,"simpleName":"CopyOption","qualifiedName":"java.nio.file.CopyOption","dimension":"[]","elementType":{"isPrimitive":false,"simpleName":"CopyOption","qualifiedName":"java.nio.file.CopyOption","dimension":"","elementType":{}}}}],"typeParameters":[]},{"name":"move","comment":"Move or rename a file to a target file.\n\n \u003cp\u003e By default, this method attempts to move the file to the target\n file, failing if the target file exists except if the source and\n target are the {@link #isSameFile same} file, in which case this method\n has no effect. If the file is a symbolic link then the symbolic link\n itself, not the target of the link, is moved. This method may be\n invoked to move an empty directory. In some implementations a directory\n has entries for special files or links that are created when the\n directory is created. In such implementations a directory is considered\n empty when only the special entries exist. When invoked to move a\n directory that is not empty then the directory is moved if it does not\n require moving the entries in the directory.  For example, renaming a\n directory on the same {@link FileStore} will usually not require moving\n the entries in the directory. When moving a directory requires that its\n entries be moved then this method fails (by throwing an {@code\n IOException}). To move a \u003ci\u003efile tree\u003c/i\u003e may involve copying rather\n than moving directories and this can be done using the {@link\n #copy copy} method in conjunction with the {@link\n #walkFileTree Files.walkFileTree} utility method.\n\n \u003cp\u003e The {@code options} parameter may include any of the following:\n\n \u003ctable border\u003d1 cellpadding\u003d5 summary\u003d\"\"\u003e\n \u003ctr\u003e \u003cth\u003eOption\u003c/th\u003e \u003cth\u003eDescription\u003c/th\u003e \u003c/tr\u003e\n \u003ctr\u003e\n   \u003ctd\u003e {@link StandardCopyOption#REPLACE_EXISTING REPLACE_EXISTING} \u003c/td\u003e\n   \u003ctd\u003e If the target file exists, then the target file is replaced if it\n     is not a non-empty directory. If the target file exists and is a\n     symbolic link, then the symbolic link itself, not the target of\n     the link, is replaced. \u003c/td\u003e\n \u003c/tr\u003e\n \u003ctr\u003e\n   \u003ctd\u003e {@link StandardCopyOption#ATOMIC_MOVE ATOMIC_MOVE} \u003c/td\u003e\n   \u003ctd\u003e The move is performed as an atomic file system operation and all\n     other options are ignored. If the target file exists then it is\n     implementation specific if the existing file is replaced or this method\n     fails by throwing an {@link IOException}. If the move cannot be\n     performed as an atomic file system operation then {@link\n     AtomicMoveNotSupportedException} is thrown. This can arise, for\n     example, when the target location is on a different {@code FileStore}\n     and would require that the file be copied, or target location is\n     associated with a different provider to this object. \u003c/td\u003e\n \u003c/table\u003e\n\n \u003cp\u003e An implementation of this interface may support additional\n implementation specific options.\n\n \u003cp\u003e Moving a file will copy the {@link\n BasicFileAttributes#lastModifiedTime last-modified-time} to the target\n file if supported by both source and target file stores. Copying of file\n timestamps may result in precision loss. An implementation may also\n attempt to copy other file attributes but is not required to fail if the\n file attributes cannot be copied. When the move is performed as\n a non-atomic operation, and an {@code IOException} is thrown, then the\n state of the files is not defined. The original file and the target file\n may both exist, the target file may be incomplete or some of its file\n attributes may not been copied from the original file.\n\n \u003cp\u003e \u003cb\u003eUsage Examples:\u003c/b\u003e\n Suppose we want to rename a file to \"newname\", keeping the file in the\n same directory:\n \u003cpre\u003e\n     Path source \u003d ...\n     Files.move(source, source.resolveSibling(\"newname\"));\n \u003c/pre\u003e\n Alternatively, suppose we want to move a file to new directory, keeping\n the same file name, and replacing any existing file of that name in the\n directory:\n \u003cpre\u003e\n     Path source \u003d ...\n     Path newdir \u003d ...\n     Files.move(source, newdir.resolve(source.getFileName()), REPLACE_EXISTING);\n \u003c/pre\u003e","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.nio.file.Path, java.nio.file.Path, java.nio.file.CopyOption...)","flatSignature":"(Path, Path, CopyOption...)","returnType":{"isPrimitive":false,"simpleName":"Path","qualifiedName":"java.nio.file.Path","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"source","type":{"isPrimitive":false,"simpleName":"Path","qualifiedName":"java.nio.file.Path","dimension":"","elementType":{}}},{"name":"target","type":{"isPrimitive":false,"simpleName":"Path","qualifiedName":"java.nio.file.Path","dimension":"","elementType":{}}},{"name":"options","type":{"isPrimitive":false,"simpleName":"CopyOption","qualifiedName":"java.nio.file.CopyOption","dimension":"[]","elementType":{"isPrimitive":false,"simpleName":"CopyOption","qualifiedName":"java.nio.file.CopyOption","dimension":"","elementType":{}}}}],"typeParameters":[]},{"name":"readSymbolicLink","comment":"Reads the target of a symbolic link \u003ci\u003e(optional operation)\u003c/i\u003e.\n\n \u003cp\u003e If the file system supports \u003ca href\u003d\"package-summary.html#links\"\u003esymbolic\n links\u003c/a\u003e then this method is used to read the target of the link, failing\n if the file is not a symbolic link. The target of the link need not exist.\n The returned {@code Path} object will be associated with the same file\n system as {@code link}.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.nio.file.Path)","flatSignature":"(Path)","returnType":{"isPrimitive":false,"simpleName":"Path","qualifiedName":"java.nio.file.Path","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"link","type":{"isPrimitive":false,"simpleName":"Path","qualifiedName":"java.nio.file.Path","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"getFileStore","comment":"Returns the {@link FileStore} representing the file store where a file\n is located.\n\n \u003cp\u003e Once a reference to the {@code FileStore} is obtained it is\n implementation specific if operations on the returned {@code FileStore},\n or {@link FileStoreAttributeView} objects obtained from it, continue\n to depend on the existence of the file. In particular the behavior is not\n defined for the case that the file is deleted or moved to a different\n file store.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.nio.file.Path)","flatSignature":"(Path)","returnType":{"isPrimitive":false,"simpleName":"FileStore","qualifiedName":"java.nio.file.FileStore","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"path","type":{"isPrimitive":false,"simpleName":"Path","qualifiedName":"java.nio.file.Path","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"isSameFile","comment":"Tests if two paths locate the same file.\n\n \u003cp\u003e If both {@code Path} objects are {@link Path#equals(Object) equal}\n then this method returns {@code true} without checking if the file exists.\n If the two {@code Path} objects are associated with different providers\n then this method returns {@code false}. Otherwise, this method checks if\n both {@code Path} objects locate the same file, and depending on the\n implementation, may require to open or access both files.\n\n \u003cp\u003e If the file system and files remain static, then this method implements\n an equivalence relation for non-null {@code Paths}.\n \u003cul\u003e\n \u003cli\u003eIt is \u003ci\u003ereflexive\u003c/i\u003e: for {@code Path} {@code f},\n     {@code isSameFile(f,f)} should return {@code true}.\n \u003cli\u003eIt is \u003ci\u003esymmetric\u003c/i\u003e: for two {@code Paths} {@code f} and {@code g},\n     {@code isSameFile(f,g)} will equal {@code isSameFile(g,f)}.\n \u003cli\u003eIt is \u003ci\u003etransitive\u003c/i\u003e: for three {@code Paths}\n     {@code f}, {@code g}, and {@code h}, if {@code isSameFile(f,g)} returns\n     {@code true} and {@code isSameFile(g,h)} returns {@code true}, then\n     {@code isSameFile(f,h)} will return return {@code true}.\n \u003c/ul\u003e","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.nio.file.Path, java.nio.file.Path)","flatSignature":"(Path, Path)","returnType":{"isPrimitive":true,"simpleName":"boolean","qualifiedName":"boolean","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"path","type":{"isPrimitive":false,"simpleName":"Path","qualifiedName":"java.nio.file.Path","dimension":"","elementType":{}}},{"name":"path2","type":{"isPrimitive":false,"simpleName":"Path","qualifiedName":"java.nio.file.Path","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"isHidden","comment":"Tells whether or not a file is considered \u003cem\u003ehidden\u003c/em\u003e. The exact\n definition of hidden is platform or provider dependent. On UNIX for\n example a file is considered to be hidden if its name begins with a\n period character (\u0027.\u0027). On Windows a file is considered hidden if it\n isn\u0027t a directory and the DOS {@link DosFileAttributes#isHidden hidden}\n attribute is set.\n\n \u003cp\u003e Depending on the implementation this method may require to access\n the file system to determine if the file is considered hidden.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.nio.file.Path)","flatSignature":"(Path)","returnType":{"isPrimitive":true,"simpleName":"boolean","qualifiedName":"boolean","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"path","type":{"isPrimitive":false,"simpleName":"Path","qualifiedName":"java.nio.file.Path","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"probeContentType","comment":"Probes the content type of a file.\n\n \u003cp\u003e This method uses the installed {@link FileTypeDetector} implementations\n to probe the given file to determine its content type. Each file type\n detector\u0027s {@link FileTypeDetector#probeContentType probeContentType} is\n invoked, in turn, to probe the file type. If the file is recognized then\n the content type is returned. If the file is not recognized by any of the\n installed file type detectors then a system-default file type detector is\n invoked to guess the content type.\n\n \u003cp\u003e A given invocation of the Java virtual machine maintains a system-wide\n list of file type detectors. Installed file type detectors are loaded\n using the service-provider loading facility defined by the {@link ServiceLoader}\n class. Installed file type detectors are loaded using the system class\n loader. If the system class loader cannot be found then the extension class\n loader is used; If the extension class loader cannot be found then the\n bootstrap class loader is used. File type detectors are typically installed\n by placing them in a JAR file on the application class path or in the\n extension directory, the JAR file contains a provider-configuration file\n named {@code java.nio.file.spi.FileTypeDetector} in the resource directory\n {@code META-INF/services}, and the file lists one or more fully-qualified\n names of concrete subclass of {@code FileTypeDetector } that have a zero\n argument constructor. If the process of locating or instantiating the\n installed file type detectors fails then an unspecified error is thrown.\n The ordering that installed providers are located is implementation\n specific.\n\n \u003cp\u003e The return value of this method is the string form of the value of a\n Multipurpose Internet Mail Extension (MIME) content type as\n defined by \u003ca href\u003d\"http://www.ietf.org/rfc/rfc2045.txt\"\u003e\u003ci\u003eRFC\u0026nbsp;2045:\n Multipurpose Internet Mail Extensions (MIME) Part One: Format of Internet\n Message Bodies\u003c/i\u003e\u003c/a\u003e. The string is guaranteed to be parsable according\n to the grammar in the RFC.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.nio.file.Path)","flatSignature":"(Path)","returnType":{"isPrimitive":false,"simpleName":"String","qualifiedName":"java.lang.String","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"path","type":{"isPrimitive":false,"simpleName":"Path","qualifiedName":"java.nio.file.Path","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"getFileAttributeView","comment":"Returns a file attribute view of a given type.\n\n \u003cp\u003e A file attribute view provides a read-only or updatable view of a\n set of file attributes. This method is intended to be used where the file\n attribute view defines type-safe methods to read or update the file\n attributes. The {@code type} parameter is the type of the attribute view\n required and the method returns an instance of that type if supported.\n The {@link BasicFileAttributeView} type supports access to the basic\n attributes of a file. Invoking this method to select a file attribute\n view of that type will always return an instance of that class.\n\n \u003cp\u003e The {@code options} array may be used to indicate how symbolic links\n are handled by the resulting file attribute view for the case that the\n file is a symbolic link. By default, symbolic links are followed. If the\n option {@link LinkOption#NOFOLLOW_LINKS NOFOLLOW_LINKS} is present then\n symbolic links are not followed. This option is ignored by implementations\n that do not support symbolic links.\n\n \u003cp\u003e \u003cb\u003eUsage Example:\u003c/b\u003e\n Suppose we want read or set a file\u0027s ACL, if supported:\n \u003cpre\u003e\n     Path path \u003d ...\n     AclFileAttributeView view \u003d Files.getFileAttributeView(path, AclFileAttributeView.class);\n     if (view !\u003d null) {\n         List\u0026lt;AclEntry\u0026gt; acl \u003d view.getAcl();\n         :\n     }\n \u003c/pre\u003e","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.nio.file.Path, java.lang.Class\u003cV\u003e, java.nio.file.LinkOption...)","flatSignature":"(Path, Class\u003cV\u003e, LinkOption...)","returnType":{"isPrimitive":false,"simpleName":"V","qualifiedName":"V","dimension":"","elementType":{},"typeVariable":{"name":"V","bounds":["java.nio.file.attribute.FileAttributeView"]}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"path","type":{"isPrimitive":false,"simpleName":"Path","qualifiedName":"java.nio.file.Path","dimension":"","elementType":{}}},{"name":"type","type":{"isPrimitive":false,"simpleName":"Class","qualifiedName":"java.lang.Class","dimension":"","elementType":{}}},{"name":"options","type":{"isPrimitive":false,"simpleName":"LinkOption","qualifiedName":"java.nio.file.LinkOption","dimension":"[]","elementType":{"isPrimitive":false,"simpleName":"LinkOption","qualifiedName":"java.nio.file.LinkOption","dimension":"","elementType":{}}}}],"typeParameters":[{"name":"V","bounds":["java.nio.file.attribute.FileAttributeView"]}]},{"name":"readAttributes","comment":"Reads a file\u0027s attributes as a bulk operation.\n\n \u003cp\u003e The {@code type} parameter is the type of the attributes required\n and this method returns an instance of that type if supported. All\n implementations support a basic set of file attributes and so invoking\n this method with a  {@code type} parameter of {@code\n BasicFileAttributes.class} will not throw {@code\n UnsupportedOperationException}.\n\n \u003cp\u003e The {@code options} array may be used to indicate how symbolic links\n are handled for the case that the file is a symbolic link. By default,\n symbolic links are followed and the file attribute of the final target\n of the link is read. If the option {@link LinkOption#NOFOLLOW_LINKS\n NOFOLLOW_LINKS} is present then symbolic links are not followed.\n\n \u003cp\u003e It is implementation specific if all file attributes are read as an\n atomic operation with respect to other file system operations.\n\n \u003cp\u003e \u003cb\u003eUsage Example:\u003c/b\u003e\n Suppose we want to read a file\u0027s attributes in bulk:\n \u003cpre\u003e\n    Path path \u003d ...\n    BasicFileAttributes attrs \u003d Files.readAttributes(path, BasicFileAttributes.class);\n \u003c/pre\u003e\n Alternatively, suppose we want to read file\u0027s POSIX attributes without\n following symbolic links:\n \u003cpre\u003e\n    PosixFileAttributes attrs \u003d Files.readAttributes(path, PosixFileAttributes.class, NOFOLLOW_LINKS);\n \u003c/pre\u003e","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.nio.file.Path, java.lang.Class\u003cA\u003e, java.nio.file.LinkOption...)","flatSignature":"(Path, Class\u003cA\u003e, LinkOption...)","returnType":{"isPrimitive":false,"simpleName":"A","qualifiedName":"A","dimension":"","elementType":{},"typeVariable":{"name":"A","bounds":["java.nio.file.attribute.BasicFileAttributes"]}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"path","type":{"isPrimitive":false,"simpleName":"Path","qualifiedName":"java.nio.file.Path","dimension":"","elementType":{}}},{"name":"type","type":{"isPrimitive":false,"simpleName":"Class","qualifiedName":"java.lang.Class","dimension":"","elementType":{}}},{"name":"options","type":{"isPrimitive":false,"simpleName":"LinkOption","qualifiedName":"java.nio.file.LinkOption","dimension":"[]","elementType":{"isPrimitive":false,"simpleName":"LinkOption","qualifiedName":"java.nio.file.LinkOption","dimension":"","elementType":{}}}}],"typeParameters":[{"name":"A","bounds":["java.nio.file.attribute.BasicFileAttributes"]}]},{"name":"setAttribute","comment":"Sets the value of a file attribute.\n\n \u003cp\u003e The {@code attribute} parameter identifies the attribute to be set\n and takes the form:\n \u003cblockquote\u003e\n [\u003ci\u003eview-name\u003c/i\u003e\u003cb\u003e:\u003c/b\u003e]\u003ci\u003eattribute-name\u003c/i\u003e\n \u003c/blockquote\u003e\n where square brackets [...] delineate an optional component and the\n character {@code \u0027:\u0027} stands for itself.\n\n \u003cp\u003e \u003ci\u003eview-name\u003c/i\u003e is the {@link FileAttributeView#name name} of a {@link\n FileAttributeView} that identifies a set of file attributes. If not\n specified then it defaults to {@code \"basic\"}, the name of the file\n attribute view that identifies the basic set of file attributes common to\n many file systems. \u003ci\u003eattribute-name\u003c/i\u003e is the name of the attribute\n within the set.\n\n \u003cp\u003e The {@code options} array may be used to indicate how symbolic links\n are handled for the case that the file is a symbolic link. By default,\n symbolic links are followed and the file attribute of the final target\n of the link is set. If the option {@link LinkOption#NOFOLLOW_LINKS\n NOFOLLOW_LINKS} is present then symbolic links are not followed.\n\n \u003cp\u003e \u003cb\u003eUsage Example:\u003c/b\u003e\n Suppose we want to set the DOS \"hidden\" attribute:\n \u003cpre\u003e\n    Path path \u003d ...\n    Files.setAttribute(path, \"dos:hidden\", true);\n \u003c/pre\u003e","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.nio.file.Path, java.lang.String, java.lang.Object, java.nio.file.LinkOption...)","flatSignature":"(Path, String, Object, LinkOption...)","returnType":{"isPrimitive":false,"simpleName":"Path","qualifiedName":"java.nio.file.Path","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"path","type":{"isPrimitive":false,"simpleName":"Path","qualifiedName":"java.nio.file.Path","dimension":"","elementType":{}}},{"name":"attribute","type":{"isPrimitive":false,"simpleName":"String","qualifiedName":"java.lang.String","dimension":"","elementType":{}}},{"name":"value","type":{"isPrimitive":false,"simpleName":"Object","qualifiedName":"java.lang.Object","dimension":"","elementType":{}}},{"name":"options","type":{"isPrimitive":false,"simpleName":"LinkOption","qualifiedName":"java.nio.file.LinkOption","dimension":"[]","elementType":{"isPrimitive":false,"simpleName":"LinkOption","qualifiedName":"java.nio.file.LinkOption","dimension":"","elementType":{}}}}],"typeParameters":[]},{"name":"getAttribute","comment":"Reads the value of a file attribute.\n\n \u003cp\u003e The {@code attribute} parameter identifies the attribute to be read\n and takes the form:\n \u003cblockquote\u003e\n [\u003ci\u003eview-name\u003c/i\u003e\u003cb\u003e:\u003c/b\u003e]\u003ci\u003eattribute-name\u003c/i\u003e\n \u003c/blockquote\u003e\n where square brackets [...] delineate an optional component and the\n character {@code \u0027:\u0027} stands for itself.\n\n \u003cp\u003e \u003ci\u003eview-name\u003c/i\u003e is the {@link FileAttributeView#name name} of a {@link\n FileAttributeView} that identifies a set of file attributes. If not\n specified then it defaults to {@code \"basic\"}, the name of the file\n attribute view that identifies the basic set of file attributes common to\n many file systems. \u003ci\u003eattribute-name\u003c/i\u003e is the name of the attribute.\n\n \u003cp\u003e The {@code options} array may be used to indicate how symbolic links\n are handled for the case that the file is a symbolic link. By default,\n symbolic links are followed and the file attribute of the final target\n of the link is read. If the option {@link LinkOption#NOFOLLOW_LINKS\n NOFOLLOW_LINKS} is present then symbolic links are not followed.\n\n \u003cp\u003e \u003cb\u003eUsage Example:\u003c/b\u003e\n Suppose we require the user ID of the file owner on a system that\n supports a \"{@code unix}\" view:\n \u003cpre\u003e\n    Path path \u003d ...\n    int uid \u003d (Integer)Files.getAttribute(path, \"unix:uid\");\n \u003c/pre\u003e","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.nio.file.Path, java.lang.String, java.nio.file.LinkOption...)","flatSignature":"(Path, String, LinkOption...)","returnType":{"isPrimitive":false,"simpleName":"Object","qualifiedName":"java.lang.Object","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"path","type":{"isPrimitive":false,"simpleName":"Path","qualifiedName":"java.nio.file.Path","dimension":"","elementType":{}}},{"name":"attribute","type":{"isPrimitive":false,"simpleName":"String","qualifiedName":"java.lang.String","dimension":"","elementType":{}}},{"name":"options","type":{"isPrimitive":false,"simpleName":"LinkOption","qualifiedName":"java.nio.file.LinkOption","dimension":"[]","elementType":{"isPrimitive":false,"simpleName":"LinkOption","qualifiedName":"java.nio.file.LinkOption","dimension":"","elementType":{}}}}],"typeParameters":[]},{"name":"readAttributes","comment":"Reads a set of file attributes as a bulk operation.\n\n \u003cp\u003e The {@code attributes} parameter identifies the attributes to be read\n and takes the form:\n \u003cblockquote\u003e\n [\u003ci\u003eview-name\u003c/i\u003e\u003cb\u003e:\u003c/b\u003e]\u003ci\u003eattribute-list\u003c/i\u003e\n \u003c/blockquote\u003e\n where square brackets [...] delineate an optional component and the\n character {@code \u0027:\u0027} stands for itself.\n\n \u003cp\u003e \u003ci\u003eview-name\u003c/i\u003e is the {@link FileAttributeView#name name} of a {@link\n FileAttributeView} that identifies a set of file attributes. If not\n specified then it defaults to {@code \"basic\"}, the name of the file\n attribute view that identifies the basic set of file attributes common to\n many file systems.\n\n \u003cp\u003e The \u003ci\u003eattribute-list\u003c/i\u003e component is a comma separated list of\n zero or more names of attributes to read. If the list contains the value\n {@code \"*\"} then all attributes are read. Attributes that are not supported\n are ignored and will not be present in the returned map. It is\n implementation specific if all attributes are read as an atomic operation\n with respect to other file system operations.\n\n \u003cp\u003e The following examples demonstrate possible values for the {@code\n attributes} parameter:\n\n \u003cblockquote\u003e\n \u003ctable border\u003d\"0\" summary\u003d\"Possible values\"\u003e\n \u003ctr\u003e\n   \u003ctd\u003e {@code \"*\"} \u003c/td\u003e\n   \u003ctd\u003e Read all {@link BasicFileAttributes basic-file-attributes}. \u003c/td\u003e\n \u003c/tr\u003e\n \u003ctr\u003e\n   \u003ctd\u003e {@code \"size,lastModifiedTime,lastAccessTime\"} \u003c/td\u003e\n   \u003ctd\u003e Reads the file size, last modified time, and last access time\n     attributes. \u003c/td\u003e\n \u003c/tr\u003e\n \u003ctr\u003e\n   \u003ctd\u003e {@code \"posix:*\"} \u003c/td\u003e\n   \u003ctd\u003e Read all {@link PosixFileAttributes POSIX-file-attributes}. \u003c/td\u003e\n \u003c/tr\u003e\n \u003ctr\u003e\n   \u003ctd\u003e {@code \"posix:permissions,owner,size\"} \u003c/td\u003e\n   \u003ctd\u003e Reads the POSX file permissions, owner, and file size. \u003c/td\u003e\n \u003c/tr\u003e\n \u003c/table\u003e\n \u003c/blockquote\u003e\n\n \u003cp\u003e The {@code options} array may be used to indicate how symbolic links\n are handled for the case that the file is a symbolic link. By default,\n symbolic links are followed and the file attribute of the final target\n of the link is read. If the option {@link LinkOption#NOFOLLOW_LINKS\n NOFOLLOW_LINKS} is present then symbolic links are not followed.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.nio.file.Path, java.lang.String, java.nio.file.LinkOption...)","flatSignature":"(Path, String, LinkOption...)","returnType":{"isPrimitive":false,"simpleName":"Map","qualifiedName":"java.util.Map","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"path","type":{"isPrimitive":false,"simpleName":"Path","qualifiedName":"java.nio.file.Path","dimension":"","elementType":{}}},{"name":"attributes","type":{"isPrimitive":false,"simpleName":"String","qualifiedName":"java.lang.String","dimension":"","elementType":{}}},{"name":"options","type":{"isPrimitive":false,"simpleName":"LinkOption","qualifiedName":"java.nio.file.LinkOption","dimension":"[]","elementType":{"isPrimitive":false,"simpleName":"LinkOption","qualifiedName":"java.nio.file.LinkOption","dimension":"","elementType":{}}}}],"typeParameters":[]},{"name":"getPosixFilePermissions","comment":"Returns a file\u0027s POSIX file permissions.\n\n \u003cp\u003e The {@code path} parameter is associated with a {@code FileSystem}\n that supports the {@link PosixFileAttributeView}. This attribute view\n provides access to file attributes commonly associated with files on file\n systems used by operating systems that implement the Portable Operating\n System Interface (POSIX) family of standards.\n\n \u003cp\u003e The {@code options} array may be used to indicate how symbolic links\n are handled for the case that the file is a symbolic link. By default,\n symbolic links are followed and the file attribute of the final target\n of the link is read. If the option {@link LinkOption#NOFOLLOW_LINKS\n NOFOLLOW_LINKS} is present then symbolic links are not followed.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.nio.file.Path, java.nio.file.LinkOption...)","flatSignature":"(Path, LinkOption...)","returnType":{"isPrimitive":false,"simpleName":"Set","qualifiedName":"java.util.Set","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"path","type":{"isPrimitive":false,"simpleName":"Path","qualifiedName":"java.nio.file.Path","dimension":"","elementType":{}}},{"name":"options","type":{"isPrimitive":false,"simpleName":"LinkOption","qualifiedName":"java.nio.file.LinkOption","dimension":"[]","elementType":{"isPrimitive":false,"simpleName":"LinkOption","qualifiedName":"java.nio.file.LinkOption","dimension":"","elementType":{}}}}],"typeParameters":[]},{"name":"setPosixFilePermissions","comment":"Sets a file\u0027s POSIX permissions.\n\n \u003cp\u003e The {@code path} parameter is associated with a {@code FileSystem}\n that supports the {@link PosixFileAttributeView}. This attribute view\n provides access to file attributes commonly associated with files on file\n systems used by operating systems that implement the Portable Operating\n System Interface (POSIX) family of standards.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.nio.file.Path, java.util.Set\u003cjava.nio.file.attribute.PosixFilePermission\u003e)","flatSignature":"(Path, Set\u003cPosixFilePermission\u003e)","returnType":{"isPrimitive":false,"simpleName":"Path","qualifiedName":"java.nio.file.Path","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"path","type":{"isPrimitive":false,"simpleName":"Path","qualifiedName":"java.nio.file.Path","dimension":"","elementType":{}}},{"name":"perms","type":{"isPrimitive":false,"simpleName":"Set","qualifiedName":"java.util.Set","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"getOwner","comment":"Returns the owner of a file.\n\n \u003cp\u003e The {@code path} parameter is associated with a file system that\n supports {@link FileOwnerAttributeView}. This file attribute view provides\n access to a file attribute that is the owner of the file.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.nio.file.Path, java.nio.file.LinkOption...)","flatSignature":"(Path, LinkOption...)","returnType":{"isPrimitive":false,"simpleName":"UserPrincipal","qualifiedName":"java.nio.file.attribute.UserPrincipal","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"path","type":{"isPrimitive":false,"simpleName":"Path","qualifiedName":"java.nio.file.Path","dimension":"","elementType":{}}},{"name":"options","type":{"isPrimitive":false,"simpleName":"LinkOption","qualifiedName":"java.nio.file.LinkOption","dimension":"[]","elementType":{"isPrimitive":false,"simpleName":"LinkOption","qualifiedName":"java.nio.file.LinkOption","dimension":"","elementType":{}}}}],"typeParameters":[]},{"name":"setOwner","comment":"Updates the file owner.\n\n \u003cp\u003e The {@code path} parameter is associated with a file system that\n supports {@link FileOwnerAttributeView}. This file attribute view provides\n access to a file attribute that is the owner of the file.\n\n \u003cp\u003e \u003cb\u003eUsage Example:\u003c/b\u003e\n Suppose we want to make \"joe\" the owner of a file:\n \u003cpre\u003e\n     Path path \u003d ...\n     UserPrincipalLookupService lookupService \u003d\n         provider(path).getUserPrincipalLookupService();\n     UserPrincipal joe \u003d lookupService.lookupPrincipalByName(\"joe\");\n     Files.setOwner(path, joe);\n \u003c/pre\u003e","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.nio.file.Path, java.nio.file.attribute.UserPrincipal)","flatSignature":"(Path, UserPrincipal)","returnType":{"isPrimitive":false,"simpleName":"Path","qualifiedName":"java.nio.file.Path","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"path","type":{"isPrimitive":false,"simpleName":"Path","qualifiedName":"java.nio.file.Path","dimension":"","elementType":{}}},{"name":"owner","type":{"isPrimitive":false,"simpleName":"UserPrincipal","qualifiedName":"java.nio.file.attribute.UserPrincipal","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"isSymbolicLink","comment":"Tests whether a file is a symbolic link.\n\n \u003cp\u003e Where it is required to distinguish an I/O exception from the case\n that the file is not a symbolic link then the file attributes can be\n read with the {@link #readAttributes(Path,Class,LinkOption[])\n readAttributes} method and the file type tested with the {@link\n BasicFileAttributes#isSymbolicLink} method.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.nio.file.Path)","flatSignature":"(Path)","returnType":{"isPrimitive":true,"simpleName":"boolean","qualifiedName":"boolean","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"path","type":{"isPrimitive":false,"simpleName":"Path","qualifiedName":"java.nio.file.Path","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"isDirectory","comment":"Tests whether a file is a directory.\n\n \u003cp\u003e The {@code options} array may be used to indicate how symbolic links\n are handled for the case that the file is a symbolic link. By default,\n symbolic links are followed and the file attribute of the final target\n of the link is read. If the option {@link LinkOption#NOFOLLOW_LINKS\n NOFOLLOW_LINKS} is present then symbolic links are not followed.\n\n \u003cp\u003e Where it is required to distinguish an I/O exception from the case\n that the file is not a directory then the file attributes can be\n read with the {@link #readAttributes(Path,Class,LinkOption[])\n readAttributes} method and the file type tested with the {@link\n BasicFileAttributes#isDirectory} method.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.nio.file.Path, java.nio.file.LinkOption...)","flatSignature":"(Path, LinkOption...)","returnType":{"isPrimitive":true,"simpleName":"boolean","qualifiedName":"boolean","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"path","type":{"isPrimitive":false,"simpleName":"Path","qualifiedName":"java.nio.file.Path","dimension":"","elementType":{}}},{"name":"options","type":{"isPrimitive":false,"simpleName":"LinkOption","qualifiedName":"java.nio.file.LinkOption","dimension":"[]","elementType":{"isPrimitive":false,"simpleName":"LinkOption","qualifiedName":"java.nio.file.LinkOption","dimension":"","elementType":{}}}}],"typeParameters":[]},{"name":"isRegularFile","comment":"Tests whether a file is a regular file with opaque content.\n\n \u003cp\u003e The {@code options} array may be used to indicate how symbolic links\n are handled for the case that the file is a symbolic link. By default,\n symbolic links are followed and the file attribute of the final target\n of the link is read. If the option {@link LinkOption#NOFOLLOW_LINKS\n NOFOLLOW_LINKS} is present then symbolic links are not followed.\n\n \u003cp\u003e Where it is required to distinguish an I/O exception from the case\n that the file is not a regular file then the file attributes can be\n read with the {@link #readAttributes(Path,Class,LinkOption[])\n readAttributes} method and the file type tested with the {@link\n BasicFileAttributes#isRegularFile} method.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.nio.file.Path, java.nio.file.LinkOption...)","flatSignature":"(Path, LinkOption...)","returnType":{"isPrimitive":true,"simpleName":"boolean","qualifiedName":"boolean","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"path","type":{"isPrimitive":false,"simpleName":"Path","qualifiedName":"java.nio.file.Path","dimension":"","elementType":{}}},{"name":"options","type":{"isPrimitive":false,"simpleName":"LinkOption","qualifiedName":"java.nio.file.LinkOption","dimension":"[]","elementType":{"isPrimitive":false,"simpleName":"LinkOption","qualifiedName":"java.nio.file.LinkOption","dimension":"","elementType":{}}}}],"typeParameters":[]},{"name":"getLastModifiedTime","comment":"Returns a file\u0027s last modified time.\n\n \u003cp\u003e The {@code options} array may be used to indicate how symbolic links\n are handled for the case that the file is a symbolic link. By default,\n symbolic links are followed and the file attribute of the final target\n of the link is read. If the option {@link LinkOption#NOFOLLOW_LINKS\n NOFOLLOW_LINKS} is present then symbolic links are not followed.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.nio.file.Path, java.nio.file.LinkOption...)","flatSignature":"(Path, LinkOption...)","returnType":{"isPrimitive":false,"simpleName":"FileTime","qualifiedName":"java.nio.file.attribute.FileTime","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"path","type":{"isPrimitive":false,"simpleName":"Path","qualifiedName":"java.nio.file.Path","dimension":"","elementType":{}}},{"name":"options","type":{"isPrimitive":false,"simpleName":"LinkOption","qualifiedName":"java.nio.file.LinkOption","dimension":"[]","elementType":{"isPrimitive":false,"simpleName":"LinkOption","qualifiedName":"java.nio.file.LinkOption","dimension":"","elementType":{}}}}],"typeParameters":[]},{"name":"setLastModifiedTime","comment":"Updates a file\u0027s last modified time attribute. The file time is converted\n to the epoch and precision supported by the file system. Converting from\n finer to coarser granularities result in precision loss. The behavior of\n this method when attempting to set the last modified time when it is not\n supported by the file system or is outside the range supported by the\n underlying file store is not defined. It may or not fail by throwing an\n {@code IOException}.\n\n \u003cp\u003e \u003cb\u003eUsage Example:\u003c/b\u003e\n Suppose we want to set the last modified time to the current time:\n \u003cpre\u003e\n    Path path \u003d ...\n    FileTime now \u003d FileTime.fromMillis(System.currentTimeMillis());\n    Files.setLastModifiedTime(path, now);\n \u003c/pre\u003e","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.nio.file.Path, java.nio.file.attribute.FileTime)","flatSignature":"(Path, FileTime)","returnType":{"isPrimitive":false,"simpleName":"Path","qualifiedName":"java.nio.file.Path","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"path","type":{"isPrimitive":false,"simpleName":"Path","qualifiedName":"java.nio.file.Path","dimension":"","elementType":{}}},{"name":"time","type":{"isPrimitive":false,"simpleName":"FileTime","qualifiedName":"java.nio.file.attribute.FileTime","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"size","comment":"Returns the size of a file (in bytes). The size may differ from the\n actual size on the file system due to compression, support for sparse\n files, or other reasons. The size of files that are not {@link\n #isRegularFile regular} files is implementation specific and\n therefore unspecified.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.nio.file.Path)","flatSignature":"(Path)","returnType":{"isPrimitive":true,"simpleName":"long","qualifiedName":"long","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"path","type":{"isPrimitive":false,"simpleName":"Path","qualifiedName":"java.nio.file.Path","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"exists","comment":"Tests whether a file exists.\n\n \u003cp\u003e The {@code options} parameter may be used to indicate how symbolic links\n are handled for the case that the file is a symbolic link. By default,\n symbolic links are followed. If the option {@link LinkOption#NOFOLLOW_LINKS\n NOFOLLOW_LINKS} is present then symbolic links are not followed.\n\n \u003cp\u003e Note that the result of this method is immediately outdated. If this\n method indicates the file exists then there is no guarantee that a\n subsequence access will succeed. Care should be taken when using this\n method in security sensitive applications.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.nio.file.Path, java.nio.file.LinkOption...)","flatSignature":"(Path, LinkOption...)","returnType":{"isPrimitive":true,"simpleName":"boolean","qualifiedName":"boolean","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"path","type":{"isPrimitive":false,"simpleName":"Path","qualifiedName":"java.nio.file.Path","dimension":"","elementType":{}}},{"name":"options","type":{"isPrimitive":false,"simpleName":"LinkOption","qualifiedName":"java.nio.file.LinkOption","dimension":"[]","elementType":{"isPrimitive":false,"simpleName":"LinkOption","qualifiedName":"java.nio.file.LinkOption","dimension":"","elementType":{}}}}],"typeParameters":[]},{"name":"notExists","comment":"Tests whether the file located by this path does not exist. This method\n is intended for cases where it is required to take action when it can be\n confirmed that a file does not exist.\n\n \u003cp\u003e The {@code options} parameter may be used to indicate how symbolic links\n are handled for the case that the file is a symbolic link. By default,\n symbolic links are followed. If the option {@link LinkOption#NOFOLLOW_LINKS\n NOFOLLOW_LINKS} is present then symbolic links are not followed.\n\n \u003cp\u003e Note that this method is not the complement of the {@link #exists\n exists} method. Where it is not possible to determine if a file exists\n or not then both methods return {@code false}. As with the {@code exists}\n method, the result of this method is immediately outdated. If this\n method indicates the file does exist then there is no guarantee that a\n subsequence attempt to create the file will succeed. Care should be taken\n when using this method in security sensitive applications.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.nio.file.Path, java.nio.file.LinkOption...)","flatSignature":"(Path, LinkOption...)","returnType":{"isPrimitive":true,"simpleName":"boolean","qualifiedName":"boolean","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"path","type":{"isPrimitive":false,"simpleName":"Path","qualifiedName":"java.nio.file.Path","dimension":"","elementType":{}}},{"name":"options","type":{"isPrimitive":false,"simpleName":"LinkOption","qualifiedName":"java.nio.file.LinkOption","dimension":"[]","elementType":{"isPrimitive":false,"simpleName":"LinkOption","qualifiedName":"java.nio.file.LinkOption","dimension":"","elementType":{}}}}],"typeParameters":[]},{"name":"isReadable","comment":"Tests whether a file is readable. This method checks that a file exists\n and that this Java virtual machine has appropriate privileges that would\n allow it open the file for reading. Depending on the implementation, this\n method may require to read file permissions, access control lists, or\n other file attributes in order to check the effective access to the file.\n Consequently, this method may not be atomic with respect to other file\n system operations.\n\n \u003cp\u003e Note that the result of this method is immediately outdated, there is\n no guarantee that a subsequent attempt to open the file for reading will\n succeed (or even that it will access the same file). Care should be taken\n when using this method in security sensitive applications.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.nio.file.Path)","flatSignature":"(Path)","returnType":{"isPrimitive":true,"simpleName":"boolean","qualifiedName":"boolean","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"path","type":{"isPrimitive":false,"simpleName":"Path","qualifiedName":"java.nio.file.Path","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"isWritable","comment":"Tests whether a file is writable. This method checks that a file exists\n and that this Java virtual machine has appropriate privileges that would\n allow it open the file for writing. Depending on the implementation, this\n method may require to read file permissions, access control lists, or\n other file attributes in order to check the effective access to the file.\n Consequently, this method may not be atomic with respect to other file\n system operations.\n\n \u003cp\u003e Note that result of this method is immediately outdated, there is no\n guarantee that a subsequent attempt to open the file for writing will\n succeed (or even that it will access the same file). Care should be taken\n when using this method in security sensitive applications.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.nio.file.Path)","flatSignature":"(Path)","returnType":{"isPrimitive":true,"simpleName":"boolean","qualifiedName":"boolean","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"path","type":{"isPrimitive":false,"simpleName":"Path","qualifiedName":"java.nio.file.Path","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"isExecutable","comment":"Tests whether a file is executable. This method checks that a file exists\n and that this Java virtual machine has appropriate privileges to {@link\n Runtime#exec execute} the file. The semantics may differ when checking\n access to a directory. For example, on UNIX systems, checking for\n execute access checks that the Java virtual machine has permission to\n search the directory in order to access file or subdirectories.\n\n \u003cp\u003e Depending on the implementation, this method may require to read file\n permissions, access control lists, or other file attributes in order to\n check the effective access to the file. Consequently, this method may not\n be atomic with respect to other file system operations.\n\n \u003cp\u003e Note that the result of this method is immediately outdated, there is\n no guarantee that a subsequent attempt to execute the file will succeed\n (or even that it will access the same file). Care should be taken when\n using this method in security sensitive applications.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.nio.file.Path)","flatSignature":"(Path)","returnType":{"isPrimitive":true,"simpleName":"boolean","qualifiedName":"boolean","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"path","type":{"isPrimitive":false,"simpleName":"Path","qualifiedName":"java.nio.file.Path","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"walkFileTree","comment":"Walks a file tree.\n\n \u003cp\u003e This method walks a file tree rooted at a given starting file. The\n file tree traversal is \u003cem\u003edepth-first\u003c/em\u003e with the given {@link\n FileVisitor} invoked for each file encountered. File tree traversal\n completes when all accessible files in the tree have been visited, or a\n visit method returns a result of {@link FileVisitResult#TERMINATE\n TERMINATE}. Where a visit method terminates due an {@code IOException},\n an uncaught error, or runtime exception, then the traversal is terminated\n and the error or exception is propagated to the caller of this method.\n\n \u003cp\u003e For each file encountered this method attempts to read its {@link\n java.nio.file.attribute.BasicFileAttributes}. If the file is not a\n directory then the {@link FileVisitor#visitFile visitFile} method is\n invoked with the file attributes. If the file attributes cannot be read,\n due to an I/O exception, then the {@link FileVisitor#visitFileFailed\n visitFileFailed} method is invoked with the I/O exception.\n\n \u003cp\u003e Where the file is a directory, and the directory could not be opened,\n then the {@code visitFileFailed} method is invoked with the I/O exception,\n after which, the file tree walk continues, by default, at the next\n \u003cem\u003esibling\u003c/em\u003e of the directory.\n\n \u003cp\u003e Where the directory is opened successfully, then the entries in the\n directory, and their \u003cem\u003edescendants\u003c/em\u003e are visited. When all entries\n have been visited, or an I/O error occurs during iteration of the\n directory, then the directory is closed and the visitor\u0027s {@link\n FileVisitor#postVisitDirectory postVisitDirectory} method is invoked.\n The file tree walk then continues, by default, at the next \u003cem\u003esibling\u003c/em\u003e\n of the directory.\n\n \u003cp\u003e By default, symbolic links are not automatically followed by this\n method. If the {@code options} parameter contains the {@link\n FileVisitOption#FOLLOW_LINKS FOLLOW_LINKS} option then symbolic links are\n followed. When following links, and the attributes of the target cannot\n be read, then this method attempts to get the {@code BasicFileAttributes}\n of the link. If they can be read then the {@code visitFile} method is\n invoked with the attributes of the link (otherwise the {@code visitFileFailed}\n method is invoked as specified above).\n\n \u003cp\u003e If the {@code options} parameter contains the {@link\n FileVisitOption#FOLLOW_LINKS FOLLOW_LINKS} option then this method keeps\n track of directories visited so that cycles can be detected. A cycle\n arises when there is an entry in a directory that is an ancestor of the\n directory. Cycle detection is done by recording the {@link\n java.nio.file.attribute.BasicFileAttributes#fileKey file-key} of directories,\n or if file keys are not available, by invoking the {@link #isSameFile\n isSameFile} method to test if a directory is the same file as an\n ancestor. When a cycle is detected it is treated as an I/O error, and the\n {@link FileVisitor#visitFileFailed visitFileFailed} method is invoked with\n an instance of {@link FileSystemLoopException}.\n\n \u003cp\u003e The {@code maxDepth} parameter is the maximum number of levels of\n directories to visit. A value of {@code 0} means that only the starting\n file is visited, unless denied by the security manager. A value of\n {@link Integer#MAX_VALUE MAX_VALUE} may be used to indicate that all\n levels should be visited. The {@code visitFile} method is invoked for all\n files, including directories, encountered at {@code maxDepth}, unless the\n basic file attributes cannot be read, in which case the {@code\n visitFileFailed} method is invoked.\n\n \u003cp\u003e If a visitor returns a result of {@code null} then {@code\n NullPointerException} is thrown.\n\n \u003cp\u003e When a security manager is installed and it denies access to a file\n (or directory), then it is ignored and the visitor is not invoked for\n that file (or directory).","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.nio.file.Path, java.util.Set\u003cjava.nio.file.FileVisitOption\u003e, int, java.nio.file.FileVisitor\u003c? super java.nio.file.Path\u003e)","flatSignature":"(Path, Set\u003cFileVisitOption\u003e, int, FileVisitor\u003c? super Path\u003e)","returnType":{"isPrimitive":false,"simpleName":"Path","qualifiedName":"java.nio.file.Path","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"start","type":{"isPrimitive":false,"simpleName":"Path","qualifiedName":"java.nio.file.Path","dimension":"","elementType":{}}},{"name":"options","type":{"isPrimitive":false,"simpleName":"Set","qualifiedName":"java.util.Set","dimension":"","elementType":{}}},{"name":"maxDepth","type":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}}},{"name":"visitor","type":{"isPrimitive":false,"simpleName":"FileVisitor","qualifiedName":"java.nio.file.FileVisitor","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"walkFileTree","comment":"Walks a file tree.\n\n \u003cp\u003e This method works as if invoking it were equivalent to evaluating the\n expression:\n \u003cblockquote\u003e\u003cpre\u003e\n walkFileTree(start, EnumSet.noneOf(FileVisitOption.class), Integer.MAX_VALUE, visitor)\n \u003c/pre\u003e\u003c/blockquote\u003e\n In other words, it does not follow symbolic links, and visits all levels\n of the file tree.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.nio.file.Path, java.nio.file.FileVisitor\u003c? super java.nio.file.Path\u003e)","flatSignature":"(Path, FileVisitor\u003c? super Path\u003e)","returnType":{"isPrimitive":false,"simpleName":"Path","qualifiedName":"java.nio.file.Path","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"start","type":{"isPrimitive":false,"simpleName":"Path","qualifiedName":"java.nio.file.Path","dimension":"","elementType":{}}},{"name":"visitor","type":{"isPrimitive":false,"simpleName":"FileVisitor","qualifiedName":"java.nio.file.FileVisitor","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"newBufferedReader","comment":"Opens a file for reading, returning a {@code BufferedReader} that may be\n used to read text from the file in an efficient manner. Bytes from the\n file are decoded into characters using the specified charset. Reading\n commences at the beginning of the file.\n\n \u003cp\u003e The {@code Reader} methods that read from the file throw {@code\n IOException} if a malformed or unmappable byte sequence is read.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.nio.file.Path, java.nio.charset.Charset)","flatSignature":"(Path, Charset)","returnType":{"isPrimitive":false,"simpleName":"BufferedReader","qualifiedName":"java.io.BufferedReader","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"path","type":{"isPrimitive":false,"simpleName":"Path","qualifiedName":"java.nio.file.Path","dimension":"","elementType":{}}},{"name":"cs","type":{"isPrimitive":false,"simpleName":"Charset","qualifiedName":"java.nio.charset.Charset","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"newBufferedReader","comment":"Opens a file for reading, returning a {@code BufferedReader} to read text\n from the file in an efficient manner. Bytes from the file are decoded into\n characters using the {@link StandardCharsets#UTF_8 UTF-8} {@link Charset\n charset}.\n\n \u003cp\u003e This method works as if invoking it were equivalent to evaluating the\n expression:\n \u003cpre\u003e{@code\n Files.newBufferedReader(path, StandardCharsets.UTF_8)\n }\u003c/pre\u003e","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.nio.file.Path)","flatSignature":"(Path)","returnType":{"isPrimitive":false,"simpleName":"BufferedReader","qualifiedName":"java.io.BufferedReader","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"path","type":{"isPrimitive":false,"simpleName":"Path","qualifiedName":"java.nio.file.Path","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"newBufferedWriter","comment":"Opens or creates a file for writing, returning a {@code BufferedWriter}\n that may be used to write text to the file in an efficient manner.\n The {@code options} parameter specifies how the the file is created or\n opened. If no options are present then this method works as if the {@link\n StandardOpenOption#CREATE CREATE}, {@link\n StandardOpenOption#TRUNCATE_EXISTING TRUNCATE_EXISTING}, and {@link\n StandardOpenOption#WRITE WRITE} options are present. In other words, it\n opens the file for writing, creating the file if it doesn\u0027t exist, or\n initially truncating an existing {@link #isRegularFile regular-file} to\n a size of {@code 0} if it exists.\n\n \u003cp\u003e The {@code Writer} methods to write text throw {@code IOException}\n if the text cannot be encoded using the specified charset.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.nio.file.Path, java.nio.charset.Charset, java.nio.file.OpenOption...)","flatSignature":"(Path, Charset, OpenOption...)","returnType":{"isPrimitive":false,"simpleName":"BufferedWriter","qualifiedName":"java.io.BufferedWriter","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"path","type":{"isPrimitive":false,"simpleName":"Path","qualifiedName":"java.nio.file.Path","dimension":"","elementType":{}}},{"name":"cs","type":{"isPrimitive":false,"simpleName":"Charset","qualifiedName":"java.nio.charset.Charset","dimension":"","elementType":{}}},{"name":"options","type":{"isPrimitive":false,"simpleName":"OpenOption","qualifiedName":"java.nio.file.OpenOption","dimension":"[]","elementType":{"isPrimitive":false,"simpleName":"OpenOption","qualifiedName":"java.nio.file.OpenOption","dimension":"","elementType":{}}}}],"typeParameters":[]},{"name":"newBufferedWriter","comment":"Opens or creates a file for writing, returning a {@code BufferedWriter}\n to write text to the file in an efficient manner. The text is encoded\n into bytes for writing using the {@link StandardCharsets#UTF_8 UTF-8}\n {@link Charset charset}.\n\n \u003cp\u003e This method works as if invoking it were equivalent to evaluating the\n expression:\n \u003cpre\u003e{@code\n Files.newBufferedWriter(path, StandardCharsets.UTF_8, options)\n }\u003c/pre\u003e","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.nio.file.Path, java.nio.file.OpenOption...)","flatSignature":"(Path, OpenOption...)","returnType":{"isPrimitive":false,"simpleName":"BufferedWriter","qualifiedName":"java.io.BufferedWriter","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"path","type":{"isPrimitive":false,"simpleName":"Path","qualifiedName":"java.nio.file.Path","dimension":"","elementType":{}}},{"name":"options","type":{"isPrimitive":false,"simpleName":"OpenOption","qualifiedName":"java.nio.file.OpenOption","dimension":"[]","elementType":{"isPrimitive":false,"simpleName":"OpenOption","qualifiedName":"java.nio.file.OpenOption","dimension":"","elementType":{}}}}],"typeParameters":[]},{"name":"copy","comment":"Copies all bytes from an input stream to a file. On return, the input\n stream will be at end of stream.\n\n \u003cp\u003e By default, the copy fails if the target file already exists or is a\n symbolic link. If the {@link StandardCopyOption#REPLACE_EXISTING\n REPLACE_EXISTING} option is specified, and the target file already exists,\n then it is replaced if it is not a non-empty directory. If the target\n file exists and is a symbolic link, then the symbolic link is replaced.\n In this release, the {@code REPLACE_EXISTING} option is the only option\n required to be supported by this method. Additional options may be\n supported in future releases.\n\n \u003cp\u003e  If an I/O error occurs reading from the input stream or writing to\n the file, then it may do so after the target file has been created and\n after some bytes have been read or written. Consequently the input\n stream may not be at end of stream and may be in an inconsistent state.\n It is strongly recommended that the input stream be promptly closed if an\n I/O error occurs.\n\n \u003cp\u003e This method may block indefinitely reading from the input stream (or\n writing to the file). The behavior for the case that the input stream is\n \u003ci\u003easynchronously closed\u003c/i\u003e or the thread interrupted during the copy is\n highly input stream and file system provider specific and therefore not\n specified.\n\n \u003cp\u003e \u003cb\u003eUsage example\u003c/b\u003e: Suppose we want to capture a web page and save\n it to a file:\n \u003cpre\u003e\n     Path path \u003d ...\n     URI u \u003d URI.create(\"http://java.sun.com/\");\n     try (InputStream in \u003d u.toURL().openStream()) {\n         Files.copy(in, path);\n     }\n \u003c/pre\u003e","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.io.InputStream, java.nio.file.Path, java.nio.file.CopyOption...)","flatSignature":"(InputStream, Path, CopyOption...)","returnType":{"isPrimitive":true,"simpleName":"long","qualifiedName":"long","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"in","type":{"isPrimitive":false,"simpleName":"InputStream","qualifiedName":"java.io.InputStream","dimension":"","elementType":{}}},{"name":"target","type":{"isPrimitive":false,"simpleName":"Path","qualifiedName":"java.nio.file.Path","dimension":"","elementType":{}}},{"name":"options","type":{"isPrimitive":false,"simpleName":"CopyOption","qualifiedName":"java.nio.file.CopyOption","dimension":"[]","elementType":{"isPrimitive":false,"simpleName":"CopyOption","qualifiedName":"java.nio.file.CopyOption","dimension":"","elementType":{}}}}],"typeParameters":[]},{"name":"copy","comment":"Copies all bytes from a file to an output stream.\n\n \u003cp\u003e If an I/O error occurs reading from the file or writing to the output\n stream, then it may do so after some bytes have been read or written.\n Consequently the output stream may be in an inconsistent state. It is\n strongly recommended that the output stream be promptly closed if an I/O\n error occurs.\n\n \u003cp\u003e This method may block indefinitely writing to the output stream (or\n reading from the file). The behavior for the case that the output stream\n is \u003ci\u003easynchronously closed\u003c/i\u003e or the thread interrupted during the copy\n is highly output stream and file system provider specific and therefore\n not specified.\n\n \u003cp\u003e Note that if the given output stream is {@link java.io.Flushable}\n then its {@link java.io.Flushable#flush flush} method may need to invoked\n after this method completes so as to flush any buffered output.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.nio.file.Path, java.io.OutputStream)","flatSignature":"(Path, OutputStream)","returnType":{"isPrimitive":true,"simpleName":"long","qualifiedName":"long","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"source","type":{"isPrimitive":false,"simpleName":"Path","qualifiedName":"java.nio.file.Path","dimension":"","elementType":{}}},{"name":"out","type":{"isPrimitive":false,"simpleName":"OutputStream","qualifiedName":"java.io.OutputStream","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"readAllBytes","comment":"Reads all the bytes from a file. The method ensures that the file is\n closed when all bytes have been read or an I/O error, or other runtime\n exception, is thrown.\n\n \u003cp\u003e Note that this method is intended for simple cases where it is\n convenient to read all bytes into a byte array. It is not intended for\n reading in large files.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.nio.file.Path)","flatSignature":"(Path)","returnType":{"isPrimitive":true,"simpleName":"byte","qualifiedName":"byte","dimension":"[]","elementType":{"isPrimitive":true,"simpleName":"byte","qualifiedName":"byte","dimension":"","elementType":{}}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"path","type":{"isPrimitive":false,"simpleName":"Path","qualifiedName":"java.nio.file.Path","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"readAllLines","comment":"Read all lines from a file. This method ensures that the file is\n closed when all bytes have been read or an I/O error, or other runtime\n exception, is thrown. Bytes from the file are decoded into characters\n using the specified charset.\n\n \u003cp\u003e This method recognizes the following as line terminators:\n \u003cul\u003e\n   \u003cli\u003e \u003ccode\u003e\u0026#92;u000D\u003c/code\u003e followed by \u003ccode\u003e\u0026#92;u000A\u003c/code\u003e,\n     CARRIAGE RETURN followed by LINE FEED \u003c/li\u003e\n   \u003cli\u003e \u003ccode\u003e\u0026#92;u000A\u003c/code\u003e, LINE FEED \u003c/li\u003e\n   \u003cli\u003e \u003ccode\u003e\u0026#92;u000D\u003c/code\u003e, CARRIAGE RETURN \u003c/li\u003e\n \u003c/ul\u003e\n \u003cp\u003e Additional Unicode line terminators may be recognized in future\n releases.\n\n \u003cp\u003e Note that this method is intended for simple cases where it is\n convenient to read all lines in a single operation. It is not intended\n for reading in large files.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.nio.file.Path, java.nio.charset.Charset)","flatSignature":"(Path, Charset)","returnType":{"isPrimitive":false,"simpleName":"List","qualifiedName":"java.util.List","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"path","type":{"isPrimitive":false,"simpleName":"Path","qualifiedName":"java.nio.file.Path","dimension":"","elementType":{}}},{"name":"cs","type":{"isPrimitive":false,"simpleName":"Charset","qualifiedName":"java.nio.charset.Charset","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"readAllLines","comment":"Read all lines from a file. Bytes from the file are decoded into characters\n using the {@link StandardCharsets#UTF_8 UTF-8} {@link Charset charset}.\n\n \u003cp\u003e This method works as if invoking it were equivalent to evaluating the\n expression:\n \u003cpre\u003e{@code\n Files.readAllLines(path, StandardCharsets.UTF_8)\n }\u003c/pre\u003e","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.nio.file.Path)","flatSignature":"(Path)","returnType":{"isPrimitive":false,"simpleName":"List","qualifiedName":"java.util.List","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"path","type":{"isPrimitive":false,"simpleName":"Path","qualifiedName":"java.nio.file.Path","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"write","comment":"Writes bytes to a file. The {@code options} parameter specifies how the\n the file is created or opened. If no options are present then this method\n works as if the {@link StandardOpenOption#CREATE CREATE}, {@link\n StandardOpenOption#TRUNCATE_EXISTING TRUNCATE_EXISTING}, and {@link\n StandardOpenOption#WRITE WRITE} options are present. In other words, it\n opens the file for writing, creating the file if it doesn\u0027t exist, or\n initially truncating an existing {@link #isRegularFile regular-file} to\n a size of {@code 0}. All bytes in the byte array are written to the file.\n The method ensures that the file is closed when all bytes have been\n written (or an I/O error or other runtime exception is thrown). If an I/O\n error occurs then it may do so after the file has created or truncated,\n or after some bytes have been written to the file.\n\n \u003cp\u003e \u003cb\u003eUsage example\u003c/b\u003e: By default the method creates a new file or\n overwrites an existing file. Suppose you instead want to append bytes\n to an existing file:\n \u003cpre\u003e\n     Path path \u003d ...\n     byte[] bytes \u003d ...\n     Files.write(path, bytes, StandardOpenOption.APPEND);\n \u003c/pre\u003e","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.nio.file.Path, byte[], java.nio.file.OpenOption...)","flatSignature":"(Path, byte[], OpenOption...)","returnType":{"isPrimitive":false,"simpleName":"Path","qualifiedName":"java.nio.file.Path","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"path","type":{"isPrimitive":false,"simpleName":"Path","qualifiedName":"java.nio.file.Path","dimension":"","elementType":{}}},{"name":"bytes","type":{"isPrimitive":true,"simpleName":"byte","qualifiedName":"byte","dimension":"[]","elementType":{"isPrimitive":true,"simpleName":"byte","qualifiedName":"byte","dimension":"","elementType":{}}}},{"name":"options","type":{"isPrimitive":false,"simpleName":"OpenOption","qualifiedName":"java.nio.file.OpenOption","dimension":"[]","elementType":{"isPrimitive":false,"simpleName":"OpenOption","qualifiedName":"java.nio.file.OpenOption","dimension":"","elementType":{}}}}],"typeParameters":[]},{"name":"write","comment":"Write lines of text to a file. Each line is a char sequence and is\n written to the file in sequence with each line terminated by the\n platform\u0027s line separator, as defined by the system property {@code\n line.separator}. Characters are encoded into bytes using the specified\n charset.\n\n \u003cp\u003e The {@code options} parameter specifies how the the file is created\n or opened. If no options are present then this method works as if the\n {@link StandardOpenOption#CREATE CREATE}, {@link\n StandardOpenOption#TRUNCATE_EXISTING TRUNCATE_EXISTING}, and {@link\n StandardOpenOption#WRITE WRITE} options are present. In other words, it\n opens the file for writing, creating the file if it doesn\u0027t exist, or\n initially truncating an existing {@link #isRegularFile regular-file} to\n a size of {@code 0}. The method ensures that the file is closed when all\n lines have been written (or an I/O error or other runtime exception is\n thrown). If an I/O error occurs then it may do so after the file has\n created or truncated, or after some bytes have been written to the file.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.nio.file.Path, java.lang.Iterable\u003c? extends java.lang.CharSequence\u003e, java.nio.charset.Charset, java.nio.file.OpenOption...)","flatSignature":"(Path, Iterable\u003c? extends CharSequence\u003e, Charset, OpenOption...)","returnType":{"isPrimitive":false,"simpleName":"Path","qualifiedName":"java.nio.file.Path","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"path","type":{"isPrimitive":false,"simpleName":"Path","qualifiedName":"java.nio.file.Path","dimension":"","elementType":{}}},{"name":"lines","type":{"isPrimitive":false,"simpleName":"Iterable","qualifiedName":"java.lang.Iterable","dimension":"","elementType":{}}},{"name":"cs","type":{"isPrimitive":false,"simpleName":"Charset","qualifiedName":"java.nio.charset.Charset","dimension":"","elementType":{}}},{"name":"options","type":{"isPrimitive":false,"simpleName":"OpenOption","qualifiedName":"java.nio.file.OpenOption","dimension":"[]","elementType":{"isPrimitive":false,"simpleName":"OpenOption","qualifiedName":"java.nio.file.OpenOption","dimension":"","elementType":{}}}}],"typeParameters":[]},{"name":"write","comment":"Write lines of text to a file. Characters are encoded into bytes using\n the {@link StandardCharsets#UTF_8 UTF-8} {@link Charset charset}.\n\n \u003cp\u003e This method works as if invoking it were equivalent to evaluating the\n expression:\n \u003cpre\u003e{@code\n Files.write(path, lines, StandardCharsets.UTF_8, options);\n }\u003c/pre\u003e","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.nio.file.Path, java.lang.Iterable\u003c? extends java.lang.CharSequence\u003e, java.nio.file.OpenOption...)","flatSignature":"(Path, Iterable\u003c? extends CharSequence\u003e, OpenOption...)","returnType":{"isPrimitive":false,"simpleName":"Path","qualifiedName":"java.nio.file.Path","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"path","type":{"isPrimitive":false,"simpleName":"Path","qualifiedName":"java.nio.file.Path","dimension":"","elementType":{}}},{"name":"lines","type":{"isPrimitive":false,"simpleName":"Iterable","qualifiedName":"java.lang.Iterable","dimension":"","elementType":{}}},{"name":"options","type":{"isPrimitive":false,"simpleName":"OpenOption","qualifiedName":"java.nio.file.OpenOption","dimension":"[]","elementType":{"isPrimitive":false,"simpleName":"OpenOption","qualifiedName":"java.nio.file.OpenOption","dimension":"","elementType":{}}}}],"typeParameters":[]},{"name":"list","comment":"Return a lazily populated {@code Stream}, the elements of\n which are the entries in the directory.  The listing is not recursive.\n\n \u003cp\u003e The elements of the stream are {@link Path} objects that are\n obtained as if by {@link Path#resolve(Path) resolving} the name of the\n directory entry against {@code dir}. Some file systems maintain special\n links to the directory itself and the directory\u0027s parent directory.\n Entries representing these links are not included.\n\n \u003cp\u003e The stream is \u003ci\u003eweakly consistent\u003c/i\u003e. It is thread safe but does\n not freeze the directory while iterating, so it may (or may not)\n reflect updates to the directory that occur after returning from this\n method.\n\n \u003cp\u003e The returned stream encapsulates a {@link DirectoryStream}.\n If timely disposal of file system resources is required, the\n {@code try}-with-resources construct should be used to ensure that the\n stream\u0027s {@link Stream#close close} method is invoked after the stream\n operations are completed.\n\n \u003cp\u003e Operating on a closed stream behaves as if the end of stream\n has been reached. Due to read-ahead, one or more elements may be\n returned after the stream has been closed.\n\n \u003cp\u003e If an {@link IOException} is thrown when accessing the directory\n after this method has returned, it is wrapped in an {@link\n UncheckedIOException} which will be thrown from the method that caused\n the access to take place.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.nio.file.Path)","flatSignature":"(Path)","returnType":{"isPrimitive":false,"simpleName":"Stream","qualifiedName":"java.util.stream.Stream","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"dir","type":{"isPrimitive":false,"simpleName":"Path","qualifiedName":"java.nio.file.Path","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"walk","comment":"Return a {@code Stream} that is lazily populated with {@code\n Path} by walking the file tree rooted at a given starting file.  The\n file tree is traversed \u003cem\u003edepth-first\u003c/em\u003e, the elements in the stream\n are {@link Path} objects that are obtained as if by {@link\n Path#resolve(Path) resolving} the relative path against {@code start}.\n\n \u003cp\u003e The {@code stream} walks the file tree as elements are consumed.\n The {@code Stream} returned is guaranteed to have at least one\n element, the starting file itself. For each file visited, the stream\n attempts to read its {@link BasicFileAttributes}. If the file is a\n directory and can be opened successfully, entries in the directory, and\n their \u003cem\u003edescendants\u003c/em\u003e will follow the directory in the stream as\n they are encountered. When all entries have been visited, then the\n directory is closed. The file tree walk then continues at the next\n \u003cem\u003esibling\u003c/em\u003e of the directory.\n\n \u003cp\u003e The stream is \u003ci\u003eweakly consistent\u003c/i\u003e. It does not freeze the\n file tree while iterating, so it may (or may not) reflect updates to\n the file tree that occur after returned from this method.\n\n \u003cp\u003e By default, symbolic links are not automatically followed by this\n method. If the {@code options} parameter contains the {@link\n FileVisitOption#FOLLOW_LINKS FOLLOW_LINKS} option then symbolic links are\n followed. When following links, and the attributes of the target cannot\n be read, then this method attempts to get the {@code BasicFileAttributes}\n of the link.\n\n \u003cp\u003e If the {@code options} parameter contains the {@link\n FileVisitOption#FOLLOW_LINKS FOLLOW_LINKS} option then the stream keeps\n track of directories visited so that cycles can be detected. A cycle\n arises when there is an entry in a directory that is an ancestor of the\n directory. Cycle detection is done by recording the {@link\n java.nio.file.attribute.BasicFileAttributes#fileKey file-key} of directories,\n or if file keys are not available, by invoking the {@link #isSameFile\n isSameFile} method to test if a directory is the same file as an\n ancestor. When a cycle is detected it is treated as an I/O error with\n an instance of {@link FileSystemLoopException}.\n\n \u003cp\u003e The {@code maxDepth} parameter is the maximum number of levels of\n directories to visit. A value of {@code 0} means that only the starting\n file is visited, unless denied by the security manager. A value of\n {@link Integer#MAX_VALUE MAX_VALUE} may be used to indicate that all\n levels should be visited.\n\n \u003cp\u003e When a security manager is installed and it denies access to a file\n (or directory), then it is ignored and not included in the stream.\n\n \u003cp\u003e The returned stream encapsulates one or more {@link DirectoryStream}s.\n If timely disposal of file system resources is required, the\n {@code try}-with-resources construct should be used to ensure that the\n stream\u0027s {@link Stream#close close} method is invoked after the stream\n operations are completed.  Operating on a closed stream will result in an\n {@link java.lang.IllegalStateException}.\n\n \u003cp\u003e If an {@link IOException} is thrown when accessing the directory\n after this method has returned, it is wrapped in an {@link\n UncheckedIOException} which will be thrown from the method that caused\n the access to take place.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.nio.file.Path, int, java.nio.file.FileVisitOption...)","flatSignature":"(Path, int, FileVisitOption...)","returnType":{"isPrimitive":false,"simpleName":"Stream","qualifiedName":"java.util.stream.Stream","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"start","type":{"isPrimitive":false,"simpleName":"Path","qualifiedName":"java.nio.file.Path","dimension":"","elementType":{}}},{"name":"maxDepth","type":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}}},{"name":"options","type":{"isPrimitive":false,"simpleName":"FileVisitOption","qualifiedName":"java.nio.file.FileVisitOption","dimension":"[]","elementType":{"isPrimitive":false,"simpleName":"FileVisitOption","qualifiedName":"java.nio.file.FileVisitOption","dimension":"","elementType":{}}}}],"typeParameters":[]},{"name":"walk","comment":"Return a {@code Stream} that is lazily populated with {@code\n Path} by walking the file tree rooted at a given starting file.  The\n file tree is traversed \u003cem\u003edepth-first\u003c/em\u003e, the elements in the stream\n are {@link Path} objects that are obtained as if by {@link\n Path#resolve(Path) resolving} the relative path against {@code start}.\n\n \u003cp\u003e This method works as if invoking it were equivalent to evaluating the\n expression:\n \u003cblockquote\u003e\u003cpre\u003e\n walk(start, Integer.MAX_VALUE, options)\n \u003c/pre\u003e\u003c/blockquote\u003e\n In other words, it visits all levels of the file tree.\n\n \u003cp\u003e The returned stream encapsulates one or more {@link DirectoryStream}s.\n If timely disposal of file system resources is required, the\n {@code try}-with-resources construct should be used to ensure that the\n stream\u0027s {@link Stream#close close} method is invoked after the stream\n operations are completed.  Operating on a closed stream will result in an\n {@link java.lang.IllegalStateException}.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.nio.file.Path, java.nio.file.FileVisitOption...)","flatSignature":"(Path, FileVisitOption...)","returnType":{"isPrimitive":false,"simpleName":"Stream","qualifiedName":"java.util.stream.Stream","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"start","type":{"isPrimitive":false,"simpleName":"Path","qualifiedName":"java.nio.file.Path","dimension":"","elementType":{}}},{"name":"options","type":{"isPrimitive":false,"simpleName":"FileVisitOption","qualifiedName":"java.nio.file.FileVisitOption","dimension":"[]","elementType":{"isPrimitive":false,"simpleName":"FileVisitOption","qualifiedName":"java.nio.file.FileVisitOption","dimension":"","elementType":{}}}}],"typeParameters":[]},{"name":"find","comment":"Return a {@code Stream} that is lazily populated with {@code\n Path} by searching for files in a file tree rooted at a given starting\n file.\n\n \u003cp\u003e This method walks the file tree in exactly the manner specified by\n the {@link #walk walk} method. For each file encountered, the given\n {@link BiPredicate} is invoked with its {@link Path} and {@link\n BasicFileAttributes}. The {@code Path} object is obtained as if by\n {@link Path#resolve(Path) resolving} the relative path against {@code\n start} and is only included in the returned {@link Stream} if\n the {@code BiPredicate} returns true. Compare to calling {@link\n java.util.stream.Stream#filter filter} on the {@code Stream}\n returned by {@code walk} method, this method may be more efficient by\n avoiding redundant retrieval of the {@code BasicFileAttributes}.\n\n \u003cp\u003e The returned stream encapsulates one or more {@link DirectoryStream}s.\n If timely disposal of file system resources is required, the\n {@code try}-with-resources construct should be used to ensure that the\n stream\u0027s {@link Stream#close close} method is invoked after the stream\n operations are completed.  Operating on a closed stream will result in an\n {@link java.lang.IllegalStateException}.\n\n \u003cp\u003e If an {@link IOException} is thrown when accessing the directory\n after returned from this method, it is wrapped in an {@link\n UncheckedIOException} which will be thrown from the method that caused\n the access to take place.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.nio.file.Path, int, java.util.function.BiPredicate\u003cjava.nio.file.Path, java.nio.file.attribute.BasicFileAttributes\u003e, java.nio.file.FileVisitOption...)","flatSignature":"(Path, int, BiPredicate\u003cPath, BasicFileAttributes\u003e, FileVisitOption...)","returnType":{"isPrimitive":false,"simpleName":"Stream","qualifiedName":"java.util.stream.Stream","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"start","type":{"isPrimitive":false,"simpleName":"Path","qualifiedName":"java.nio.file.Path","dimension":"","elementType":{}}},{"name":"maxDepth","type":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}}},{"name":"matcher","type":{"isPrimitive":false,"simpleName":"BiPredicate","qualifiedName":"java.util.function.BiPredicate","dimension":"","elementType":{}}},{"name":"options","type":{"isPrimitive":false,"simpleName":"FileVisitOption","qualifiedName":"java.nio.file.FileVisitOption","dimension":"[]","elementType":{"isPrimitive":false,"simpleName":"FileVisitOption","qualifiedName":"java.nio.file.FileVisitOption","dimension":"","elementType":{}}}}],"typeParameters":[]},{"name":"lines","comment":"Read all lines from a file as a {@code Stream}. Unlike {@link\n #readAllLines(Path, Charset) readAllLines}, this method does not read\n all lines into a {@code List}, but instead populates lazily as the stream\n is consumed.\n\n \u003cp\u003e Bytes from the file are decoded into characters using the specified\n charset and the same line terminators as specified by {@code\n readAllLines} are supported.\n\n \u003cp\u003e After this method returns, then any subsequent I/O exception that\n occurs while reading from the file or when a malformed or unmappable byte\n sequence is read, is wrapped in an {@link UncheckedIOException} that will\n be thrown from the\n {@link java.util.stream.Stream} method that caused the read to take\n place. In case an {@code IOException} is thrown when closing the file,\n it is also wrapped as an {@code UncheckedIOException}.\n\n \u003cp\u003e The returned stream encapsulates a {@link Reader}.  If timely\n disposal of file system resources is required, the try-with-resources\n construct should be used to ensure that the stream\u0027s\n {@link Stream#close close} method is invoked after the stream operations\n are completed.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.nio.file.Path, java.nio.charset.Charset)","flatSignature":"(Path, Charset)","returnType":{"isPrimitive":false,"simpleName":"Stream","qualifiedName":"java.util.stream.Stream","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"path","type":{"isPrimitive":false,"simpleName":"Path","qualifiedName":"java.nio.file.Path","dimension":"","elementType":{}}},{"name":"cs","type":{"isPrimitive":false,"simpleName":"Charset","qualifiedName":"java.nio.charset.Charset","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"lines","comment":"Read all lines from a file as a {@code Stream}. Bytes from the file are\n decoded into characters using the {@link StandardCharsets#UTF_8 UTF-8}\n {@link Charset charset}.\n\n \u003cp\u003e This method works as if invoking it were equivalent to evaluating the\n expression:\n \u003cpre\u003e{@code\n Files.lines(path, StandardCharsets.UTF_8)\n }\u003c/pre\u003e","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.nio.file.Path)","flatSignature":"(Path)","returnType":{"isPrimitive":false,"simpleName":"Stream","qualifiedName":"java.util.stream.Stream","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"path","type":{"isPrimitive":false,"simpleName":"Path","qualifiedName":"java.nio.file.Path","dimension":"","elementType":{}}}],"typeParameters":[]}],"typeParameters":[],"enumConstants":[]}