{"name":"Path","comment":"An object that may be used to locate a file in a file system. It will\n typically represent a system dependent file path.\n\n \u003cp\u003e A {@code Path} represents a path that is hierarchical and composed of a\n sequence of directory and file name elements separated by a special separator\n or delimiter. A \u003cem\u003eroot component\u003c/em\u003e, that identifies a file system\n hierarchy, may also be present. The name element that is \u003cem\u003efarthest\u003c/em\u003e\n from the root of the directory hierarchy is the name of a file or directory.\n The other name elements are directory names. A {@code Path} can represent a\n root, a root and a sequence of names, or simply one or more name elements.\n A {@code Path} is considered to be an \u003ci\u003eempty path\u003c/i\u003e if it consists\n solely of one name element that is empty. Accessing a file using an\n \u003ci\u003eempty path\u003c/i\u003e is equivalent to accessing the default directory of the\n file system. {@code Path} defines the {@link #getFileName() getFileName},\n {@link #getParent getParent}, {@link #getRoot getRoot}, and {@link #subpath\n subpath} methods to access the path components or a subsequence of its name\n elements.\n\n \u003cp\u003e In addition to accessing the components of a path, a {@code Path} also\n defines the {@link #resolve(Path) resolve} and {@link #resolveSibling(Path)\n resolveSibling} methods to combine paths. The {@link #relativize relativize}\n method that can be used to construct a relative path between two paths.\n Paths can be {@link #compareTo compared}, and tested against each other using\n the {@link #startsWith startsWith} and {@link #endsWith endsWith} methods.\n\n \u003cp\u003e This interface extends {@link Watchable} interface so that a directory\n located by a path can be {@link #register registered} with a {@link\n WatchService} and entries in the directory watched. \u003c/p\u003e\n\n \u003cp\u003e \u003cb\u003eWARNING:\u003c/b\u003e This interface is only intended to be implemented by\n those developing custom file system implementations. Methods may be added to\n this interface in future releases. \u003c/p\u003e\n\n \u003ch2\u003eAccessing Files\u003c/h2\u003e\n \u003cp\u003e Paths may be used with the {@link Files} class to operate on files,\n directories, and other types of files. For example, suppose we want a {@link\n java.io.BufferedReader} to read text from a file \"{@code access.log}\". The\n file is located in a directory \"{@code logs}\" relative to the current working\n directory and is UTF-8 encoded.\n \u003cpre\u003e\n     Path path \u003d FileSystems.getDefault().getPath(\"logs\", \"access.log\");\n     BufferedReader reader \u003d Files.newBufferedReader(path, StandardCharsets.UTF_8);\n \u003c/pre\u003e\n\n \u003ca name\u003d\"interop\"\u003e\u003c/a\u003e\u003ch2\u003eInteroperability\u003c/h2\u003e\n \u003cp\u003e Paths associated with the default {@link\n java.nio.file.spi.FileSystemProvider provider} are generally interoperable\n with the {@link java.io.File java.io.File} class. Paths created by other\n providers are unlikely to be interoperable with the abstract path names\n represented by {@code java.io.File}. The {@link java.io.File#toPath toPath}\n method may be used to obtain a {@code Path} from the abstract path name\n represented by a {@code java.io.File} object. The resulting {@code Path} can\n be used to operate on the same file as the {@code java.io.File} object. In\n addition, the {@link #toFile toFile} method is useful to construct a {@code\n File} from the {@code String} representation of a {@code Path}.\n\n \u003ch2\u003eConcurrency\u003c/h2\u003e\n \u003cp\u003e Implementations of this interface are immutable and safe for use by\n multiple concurrent threads.","isClass":false,"isInterface":true,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":false,"isOrdinaryClass":false,"isPrimitive":false,"simpleName":"Path","qualifiedName":"java.nio.file.Path","dimension":"","elementType":{},"package":"java.nio.file","interfaces":["java.lang.Comparable","java.lang.Iterable","java.nio.file.Watchable"],"isAbstract":true,"isStatic":false,"since":"1.7","innerClasses":[],"isInnerClass":false,"constructors":[],"fields":[],"methods":[{"name":"getFileSystem","comment":"Returns the file system that created this object.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":false,"simpleName":"FileSystem","qualifiedName":"java.nio.file.FileSystem","dimension":"","elementType":{}},"isAbstract":true,"isDefault":false,"isStatic":false,"parameters":[],"typeParameters":[]},{"name":"isAbsolute","comment":"Tells whether or not this path is absolute.\n\n \u003cp\u003e An absolute path is complete in that it doesn\u0027t need to be combined\n with other path information in order to locate a file.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":true,"simpleName":"boolean","qualifiedName":"boolean","dimension":"","elementType":{}},"isAbstract":true,"isDefault":false,"isStatic":false,"parameters":[],"typeParameters":[]},{"name":"getRoot","comment":"Returns the root component of this path as a {@code Path} object,\n or {@code null} if this path does not have a root component.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":false,"simpleName":"Path","qualifiedName":"java.nio.file.Path","dimension":"","elementType":{}},"isAbstract":true,"isDefault":false,"isStatic":false,"parameters":[],"typeParameters":[]},{"name":"getFileName","comment":"Returns the name of the file or directory denoted by this path as a\n {@code Path} object. The file name is the \u003cem\u003efarthest\u003c/em\u003e element from\n the root in the directory hierarchy.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":false,"simpleName":"Path","qualifiedName":"java.nio.file.Path","dimension":"","elementType":{}},"isAbstract":true,"isDefault":false,"isStatic":false,"parameters":[],"typeParameters":[]},{"name":"getParent","comment":"Returns the \u003cem\u003eparent path\u003c/em\u003e, or {@code null} if this path does not\n have a parent.\n\n \u003cp\u003e The parent of this path object consists of this path\u0027s root\n component, if any, and each element in the path except for the\n \u003cem\u003efarthest\u003c/em\u003e from the root in the directory hierarchy. This method\n does not access the file system; the path or its parent may not exist.\n Furthermore, this method does not eliminate special names such as \".\"\n and \"..\" that may be used in some implementations. On UNIX for example,\n the parent of \"{@code /a/b/c}\" is \"{@code /a/b}\", and the parent of\n {@code \"x/y/.}\" is \"{@code x/y}\". This method may be used with the {@link\n #normalize normalize} method, to eliminate redundant names, for cases where\n \u003cem\u003eshell-like\u003c/em\u003e navigation is required.\n\n \u003cp\u003e If this path has one or more elements, and no root component, then\n this method is equivalent to evaluating the expression:\n \u003cblockquote\u003e\u003cpre\u003e\n subpath(0,\u0026nbsp;getNameCount()-1);\n \u003c/pre\u003e\u003c/blockquote\u003e","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":false,"simpleName":"Path","qualifiedName":"java.nio.file.Path","dimension":"","elementType":{}},"isAbstract":true,"isDefault":false,"isStatic":false,"parameters":[],"typeParameters":[]},{"name":"getNameCount","comment":"Returns the number of name elements in the path.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}},"isAbstract":true,"isDefault":false,"isStatic":false,"parameters":[],"typeParameters":[]},{"name":"getName","comment":"Returns a name element of this path as a {@code Path} object.\n\n \u003cp\u003e The {@code index} parameter is the index of the name element to return.\n The element that is \u003cem\u003eclosest\u003c/em\u003e to the root in the directory hierarchy\n has index {@code 0}. The element that is \u003cem\u003efarthest\u003c/em\u003e from the root\n has index {@link #getNameCount count}{@code -1}.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(int)","flatSignature":"(int)","returnType":{"isPrimitive":false,"simpleName":"Path","qualifiedName":"java.nio.file.Path","dimension":"","elementType":{}},"isAbstract":true,"isDefault":false,"isStatic":false,"parameters":[{"name":"index","type":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"subpath","comment":"Returns a relative {@code Path} that is a subsequence of the name\n elements of this path.\n\n \u003cp\u003e The {@code beginIndex} and {@code endIndex} parameters specify the\n subsequence of name elements. The name that is \u003cem\u003eclosest\u003c/em\u003e to the root\n in the directory hierarchy has index {@code 0}. The name that is\n \u003cem\u003efarthest\u003c/em\u003e from the root has index {@link #getNameCount\n count}{@code -1}. The returned {@code Path} object has the name elements\n that begin at {@code beginIndex} and extend to the element at index {@code\n endIndex-1}.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(int, int)","flatSignature":"(int, int)","returnType":{"isPrimitive":false,"simpleName":"Path","qualifiedName":"java.nio.file.Path","dimension":"","elementType":{}},"isAbstract":true,"isDefault":false,"isStatic":false,"parameters":[{"name":"beginIndex","type":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}}},{"name":"endIndex","type":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"startsWith","comment":"Tests if this path starts with the given path.\n\n \u003cp\u003e This path \u003cem\u003estarts\u003c/em\u003e with the given path if this path\u0027s root\n component \u003cem\u003estarts\u003c/em\u003e with the root component of the given path,\n and this path starts with the same name elements as the given path.\n If the given path has more name elements than this path then {@code false}\n is returned.\n\n \u003cp\u003e Whether or not the root component of this path starts with the root\n component of the given path is file system specific. If this path does\n not have a root component and the given path has a root component then\n this path does not start with the given path.\n\n \u003cp\u003e If the given path is associated with a different {@code FileSystem}\n to this path then {@code false} is returned.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.nio.file.Path)","flatSignature":"(Path)","returnType":{"isPrimitive":true,"simpleName":"boolean","qualifiedName":"boolean","dimension":"","elementType":{}},"isAbstract":true,"isDefault":false,"isStatic":false,"parameters":[{"name":"other","type":{"isPrimitive":false,"simpleName":"Path","qualifiedName":"java.nio.file.Path","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"startsWith","comment":"Tests if this path starts with a {@code Path}, constructed by converting\n the given path string, in exactly the manner specified by the {@link\n #startsWith(Path) startsWith(Path)} method. On UNIX for example, the path\n \"{@code foo/bar}\" starts with \"{@code foo}\" and \"{@code foo/bar}\". It\n does not start with \"{@code f}\" or \"{@code fo}\".","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.lang.String)","flatSignature":"(String)","returnType":{"isPrimitive":true,"simpleName":"boolean","qualifiedName":"boolean","dimension":"","elementType":{}},"isAbstract":true,"isDefault":false,"isStatic":false,"parameters":[{"name":"other","type":{"isPrimitive":false,"simpleName":"String","qualifiedName":"java.lang.String","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"endsWith","comment":"Tests if this path ends with the given path.\n\n \u003cp\u003e If the given path has \u003cem\u003eN\u003c/em\u003e elements, and no root component,\n and this path has \u003cem\u003eN\u003c/em\u003e or more elements, then this path ends with\n the given path if the last \u003cem\u003eN\u003c/em\u003e elements of each path, starting at\n the element farthest from the root, are equal.\n\n \u003cp\u003e If the given path has a root component then this path ends with the\n given path if the root component of this path \u003cem\u003eends with\u003c/em\u003e the root\n component of the given path, and the corresponding elements of both paths\n are equal. Whether or not the root component of this path ends with the\n root component of the given path is file system specific. If this path\n does not have a root component and the given path has a root component\n then this path does not end with the given path.\n\n \u003cp\u003e If the given path is associated with a different {@code FileSystem}\n to this path then {@code false} is returned.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.nio.file.Path)","flatSignature":"(Path)","returnType":{"isPrimitive":true,"simpleName":"boolean","qualifiedName":"boolean","dimension":"","elementType":{}},"isAbstract":true,"isDefault":false,"isStatic":false,"parameters":[{"name":"other","type":{"isPrimitive":false,"simpleName":"Path","qualifiedName":"java.nio.file.Path","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"endsWith","comment":"Tests if this path ends with a {@code Path}, constructed by converting\n the given path string, in exactly the manner specified by the {@link\n #endsWith(Path) endsWith(Path)} method. On UNIX for example, the path\n \"{@code foo/bar}\" ends with \"{@code foo/bar}\" and \"{@code bar}\". It does\n not end with \"{@code r}\" or \"{@code /bar}\". Note that trailing separators\n are not taken into account, and so invoking this method on the {@code\n Path}\"{@code foo/bar}\" with the {@code String} \"{@code bar/}\" returns\n {@code true}.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.lang.String)","flatSignature":"(String)","returnType":{"isPrimitive":true,"simpleName":"boolean","qualifiedName":"boolean","dimension":"","elementType":{}},"isAbstract":true,"isDefault":false,"isStatic":false,"parameters":[{"name":"other","type":{"isPrimitive":false,"simpleName":"String","qualifiedName":"java.lang.String","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"normalize","comment":"Returns a path that is this path with redundant name elements eliminated.\n\n \u003cp\u003e The precise definition of this method is implementation dependent but\n in general it derives from this path, a path that does not contain\n \u003cem\u003eredundant\u003c/em\u003e name elements. In many file systems, the \"{@code .}\"\n and \"{@code ..}\" are special names used to indicate the current directory\n and parent directory. In such file systems all occurrences of \"{@code .}\"\n are considered redundant. If a \"{@code ..}\" is preceded by a\n non-\"{@code ..}\" name then both names are considered redundant (the\n process to identify such names is repeated until it is no longer\n applicable).\n\n \u003cp\u003e This method does not access the file system; the path may not locate\n a file that exists. Eliminating \"{@code ..}\" and a preceding name from a\n path may result in the path that locates a different file than the original\n path. This can arise when the preceding name is a symbolic link.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":false,"simpleName":"Path","qualifiedName":"java.nio.file.Path","dimension":"","elementType":{}},"isAbstract":true,"isDefault":false,"isStatic":false,"parameters":[],"typeParameters":[]},{"name":"resolve","comment":"Resolve the given path against this path.\n\n \u003cp\u003e If the {@code other} parameter is an {@link #isAbsolute() absolute}\n path then this method trivially returns {@code other}. If {@code other}\n is an \u003ci\u003eempty path\u003c/i\u003e then this method trivially returns this path.\n Otherwise this method considers this path to be a directory and resolves\n the given path against this path. In the simplest case, the given path\n does not have a {@link #getRoot root} component, in which case this method\n \u003cem\u003ejoins\u003c/em\u003e the given path to this path and returns a resulting path\n that {@link #endsWith ends} with the given path. Where the given path has\n a root component then resolution is highly implementation dependent and\n therefore unspecified.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.nio.file.Path)","flatSignature":"(Path)","returnType":{"isPrimitive":false,"simpleName":"Path","qualifiedName":"java.nio.file.Path","dimension":"","elementType":{}},"isAbstract":true,"isDefault":false,"isStatic":false,"parameters":[{"name":"other","type":{"isPrimitive":false,"simpleName":"Path","qualifiedName":"java.nio.file.Path","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"resolve","comment":"Converts a given path string to a {@code Path} and resolves it against\n this {@code Path} in exactly the manner specified by the {@link\n #resolve(Path) resolve} method. For example, suppose that the name\n separator is \"{@code /}\" and a path represents \"{@code foo/bar}\", then\n invoking this method with the path string \"{@code gus}\" will result in\n the {@code Path} \"{@code foo/bar/gus}\".","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.lang.String)","flatSignature":"(String)","returnType":{"isPrimitive":false,"simpleName":"Path","qualifiedName":"java.nio.file.Path","dimension":"","elementType":{}},"isAbstract":true,"isDefault":false,"isStatic":false,"parameters":[{"name":"other","type":{"isPrimitive":false,"simpleName":"String","qualifiedName":"java.lang.String","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"resolveSibling","comment":"Resolves the given path against this path\u0027s {@link #getParent parent}\n path. This is useful where a file name needs to be \u003ci\u003ereplaced\u003c/i\u003e with\n another file name. For example, suppose that the name separator is\n \"{@code /}\" and a path represents \"{@code dir1/dir2/foo}\", then invoking\n this method with the {@code Path} \"{@code bar}\" will result in the {@code\n Path} \"{@code dir1/dir2/bar}\". If this path does not have a parent path,\n or {@code other} is {@link #isAbsolute() absolute}, then this method\n returns {@code other}. If {@code other} is an empty path then this method\n returns this path\u0027s parent, or where this path doesn\u0027t have a parent, the\n empty path.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.nio.file.Path)","flatSignature":"(Path)","returnType":{"isPrimitive":false,"simpleName":"Path","qualifiedName":"java.nio.file.Path","dimension":"","elementType":{}},"isAbstract":true,"isDefault":false,"isStatic":false,"parameters":[{"name":"other","type":{"isPrimitive":false,"simpleName":"Path","qualifiedName":"java.nio.file.Path","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"resolveSibling","comment":"Converts a given path string to a {@code Path} and resolves it against\n this path\u0027s {@link #getParent parent} path in exactly the manner\n specified by the {@link #resolveSibling(Path) resolveSibling} method.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.lang.String)","flatSignature":"(String)","returnType":{"isPrimitive":false,"simpleName":"Path","qualifiedName":"java.nio.file.Path","dimension":"","elementType":{}},"isAbstract":true,"isDefault":false,"isStatic":false,"parameters":[{"name":"other","type":{"isPrimitive":false,"simpleName":"String","qualifiedName":"java.lang.String","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"relativize","comment":"Constructs a relative path between this path and a given path.\n\n \u003cp\u003e Relativization is the inverse of {@link #resolve(Path) resolution}.\n This method attempts to construct a {@link #isAbsolute relative} path\n that when {@link #resolve(Path) resolved} against this path, yields a\n path that locates the same file as the given path. For example, on UNIX,\n if this path is {@code \"/a/b\"} and the given path is {@code \"/a/b/c/d\"}\n then the resulting relative path would be {@code \"c/d\"}. Where this\n path and the given path do not have a {@link #getRoot root} component,\n then a relative path can be constructed. A relative path cannot be\n constructed if only one of the paths have a root component. Where both\n paths have a root component then it is implementation dependent if a\n relative path can be constructed. If this path and the given path are\n {@link #equals equal} then an \u003ci\u003eempty path\u003c/i\u003e is returned.\n\n \u003cp\u003e For any two {@link #normalize normalized} paths \u003ci\u003ep\u003c/i\u003e and\n \u003ci\u003eq\u003c/i\u003e, where \u003ci\u003eq\u003c/i\u003e does not have a root component,\n \u003cblockquote\u003e\n   \u003ci\u003ep\u003c/i\u003e\u003ctt\u003e.relativize(\u003c/tt\u003e\u003ci\u003ep\u003c/i\u003e\u003ctt\u003e.resolve(\u003c/tt\u003e\u003ci\u003eq\u003c/i\u003e\u003ctt\u003e)).equals(\u003c/tt\u003e\u003ci\u003eq\u003c/i\u003e\u003ctt\u003e)\u003c/tt\u003e\n \u003c/blockquote\u003e\n\n \u003cp\u003e When symbolic links are supported, then whether the resulting path,\n when resolved against this path, yields a path that can be used to locate\n the {@link Files#isSameFile same} file as {@code other} is implementation\n dependent. For example, if this path is  {@code \"/a/b\"} and the given\n path is {@code \"/a/x\"} then the resulting relative path may be {@code\n \"../x\"}. If {@code \"b\"} is a symbolic link then is implementation\n dependent if {@code \"a/b/../x\"} would locate the same file as {@code \"/a/x\"}.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.nio.file.Path)","flatSignature":"(Path)","returnType":{"isPrimitive":false,"simpleName":"Path","qualifiedName":"java.nio.file.Path","dimension":"","elementType":{}},"isAbstract":true,"isDefault":false,"isStatic":false,"parameters":[{"name":"other","type":{"isPrimitive":false,"simpleName":"Path","qualifiedName":"java.nio.file.Path","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"toUri","comment":"Returns a URI to represent this path.\n\n \u003cp\u003e This method constructs an absolute {@link URI} with a {@link\n URI#getScheme() scheme} equal to the URI scheme that identifies the\n provider. The exact form of the scheme specific part is highly provider\n dependent.\n\n \u003cp\u003e In the case of the default provider, the URI is hierarchical with\n a {@link URI#getPath() path} component that is absolute. The query and\n fragment components are undefined. Whether the authority component is\n defined or not is implementation dependent. There is no guarantee that\n the {@code URI} may be used to construct a {@link java.io.File java.io.File}.\n In particular, if this path represents a Universal Naming Convention (UNC)\n path, then the UNC server name may be encoded in the authority component\n of the resulting URI. In the case of the default provider, and the file\n exists, and it can be determined that the file is a directory, then the\n resulting {@code URI} will end with a slash.\n\n \u003cp\u003e The default provider provides a similar \u003cem\u003eround-trip\u003c/em\u003e guarantee\n to the {@link java.io.File} class. For a given {@code Path} \u003ci\u003ep\u003c/i\u003e it\n is guaranteed that\n \u003cblockquote\u003e\u003ctt\u003e\n {@link Paths#get(URI) Paths.get}(\u003c/tt\u003e\u003ci\u003ep\u003c/i\u003e\u003ctt\u003e.toUri()).equals(\u003c/tt\u003e\u003ci\u003ep\u003c/i\u003e\n \u003ctt\u003e.{@link #toAbsolutePath() toAbsolutePath}())\u003c/tt\u003e\n \u003c/blockquote\u003e\n so long as the original {@code Path}, the {@code URI}, and the new {@code\n Path} are all created in (possibly different invocations of) the same\n Java virtual machine. Whether other providers make any guarantees is\n provider specific and therefore unspecified.\n\n \u003cp\u003e When a file system is constructed to access the contents of a file\n as a file system then it is highly implementation specific if the returned\n URI represents the given path in the file system or it represents a\n \u003cem\u003ecompound\u003c/em\u003e URI that encodes the URI of the enclosing file system.\n A format for compound URIs is not defined in this release; such a scheme\n may be added in a future release.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":false,"simpleName":"URI","qualifiedName":"java.net.URI","dimension":"","elementType":{}},"isAbstract":true,"isDefault":false,"isStatic":false,"parameters":[],"typeParameters":[]},{"name":"toAbsolutePath","comment":"Returns a {@code Path} object representing the absolute path of this\n path.\n\n \u003cp\u003e If this path is already {@link Path#isAbsolute absolute} then this\n method simply returns this path. Otherwise, this method resolves the path\n in an implementation dependent manner, typically by resolving the path\n against a file system default directory. Depending on the implementation,\n this method may throw an I/O error if the file system is not accessible.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":false,"simpleName":"Path","qualifiedName":"java.nio.file.Path","dimension":"","elementType":{}},"isAbstract":true,"isDefault":false,"isStatic":false,"parameters":[],"typeParameters":[]},{"name":"toRealPath","comment":"Returns the \u003cem\u003ereal\u003c/em\u003e path of an existing file.\n\n \u003cp\u003e The precise definition of this method is implementation dependent but\n in general it derives from this path, an {@link #isAbsolute absolute}\n path that locates the {@link Files#isSameFile same} file as this path, but\n with name elements that represent the actual name of the directories\n and the file. For example, where filename comparisons on a file system\n are case insensitive then the name elements represent the names in their\n actual case. Additionally, the resulting path has redundant name\n elements removed.\n\n \u003cp\u003e If this path is relative then its absolute path is first obtained,\n as if by invoking the {@link #toAbsolutePath toAbsolutePath} method.\n\n \u003cp\u003e The {@code options} array may be used to indicate how symbolic links\n are handled. By default, symbolic links are resolved to their final\n target. If the option {@link LinkOption#NOFOLLOW_LINKS NOFOLLOW_LINKS} is\n present then this method does not resolve symbolic links.\n\n Some implementations allow special names such as \"{@code ..}\" to refer to\n the parent directory. When deriving the \u003cem\u003ereal path\u003c/em\u003e, and a\n \"{@code ..}\" (or equivalent) is preceded by a non-\"{@code ..}\" name then\n an implementation will typically cause both names to be removed. When\n not resolving symbolic links and the preceding name is a symbolic link\n then the names are only removed if it guaranteed that the resulting path\n will locate the same file as this path.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.nio.file.LinkOption...)","flatSignature":"(LinkOption...)","returnType":{"isPrimitive":false,"simpleName":"Path","qualifiedName":"java.nio.file.Path","dimension":"","elementType":{}},"isAbstract":true,"isDefault":false,"isStatic":false,"parameters":[{"name":"options","type":{"isPrimitive":false,"simpleName":"LinkOption","qualifiedName":"java.nio.file.LinkOption","dimension":"[]","elementType":{"isPrimitive":false,"simpleName":"LinkOption","qualifiedName":"java.nio.file.LinkOption","dimension":"","elementType":{}}}}],"typeParameters":[]},{"name":"toFile","comment":"Returns a {@link File} object representing this path. Where this {@code\n Path} is associated with the default provider, then this method is\n equivalent to returning a {@code File} object constructed with the\n {@code String} representation of this path.\n\n \u003cp\u003e If this path was created by invoking the {@code File} {@link\n File#toPath toPath} method then there is no guarantee that the {@code\n File} object returned by this method is {@link #equals equal} to the\n original {@code File}.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":false,"simpleName":"File","qualifiedName":"java.io.File","dimension":"","elementType":{}},"isAbstract":true,"isDefault":false,"isStatic":false,"parameters":[],"typeParameters":[]},{"name":"register","comment":"Registers the file located by this path with a watch service.\n\n \u003cp\u003e In this release, this path locates a directory that exists. The\n directory is registered with the watch service so that entries in the\n directory can be watched. The {@code events} parameter is the events to\n register and may contain the following events:\n \u003cul\u003e\n   \u003cli\u003e{@link StandardWatchEventKinds#ENTRY_CREATE ENTRY_CREATE} -\n       entry created or moved into the directory\u003c/li\u003e\n   \u003cli\u003e{@link StandardWatchEventKinds#ENTRY_DELETE ENTRY_DELETE} -\n        entry deleted or moved out of the directory\u003c/li\u003e\n   \u003cli\u003e{@link StandardWatchEventKinds#ENTRY_MODIFY ENTRY_MODIFY} -\n        entry in directory was modified\u003c/li\u003e\n \u003c/ul\u003e\n\n \u003cp\u003e The {@link WatchEvent#context context} for these events is the\n relative path between the directory located by this path, and the path\n that locates the directory entry that is created, deleted, or modified.\n\n \u003cp\u003e The set of events may include additional implementation specific\n event that are not defined by the enum {@link StandardWatchEventKinds}\n\n \u003cp\u003e The {@code modifiers} parameter specifies \u003cem\u003emodifiers\u003c/em\u003e that\n qualify how the directory is registered. This release does not define any\n \u003cem\u003estandard\u003c/em\u003e modifiers. It may contain implementation specific\n modifiers.\n\n \u003cp\u003e Where a file is registered with a watch service by means of a symbolic\n link then it is implementation specific if the watch continues to depend\n on the existence of the symbolic link after it is registered.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.nio.file.WatchService, java.nio.file.WatchEvent.Kind\u003c?\u003e[], java.nio.file.WatchEvent.Modifier...)","flatSignature":"(WatchService, WatchEvent.Kind\u003c?\u003e[], WatchEvent.Modifier...)","returnType":{"isPrimitive":false,"simpleName":"WatchKey","qualifiedName":"java.nio.file.WatchKey","dimension":"","elementType":{}},"isAbstract":true,"isDefault":false,"isStatic":false,"parameters":[{"name":"watcher","type":{"isPrimitive":false,"simpleName":"WatchService","qualifiedName":"java.nio.file.WatchService","dimension":"","elementType":{}}},{"name":"events","type":{"isPrimitive":false,"simpleName":"Kind","qualifiedName":"java.nio.file.WatchEvent.Kind","dimension":"[]","elementType":{"isPrimitive":false,"simpleName":"Kind","qualifiedName":"java.nio.file.WatchEvent.Kind","dimension":"","elementType":{}}}},{"name":"modifiers","type":{"isPrimitive":false,"simpleName":"Modifier","qualifiedName":"java.nio.file.WatchEvent.Modifier","dimension":"[]","elementType":{"isPrimitive":false,"simpleName":"Modifier","qualifiedName":"java.nio.file.WatchEvent.Modifier","dimension":"","elementType":{}}}}],"typeParameters":[]},{"name":"register","comment":"Registers the file located by this path with a watch service.\n\n \u003cp\u003e An invocation of this method behaves in exactly the same way as the\n invocation\n \u003cpre\u003e\n     watchable.{@link #register(WatchService,WatchEvent.Kind[],WatchEvent.Modifier[]) register}(watcher, events, new WatchEvent.Modifier[0]);\n \u003c/pre\u003e\n\n \u003cp\u003e \u003cb\u003eUsage Example:\u003c/b\u003e\n Suppose we wish to register a directory for entry create, delete, and modify\n events:\n \u003cpre\u003e\n     Path dir \u003d ...\n     WatchService watcher \u003d ...\n\n     WatchKey key \u003d dir.register(watcher, ENTRY_CREATE, ENTRY_DELETE, ENTRY_MODIFY);\n \u003c/pre\u003e","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.nio.file.WatchService, java.nio.file.WatchEvent.Kind\u003c?\u003e...)","flatSignature":"(WatchService, WatchEvent.Kind\u003c?\u003e...)","returnType":{"isPrimitive":false,"simpleName":"WatchKey","qualifiedName":"java.nio.file.WatchKey","dimension":"","elementType":{}},"isAbstract":true,"isDefault":false,"isStatic":false,"parameters":[{"name":"watcher","type":{"isPrimitive":false,"simpleName":"WatchService","qualifiedName":"java.nio.file.WatchService","dimension":"","elementType":{}}},{"name":"events","type":{"isPrimitive":false,"simpleName":"Kind","qualifiedName":"java.nio.file.WatchEvent.Kind","dimension":"[]","elementType":{"isPrimitive":false,"simpleName":"Kind","qualifiedName":"java.nio.file.WatchEvent.Kind","dimension":"","elementType":{}}}}],"typeParameters":[]},{"name":"iterator","comment":"Returns an iterator over the name elements of this path.\n\n \u003cp\u003e The first element returned by the iterator represents the name\n element that is closest to the root in the directory hierarchy, the\n second element is the next closest, and so on. The last element returned\n is the name of the file or directory denoted by this path. The {@link\n #getRoot root} component, if present, is not returned by the iterator.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":false,"simpleName":"Iterator","qualifiedName":"java.util.Iterator","dimension":"","elementType":{}},"isAbstract":true,"isDefault":false,"isStatic":false,"parameters":[],"typeParameters":[]},{"name":"compareTo","comment":"Compares two abstract paths lexicographically. The ordering defined by\n this method is provider specific, and in the case of the default\n provider, platform specific. This method does not access the file system\n and neither file is required to exist.\n\n \u003cp\u003e This method may not be used to compare paths that are associated\n with different file system providers.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.nio.file.Path)","flatSignature":"(Path)","returnType":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}},"isAbstract":true,"isDefault":false,"isStatic":false,"parameters":[{"name":"other","type":{"isPrimitive":false,"simpleName":"Path","qualifiedName":"java.nio.file.Path","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"equals","comment":"Tests this path for equality with the given object.\n\n \u003cp\u003e If the given object is not a Path, or is a Path associated with a\n different {@code FileSystem}, then this method returns {@code false}.\n\n \u003cp\u003e Whether or not two path are equal depends on the file system\n implementation. In some cases the paths are compared without regard\n to case, and others are case sensitive. This method does not access the\n file system and the file is not required to exist. Where required, the\n {@link Files#isSameFile isSameFile} method may be used to check if two\n paths locate the same file.\n\n \u003cp\u003e This method satisfies the general contract of the {@link\n java.lang.Object#equals(Object) Object.equals} method. \u003c/p\u003e","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.lang.Object)","flatSignature":"(Object)","returnType":{"isPrimitive":true,"simpleName":"boolean","qualifiedName":"boolean","dimension":"","elementType":{}},"isAbstract":true,"isDefault":false,"isStatic":false,"parameters":[{"name":"other","type":{"isPrimitive":false,"simpleName":"Object","qualifiedName":"java.lang.Object","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"hashCode","comment":"Computes a hash code for this path.\n\n \u003cp\u003e The hash code is based upon the components of the path, and\n satisfies the general contract of the {@link Object#hashCode\n Object.hashCode} method.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}},"isAbstract":true,"isDefault":false,"isStatic":false,"parameters":[],"typeParameters":[]},{"name":"toString","comment":"Returns the string representation of this path.\n\n \u003cp\u003e If this path was created by converting a path string using the\n {@link FileSystem#getPath getPath} method then the path string returned\n by this method may differ from the original String used to create the path.\n\n \u003cp\u003e The returned path string uses the default name {@link\n FileSystem#getSeparator separator} to separate names in the path.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":false,"simpleName":"String","qualifiedName":"java.lang.String","dimension":"","elementType":{}},"isAbstract":true,"isDefault":false,"isStatic":false,"parameters":[],"typeParameters":[]}],"typeParameters":[],"enumConstants":[]}