{"name":"Paths","comment":"This class consists exclusively of static methods that return a {@link Path}\n by converting a path string or {@link URI}.","isClass":true,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":false,"isOrdinaryClass":true,"isPrimitive":false,"simpleName":"Paths","qualifiedName":"java.nio.file.Paths","dimension":"","elementType":{},"package":"java.nio.file","superclass":"java.lang.Object","interfaces":[],"isAbstract":false,"isStatic":false,"since":"1.7","innerClasses":[],"isInnerClass":false,"constructors":[],"fields":[],"methods":[{"name":"get","comment":"Converts a path string, or a sequence of strings that when joined form\n a path string, to a {@code Path}. If {@code more} does not specify any\n elements then the value of the {@code first} parameter is the path string\n to convert. If {@code more} specifies one or more elements then each\n non-empty string, including {@code first}, is considered to be a sequence\n of name elements (see {@link Path}) and is joined to form a path string.\n The details as to how the Strings are joined is provider specific but\n typically they will be joined using the {@link FileSystem#getSeparator\n name-separator} as the separator. For example, if the name separator is\n \"{@code /}\" and {@code getPath(\"/foo\",\"bar\",\"gus\")} is invoked, then the\n path string {@code \"/foo/bar/gus\"} is converted to a {@code Path}.\n A {@code Path} representing an empty path is returned if {@code first}\n is the empty string and {@code more} does not contain any non-empty\n strings.\n\n \u003cp\u003e The {@code Path} is obtained by invoking the {@link FileSystem#getPath\n getPath} method of the {@link FileSystems#getDefault default} {@link\n FileSystem}.\n\n \u003cp\u003e Note that while this method is very convenient, using it will imply\n an assumed reference to the default {@code FileSystem} and limit the\n utility of the calling code. Hence it should not be used in library code\n intended for flexible reuse. A more flexible alternative is to use an\n existing {@code Path} instance as an anchor, such as:\n \u003cpre\u003e\n     Path dir \u003d ...\n     Path path \u003d dir.resolve(\"file\");\n \u003c/pre\u003e","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.lang.String, java.lang.String...)","flatSignature":"(String, String...)","returnType":{"isPrimitive":false,"simpleName":"Path","qualifiedName":"java.nio.file.Path","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"first","type":{"isPrimitive":false,"simpleName":"String","qualifiedName":"java.lang.String","dimension":"","elementType":{}}},{"name":"more","type":{"isPrimitive":false,"simpleName":"String","qualifiedName":"java.lang.String","dimension":"[]","elementType":{"isPrimitive":false,"simpleName":"String","qualifiedName":"java.lang.String","dimension":"","elementType":{}}}}],"typeParameters":[]},{"name":"get","comment":"Converts the given URI to a {@link Path} object.\n\n \u003cp\u003e This method iterates over the {@link FileSystemProvider#installedProviders()\n installed} providers to locate the provider that is identified by the\n URI {@link URI#getScheme scheme} of the given URI. URI schemes are\n compared without regard to case. If the provider is found then its {@link\n FileSystemProvider#getPath getPath} method is invoked to convert the\n URI.\n\n \u003cp\u003e In the case of the default provider, identified by the URI scheme\n \"file\", the given URI has a non-empty path component, and undefined query\n and fragment components. Whether the authority component may be present\n is platform specific. The returned {@code Path} is associated with the\n {@link FileSystems#getDefault default} file system.\n\n \u003cp\u003e The default provider provides a similar \u003cem\u003eround-trip\u003c/em\u003e guarantee\n to the {@link java.io.File} class. For a given {@code Path} \u003ci\u003ep\u003c/i\u003e it\n is guaranteed that\n \u003cblockquote\u003e\u003ctt\u003e\n Paths.get(\u003c/tt\u003e\u003ci\u003ep\u003c/i\u003e\u003ctt\u003e.{@link Path#toUri() toUri}()).equals(\u003c/tt\u003e\n \u003ci\u003ep\u003c/i\u003e\u003ctt\u003e.{@link Path#toAbsolutePath() toAbsolutePath}())\u003c/tt\u003e\n \u003c/blockquote\u003e\n so long as the original {@code Path}, the {@code URI}, and the new {@code\n Path} are all created in (possibly different invocations of) the same\n Java virtual machine. Whether other providers make any guarantees is\n provider specific and therefore unspecified.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.net.URI)","flatSignature":"(URI)","returnType":{"isPrimitive":false,"simpleName":"Path","qualifiedName":"java.nio.file.Path","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"uri","type":{"isPrimitive":false,"simpleName":"URI","qualifiedName":"java.net.URI","dimension":"","elementType":{}}}],"typeParameters":[]}],"typeParameters":[],"enumConstants":[]}