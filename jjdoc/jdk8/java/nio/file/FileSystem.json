{"name":"FileSystem","comment":"Provides an interface to a file system and is the factory for objects to\n access files and other objects in the file system.\n\n \u003cp\u003e The default file system, obtained by invoking the {@link FileSystems#getDefault\n FileSystems.getDefault} method, provides access to the file system that is\n accessible to the Java virtual machine. The {@link FileSystems} class defines\n methods to create file systems that provide access to other types of (custom)\n file systems.\n\n \u003cp\u003e A file system is the factory for several types of objects:\n\n \u003cul\u003e\n   \u003cli\u003e\u003cp\u003e The {@link #getPath getPath} method converts a system dependent\n     \u003cem\u003epath string\u003c/em\u003e, returning a {@link Path} object that may be used\n     to locate and access a file. \u003c/p\u003e\u003c/li\u003e\n   \u003cli\u003e\u003cp\u003e The {@link #getPathMatcher  getPathMatcher} method is used\n     to create a {@link PathMatcher} that performs match operations on\n     paths. \u003c/p\u003e\u003c/li\u003e\n   \u003cli\u003e\u003cp\u003e The {@link #getFileStores getFileStores} method returns an iterator\n     over the underlying {@link FileStore file-stores}. \u003c/p\u003e\u003c/li\u003e\n   \u003cli\u003e\u003cp\u003e The {@link #getUserPrincipalLookupService getUserPrincipalLookupService}\n     method returns the {@link UserPrincipalLookupService} to lookup users or\n     groups by name. \u003c/p\u003e\u003c/li\u003e\n   \u003cli\u003e\u003cp\u003e The {@link #newWatchService newWatchService} method creates a\n     {@link WatchService} that may be used to watch objects for changes and\n     events. \u003c/p\u003e\u003c/li\u003e\n \u003c/ul\u003e\n\n \u003cp\u003e File systems vary greatly. In some cases the file system is a single\n hierarchy of files with one top-level root directory. In other cases it may\n have several distinct file hierarchies, each with its own top-level root\n directory. The {@link #getRootDirectories getRootDirectories} method may be\n used to iterate over the root directories in the file system. A file system\n is typically composed of one or more underlying {@link FileStore file-stores}\n that provide the storage for the files. Theses file stores can also vary in\n the features they support, and the file attributes or \u003cem\u003emeta-data\u003c/em\u003e that\n they associate with files.\n\n \u003cp\u003e A file system is open upon creation and can be closed by invoking its\n {@link #close() close} method. Once closed, any further attempt to access\n objects in the file system cause {@link ClosedFileSystemException} to be\n thrown. File systems created by the default {@link FileSystemProvider provider}\n cannot be closed.\n\n \u003cp\u003e A {@code FileSystem} can provide read-only or read-write access to the\n file system. Whether or not a file system provides read-only access is\n established when the {@code FileSystem} is created and can be tested by invoking\n its {@link #isReadOnly() isReadOnly} method. Attempts to write to file stores\n by means of an object associated with a read-only file system throws {@link\n ReadOnlyFileSystemException}.\n\n \u003cp\u003e File systems are safe for use by multiple concurrent threads. The {@link\n #close close} method may be invoked at any time to close a file system but\n whether a file system is \u003ci\u003easynchronously closeable\u003c/i\u003e is provider specific\n and therefore unspecified. In other words, if a thread is accessing an\n object in a file system, and another thread invokes the {@code close} method\n then it may require to block until the first operation is complete. Closing\n a file system causes all open channels, watch services, and other {@link\n Closeable closeable} objects associated with the file system to be closed.","isClass":true,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":false,"isOrdinaryClass":true,"isPrimitive":false,"simpleName":"FileSystem","qualifiedName":"java.nio.file.FileSystem","dimension":"","elementType":{},"package":"java.nio.file","superclass":"java.lang.Object","interfaces":["java.io.Closeable"],"isAbstract":true,"isStatic":false,"since":"1.7","innerClasses":[],"isInnerClass":false,"constructors":[],"fields":[],"methods":[{"name":"provider","comment":"Returns the provider that created this file system.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":false,"simpleName":"FileSystemProvider","qualifiedName":"java.nio.file.spi.FileSystemProvider","dimension":"","elementType":{}},"isAbstract":true,"isDefault":false,"isStatic":false,"parameters":[],"typeParameters":[]},{"name":"close","comment":"Closes this file system.\n\n \u003cp\u003e After a file system is closed then all subsequent access to the file\n system, either by methods defined by this class or on objects associated\n with this file system, throw {@link ClosedFileSystemException}. If the\n file system is already closed then invoking this method has no effect.\n\n \u003cp\u003e Closing a file system will close all open {@link\n java.nio.channels.Channel channels}, {@link DirectoryStream directory-streams},\n {@link WatchService watch-service}, and other closeable objects associated\n with this file system. The {@link FileSystems#getDefault default} file\n system cannot be closed.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":true,"simpleName":"void","qualifiedName":"void","dimension":"","elementType":{}},"isAbstract":true,"isDefault":false,"isStatic":false,"parameters":[],"typeParameters":[]},{"name":"isOpen","comment":"Tells whether or not this file system is open.\n\n \u003cp\u003e File systems created by the default provider are always open.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":true,"simpleName":"boolean","qualifiedName":"boolean","dimension":"","elementType":{}},"isAbstract":true,"isDefault":false,"isStatic":false,"parameters":[],"typeParameters":[]},{"name":"isReadOnly","comment":"Tells whether or not this file system allows only read-only access to\n its file stores.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":true,"simpleName":"boolean","qualifiedName":"boolean","dimension":"","elementType":{}},"isAbstract":true,"isDefault":false,"isStatic":false,"parameters":[],"typeParameters":[]},{"name":"getSeparator","comment":"Returns the name separator, represented as a string.\n\n \u003cp\u003e The name separator is used to separate names in a path string. An\n implementation may support multiple name separators in which case this\n method returns an implementation specific \u003cem\u003edefault\u003c/em\u003e name separator.\n This separator is used when creating path strings by invoking the {@link\n Path#toString() toString()} method.\n\n \u003cp\u003e In the case of the default provider, this method returns the same\n separator as {@link java.io.File#separator}.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":false,"simpleName":"String","qualifiedName":"java.lang.String","dimension":"","elementType":{}},"isAbstract":true,"isDefault":false,"isStatic":false,"parameters":[],"typeParameters":[]},{"name":"getRootDirectories","comment":"Returns an object to iterate over the paths of the root directories.\n\n \u003cp\u003e A file system provides access to a file store that may be composed\n of a number of distinct file hierarchies, each with its own top-level\n root directory. Unless denied by the security manager, each element in\n the returned iterator corresponds to the root directory of a distinct\n file hierarchy. The order of the elements is not defined. The file\n hierarchies may change during the lifetime of the Java virtual machine.\n For example, in some implementations, the insertion of removable media\n may result in the creation of a new file hierarchy with its own\n top-level directory.\n\n \u003cp\u003e When a security manager is installed, it is invoked to check access\n to the each root directory. If denied, the root directory is not returned\n by the iterator. In the case of the default provider, the {@link\n SecurityManager#checkRead(String)} method is invoked to check read access\n to each root directory. It is system dependent if the permission checks\n are done when the iterator is obtained or during iteration.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":false,"simpleName":"Iterable","qualifiedName":"java.lang.Iterable","dimension":"","elementType":{}},"isAbstract":true,"isDefault":false,"isStatic":false,"parameters":[],"typeParameters":[]},{"name":"getFileStores","comment":"Returns an object to iterate over the underlying file stores.\n\n \u003cp\u003e The elements of the returned iterator are the {@link\n FileStore FileStores} for this file system. The order of the elements is\n not defined and the file stores may change during the lifetime of the\n Java virtual machine. When an I/O error occurs, perhaps because a file\n store is not accessible, then it is not returned by the iterator.\n\n \u003cp\u003e In the case of the default provider, and a security manager is\n installed, the security manager is invoked to check {@link\n RuntimePermission}\u003ctt\u003e(\"getFileStoreAttributes\")\u003c/tt\u003e. If denied, then\n no file stores are returned by the iterator. In addition, the security\n manager\u0027s {@link SecurityManager#checkRead(String)} method is invoked to\n check read access to the file store\u0027s \u003cem\u003etop-most\u003c/em\u003e directory. If\n denied, the file store is not returned by the iterator. It is system\n dependent if the permission checks are done when the iterator is obtained\n or during iteration.\n\n \u003cp\u003e \u003cb\u003eUsage Example:\u003c/b\u003e\n Suppose we want to print the space usage for all file stores:\n \u003cpre\u003e\n     for (FileStore store: FileSystems.getDefault().getFileStores()) {\n         long total \u003d store.getTotalSpace() / 1024;\n         long used \u003d (store.getTotalSpace() - store.getUnallocatedSpace()) / 1024;\n         long avail \u003d store.getUsableSpace() / 1024;\n         System.out.format(\"%-20s %12d %12d %12d%n\", store, total, used, avail);\n     }\n \u003c/pre\u003e","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":false,"simpleName":"Iterable","qualifiedName":"java.lang.Iterable","dimension":"","elementType":{}},"isAbstract":true,"isDefault":false,"isStatic":false,"parameters":[],"typeParameters":[]},{"name":"supportedFileAttributeViews","comment":"Returns the set of the {@link FileAttributeView#name names} of the file\n attribute views supported by this {@code FileSystem}.\n\n \u003cp\u003e The {@link BasicFileAttributeView} is required to be supported and\n therefore the set contains at least one element, \"basic\".\n\n \u003cp\u003e The {@link FileStore#supportsFileAttributeView(String)\n supportsFileAttributeView(String)} method may be used to test if an\n underlying {@link FileStore} supports the file attributes identified by a\n file attribute view.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":false,"simpleName":"Set","qualifiedName":"java.util.Set","dimension":"","elementType":{}},"isAbstract":true,"isDefault":false,"isStatic":false,"parameters":[],"typeParameters":[]},{"name":"getPath","comment":"Converts a path string, or a sequence of strings that when joined form\n a path string, to a {@code Path}. If {@code more} does not specify any\n elements then the value of the {@code first} parameter is the path string\n to convert. If {@code more} specifies one or more elements then each\n non-empty string, including {@code first}, is considered to be a sequence\n of name elements (see {@link Path}) and is joined to form a path string.\n The details as to how the Strings are joined is provider specific but\n typically they will be joined using the {@link #getSeparator\n name-separator} as the separator. For example, if the name separator is\n \"{@code /}\" and {@code getPath(\"/foo\",\"bar\",\"gus\")} is invoked, then the\n path string {@code \"/foo/bar/gus\"} is converted to a {@code Path}.\n A {@code Path} representing an empty path is returned if {@code first}\n is the empty string and {@code more} does not contain any non-empty\n strings.\n\n \u003cp\u003e The parsing and conversion to a path object is inherently\n implementation dependent. In the simplest case, the path string is rejected,\n and {@link InvalidPathException} thrown, if the path string contains\n characters that cannot be converted to characters that are \u003cem\u003elegal\u003c/em\u003e\n to the file store. For example, on UNIX systems, the NUL (\u0026#92;u0000)\n character is not allowed to be present in a path. An implementation may\n choose to reject path strings that contain names that are longer than those\n allowed by any file store, and where an implementation supports a complex\n path syntax, it may choose to reject path strings that are \u003cem\u003ebadly\n formed\u003c/em\u003e.\n\n \u003cp\u003e In the case of the default provider, path strings are parsed based\n on the definition of paths at the platform or virtual file system level.\n For example, an operating system may not allow specific characters to be\n present in a file name, but a specific underlying file store may impose\n different or additional restrictions on the set of legal\n characters.\n\n \u003cp\u003e This method throws {@link InvalidPathException} when the path string\n cannot be converted to a path. Where possible, and where applicable,\n the exception is created with an {@link InvalidPathException#getIndex\n index} value indicating the first position in the {@code path} parameter\n that caused the path string to be rejected.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.lang.String, java.lang.String...)","flatSignature":"(String, String...)","returnType":{"isPrimitive":false,"simpleName":"Path","qualifiedName":"java.nio.file.Path","dimension":"","elementType":{}},"isAbstract":true,"isDefault":false,"isStatic":false,"parameters":[{"name":"first","type":{"isPrimitive":false,"simpleName":"String","qualifiedName":"java.lang.String","dimension":"","elementType":{}}},{"name":"more","type":{"isPrimitive":false,"simpleName":"String","qualifiedName":"java.lang.String","dimension":"[]","elementType":{"isPrimitive":false,"simpleName":"String","qualifiedName":"java.lang.String","dimension":"","elementType":{}}}}],"typeParameters":[]},{"name":"getPathMatcher","comment":"Returns a {@code PathMatcher} that performs match operations on the\n {@code String} representation of {@link Path} objects by interpreting a\n given pattern.\n\n The {@code syntaxAndPattern} parameter identifies the syntax and the\n pattern and takes the form:\n \u003cblockquote\u003e\u003cpre\u003e\n \u003ci\u003esyntax\u003c/i\u003e\u003cb\u003e:\u003c/b\u003e\u003ci\u003epattern\u003c/i\u003e\n \u003c/pre\u003e\u003c/blockquote\u003e\n where {@code \u0027:\u0027} stands for itself.\n\n \u003cp\u003e A {@code FileSystem} implementation supports the \"{@code glob}\" and\n \"{@code regex}\" syntaxes, and may support others. The value of the syntax\n component is compared without regard to case.\n\n \u003cp\u003e When the syntax is \"{@code glob}\" then the {@code String}\n representation of the path is matched using a limited pattern language\n that resembles regular expressions but with a simpler syntax. For example:\n\n \u003cblockquote\u003e\n \u003ctable border\u003d\"0\" summary\u003d\"Pattern Language\"\u003e\n \u003ctr\u003e\n   \u003ctd\u003e{@code *.java}\u003c/td\u003e\n   \u003ctd\u003eMatches a path that represents a file name ending in {@code .java}\u003c/td\u003e\n \u003c/tr\u003e\n \u003ctr\u003e\n   \u003ctd\u003e{@code *.*}\u003c/td\u003e\n   \u003ctd\u003eMatches file names containing a dot\u003c/td\u003e\n \u003c/tr\u003e\n \u003ctr\u003e\n   \u003ctd\u003e{@code *.{java,class}}\u003c/td\u003e\n   \u003ctd\u003eMatches file names ending with {@code .java} or {@code .class}\u003c/td\u003e\n \u003c/tr\u003e\n \u003ctr\u003e\n   \u003ctd\u003e{@code foo.?}\u003c/td\u003e\n   \u003ctd\u003eMatches file names starting with {@code foo.} and a single\n   character extension\u003c/td\u003e\n \u003c/tr\u003e\n \u003ctr\u003e\n   \u003ctd\u003e\u003ctt\u003e\u0026#47;home\u0026#47;*\u0026#47;*\u003c/tt\u003e\n   \u003ctd\u003eMatches \u003ctt\u003e\u0026#47;home\u0026#47;gus\u0026#47;data\u003c/tt\u003e on UNIX platforms\u003c/td\u003e\n \u003c/tr\u003e\n \u003ctr\u003e\n   \u003ctd\u003e\u003ctt\u003e\u0026#47;home\u0026#47;**\u003c/tt\u003e\n   \u003ctd\u003eMatches \u003ctt\u003e\u0026#47;home\u0026#47;gus\u003c/tt\u003e and\n   \u003ctt\u003e\u0026#47;home\u0026#47;gus\u0026#47;data\u003c/tt\u003e on UNIX platforms\u003c/td\u003e\n \u003c/tr\u003e\n \u003ctr\u003e\n   \u003ctd\u003e\u003ctt\u003eC:\u0026#92;\u0026#92;*\u003c/tt\u003e\n   \u003ctd\u003eMatches \u003ctt\u003eC:\u0026#92;foo\u003c/tt\u003e and \u003ctt\u003eC:\u0026#92;bar\u003c/tt\u003e on the Windows\n   platform (note that the backslash is escaped; as a string literal in the\n   Java Language the pattern would be \u003ctt\u003e\"C:\u0026#92;\u0026#92;\u0026#92;\u0026#92;*\"\u003c/tt\u003e) \u003c/td\u003e\n \u003c/tr\u003e\n\n \u003c/table\u003e\n \u003c/blockquote\u003e\n\n \u003cp\u003e The following rules are used to interpret glob patterns:\n\n \u003cul\u003e\n   \u003cli\u003e\u003cp\u003e The {@code *} character matches zero or more {@link Character\n   characters} of a {@link Path#getName(int) name} component without\n   crossing directory boundaries. \u003c/p\u003e\u003c/li\u003e\n\n   \u003cli\u003e\u003cp\u003e The {@code **} characters matches zero or more {@link Character\n   characters} crossing directory boundaries. \u003c/p\u003e\u003c/li\u003e\n\n   \u003cli\u003e\u003cp\u003e The {@code ?} character matches exactly one character of a\n   name component.\u003c/p\u003e\u003c/li\u003e\n\n   \u003cli\u003e\u003cp\u003e The backslash character ({@code \\}) is used to escape characters\n   that would otherwise be interpreted as special characters. The expression\n   {@code \\\\} matches a single backslash and \"\\{\" matches a left brace\n   for example.  \u003c/p\u003e\u003c/li\u003e\n\n   \u003cli\u003e\u003cp\u003e The {@code [ ]} characters are a \u003ci\u003ebracket expression\u003c/i\u003e that\n   match a single character of a name component out of a set of characters.\n   For example, {@code [abc]} matches {@code \"a\"}, {@code \"b\"}, or {@code \"c\"}.\n   The hyphen ({@code -}) may be used to specify a range so {@code [a-z]}\n   specifies a range that matches from {@code \"a\"} to {@code \"z\"} (inclusive).\n   These forms can be mixed so [abce-g] matches {@code \"a\"}, {@code \"b\"},\n   {@code \"c\"}, {@code \"e\"}, {@code \"f\"} or {@code \"g\"}. If the character\n   after the {@code [} is a {@code !} then it is used for negation so {@code\n   [!a-c]} matches any character except {@code \"a\"}, {@code \"b\"}, or {@code\n   \"c\"}.\n   \u003cp\u003e Within a bracket expression the {@code *}, {@code ?} and {@code \\}\n   characters match themselves. The ({@code -}) character matches itself if\n   it is the first character within the brackets, or the first character\n   after the {@code !} if negating.\u003c/p\u003e\u003c/li\u003e\n\n   \u003cli\u003e\u003cp\u003e The {@code { }} characters are a group of subpatterns, where\n   the group matches if any subpattern in the group matches. The {@code \",\"}\n   character is used to separate the subpatterns. Groups cannot be nested.\n   \u003c/p\u003e\u003c/li\u003e\n\n   \u003cli\u003e\u003cp\u003e Leading period\u003ctt\u003e\u0026#47;\u003c/tt\u003edot characters in file name are\n   treated as regular characters in match operations. For example,\n   the {@code \"*\"} glob pattern matches file name {@code \".login\"}.\n   The {@link Files#isHidden} method may be used to test whether a file\n   is considered hidden.\n   \u003c/p\u003e\u003c/li\u003e\n\n   \u003cli\u003e\u003cp\u003e All other characters match themselves in an implementation\n   dependent manner. This includes characters representing any {@link\n   FileSystem#getSeparator name-separators}. \u003c/p\u003e\u003c/li\u003e\n\n   \u003cli\u003e\u003cp\u003e The matching of {@link Path#getRoot root} components is highly\n   implementation-dependent and is not specified. \u003c/p\u003e\u003c/li\u003e\n\n \u003c/ul\u003e\n\n \u003cp\u003e When the syntax is \"{@code regex}\" then the pattern component is a\n regular expression as defined by the {@link java.util.regex.Pattern}\n class.\n\n \u003cp\u003e  For both the glob and regex syntaxes, the matching details, such as\n whether the matching is case sensitive, are implementation-dependent\n and therefore not specified.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.lang.String)","flatSignature":"(String)","returnType":{"isPrimitive":false,"simpleName":"PathMatcher","qualifiedName":"java.nio.file.PathMatcher","dimension":"","elementType":{}},"isAbstract":true,"isDefault":false,"isStatic":false,"parameters":[{"name":"syntaxAndPattern","type":{"isPrimitive":false,"simpleName":"String","qualifiedName":"java.lang.String","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"getUserPrincipalLookupService","comment":"Returns the {@code UserPrincipalLookupService} for this file system\n \u003ci\u003e(optional operation)\u003c/i\u003e. The resulting lookup service may be used to\n lookup user or group names.\n\n \u003cp\u003e \u003cb\u003eUsage Example:\u003c/b\u003e\n Suppose we want to make \"joe\" the owner of a file:\n \u003cpre\u003e\n     UserPrincipalLookupService lookupService \u003d FileSystems.getDefault().getUserPrincipalLookupService();\n     Files.setOwner(path, lookupService.lookupPrincipalByName(\"joe\"));\n \u003c/pre\u003e","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":false,"simpleName":"UserPrincipalLookupService","qualifiedName":"java.nio.file.attribute.UserPrincipalLookupService","dimension":"","elementType":{}},"isAbstract":true,"isDefault":false,"isStatic":false,"parameters":[],"typeParameters":[]},{"name":"newWatchService","comment":"Constructs a new {@link WatchService} \u003ci\u003e(optional operation)\u003c/i\u003e.\n\n \u003cp\u003e This method constructs a new watch service that may be used to watch\n registered objects for changes and events.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":false,"simpleName":"WatchService","qualifiedName":"java.nio.file.WatchService","dimension":"","elementType":{}},"isAbstract":true,"isDefault":false,"isStatic":false,"parameters":[],"typeParameters":[]}],"typeParameters":[],"enumConstants":[]}