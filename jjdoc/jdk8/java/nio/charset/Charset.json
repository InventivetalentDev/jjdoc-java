{"name":"Charset","comment":"A named mapping between sequences of sixteen-bit Unicode \u003ca\n href\u003d\"../../lang/Character.html#unicode\"\u003ecode units\u003c/a\u003e and sequences of\n bytes.  This class defines methods for creating decoders and encoders and\n for retrieving the various names associated with a charset.  Instances of\n this class are immutable.\n\n \u003cp\u003e This class also defines static methods for testing whether a particular\n charset is supported, for locating charset instances by name, and for\n constructing a map that contains every charset for which support is\n available in the current Java virtual machine.  Support for new charsets can\n be added via the service-provider interface defined in the {@link\n java.nio.charset.spi.CharsetProvider} class.\n\n \u003cp\u003e All of the methods defined in this class are safe for use by multiple\n concurrent threads.\n\n\n \u003ca name\u003d\"names\"\u003e\u003c/a\u003e\u003ca name\u003d\"charenc\"\u003e\u003c/a\u003e\n \u003ch2\u003eCharset names\u003c/h2\u003e\n\n \u003cp\u003e Charsets are named by strings composed of the following characters:\n\n \u003cul\u003e\n\n   \u003cli\u003e The uppercase letters \u003ctt\u003e\u0027A\u0027\u003c/tt\u003e through \u003ctt\u003e\u0027Z\u0027\u003c/tt\u003e\n        (\u003ctt\u003e\u0027\u0026#92;u0041\u0027\u003c/tt\u003e\u0026nbsp;through\u0026nbsp;\u003ctt\u003e\u0027\u0026#92;u005a\u0027\u003c/tt\u003e),\n\n   \u003cli\u003e The lowercase letters \u003ctt\u003e\u0027a\u0027\u003c/tt\u003e through \u003ctt\u003e\u0027z\u0027\u003c/tt\u003e\n        (\u003ctt\u003e\u0027\u0026#92;u0061\u0027\u003c/tt\u003e\u0026nbsp;through\u0026nbsp;\u003ctt\u003e\u0027\u0026#92;u007a\u0027\u003c/tt\u003e),\n\n   \u003cli\u003e The digits \u003ctt\u003e\u00270\u0027\u003c/tt\u003e through \u003ctt\u003e\u00279\u0027\u003c/tt\u003e\n        (\u003ctt\u003e\u0027\u0026#92;u0030\u0027\u003c/tt\u003e\u0026nbsp;through\u0026nbsp;\u003ctt\u003e\u0027\u0026#92;u0039\u0027\u003c/tt\u003e),\n\n   \u003cli\u003e The dash character \u003ctt\u003e\u0027-\u0027\u003c/tt\u003e\n        (\u003ctt\u003e\u0027\u0026#92;u002d\u0027\u003c/tt\u003e,\u0026nbsp;\u003csmall\u003eHYPHEN-MINUS\u003c/small\u003e),\n\n   \u003cli\u003e The plus character \u003ctt\u003e\u0027+\u0027\u003c/tt\u003e\n        (\u003ctt\u003e\u0027\u0026#92;u002b\u0027\u003c/tt\u003e,\u0026nbsp;\u003csmall\u003ePLUS SIGN\u003c/small\u003e),\n\n   \u003cli\u003e The period character \u003ctt\u003e\u0027.\u0027\u003c/tt\u003e\n        (\u003ctt\u003e\u0027\u0026#92;u002e\u0027\u003c/tt\u003e,\u0026nbsp;\u003csmall\u003eFULL STOP\u003c/small\u003e),\n\n   \u003cli\u003e The colon character \u003ctt\u003e\u0027:\u0027\u003c/tt\u003e\n        (\u003ctt\u003e\u0027\u0026#92;u003a\u0027\u003c/tt\u003e,\u0026nbsp;\u003csmall\u003eCOLON\u003c/small\u003e), and\n\n   \u003cli\u003e The underscore character \u003ctt\u003e\u0027_\u0027\u003c/tt\u003e\n        (\u003ctt\u003e\u0027\u0026#92;u005f\u0027\u003c/tt\u003e,\u0026nbsp;\u003csmall\u003eLOW\u0026nbsp;LINE\u003c/small\u003e).\n\n \u003c/ul\u003e\n\n A charset name must begin with either a letter or a digit.  The empty string\n is not a legal charset name.  Charset names are not case-sensitive; that is,\n case is always ignored when comparing charset names.  Charset names\n generally follow the conventions documented in \u003ca\n href\u003d\"http://www.ietf.org/rfc/rfc2278.txt\"\u003e\u003ci\u003eRFC\u0026nbsp;2278:\u0026nbsp;IANA Charset\n Registration Procedures\u003c/i\u003e\u003c/a\u003e.\n\n \u003cp\u003e Every charset has a \u003ci\u003ecanonical name\u003c/i\u003e and may also have one or more\n \u003ci\u003ealiases\u003c/i\u003e.  The canonical name is returned by the {@link #name() name} method\n of this class.  Canonical names are, by convention, usually in upper case.\n The aliases of a charset are returned by the {@link #aliases() aliases}\n method.\n\n \u003cp\u003e\u003ca name\u003d\"hn\"\u003eSome charsets have an \u003ci\u003ehistorical name\u003c/i\u003e that is defined for\n compatibility with previous versions of the Java platform.\u003c/a\u003e  A charset\u0027s\n historical name is either its canonical name or one of its aliases.  The\n historical name is returned by the \u003ctt\u003egetEncoding()\u003c/tt\u003e methods of the\n {@link java.io.InputStreamReader#getEncoding InputStreamReader} and {@link\n java.io.OutputStreamWriter#getEncoding OutputStreamWriter} classes.\n\n \u003cp\u003e\u003ca name\u003d\"iana\"\u003e \u003c/a\u003eIf a charset listed in the \u003ca\n href\u003d\"http://www.iana.org/assignments/character-sets\"\u003e\u003ci\u003eIANA Charset\n Registry\u003c/i\u003e\u003c/a\u003e is supported by an implementation of the Java platform then\n its canonical name must be the name listed in the registry. Many charsets\n are given more than one name in the registry, in which case the registry\n identifies one of the names as \u003ci\u003eMIME-preferred\u003c/i\u003e.  If a charset has more\n than one registry name then its canonical name must be the MIME-preferred\n name and the other names in the registry must be valid aliases.  If a\n supported charset is not listed in the IANA registry then its canonical name\n must begin with one of the strings \u003ctt\u003e\"X-\"\u003c/tt\u003e or \u003ctt\u003e\"x-\"\u003c/tt\u003e.\n\n \u003cp\u003e The IANA charset registry does change over time, and so the canonical\n name and the aliases of a particular charset may also change over time.  To\n ensure compatibility it is recommended that no alias ever be removed from a\n charset, and that if the canonical name of a charset is changed then its\n previous canonical name be made into an alias.\n\n\n \u003ch2\u003eStandard charsets\u003c/h2\u003e\n\n\n\n \u003cp\u003e\u003ca name\u003d\"standard\"\u003eEvery implementation of the Java platform is required to support the\n following standard charsets.\u003c/a\u003e  Consult the release documentation for your\n implementation to see if any other charsets are supported.  The behavior\n of such optional charsets may differ between implementations.\n\n \u003cblockquote\u003e\u003ctable width\u003d\"80%\" summary\u003d\"Description of standard charsets\"\u003e\n \u003ctr\u003e\u003cth align\u003d\"left\"\u003eCharset\u003c/th\u003e\u003cth align\u003d\"left\"\u003eDescription\u003c/th\u003e\u003c/tr\u003e\n \u003ctr\u003e\u003ctd valign\u003dtop\u003e\u003ctt\u003eUS-ASCII\u003c/tt\u003e\u003c/td\u003e\n     \u003ctd\u003eSeven-bit ASCII, a.k.a. \u003ctt\u003eISO646-US\u003c/tt\u003e,\n         a.k.a. the Basic Latin block of the Unicode character set\u003c/td\u003e\u003c/tr\u003e\n \u003ctr\u003e\u003ctd valign\u003dtop\u003e\u003ctt\u003eISO-8859-1\u0026nbsp;\u0026nbsp;\u003c/tt\u003e\u003c/td\u003e\n     \u003ctd\u003eISO Latin Alphabet No. 1, a.k.a. \u003ctt\u003eISO-LATIN-1\u003c/tt\u003e\u003c/td\u003e\u003c/tr\u003e\n \u003ctr\u003e\u003ctd valign\u003dtop\u003e\u003ctt\u003eUTF-8\u003c/tt\u003e\u003c/td\u003e\n     \u003ctd\u003eEight-bit UCS Transformation Format\u003c/td\u003e\u003c/tr\u003e\n \u003ctr\u003e\u003ctd valign\u003dtop\u003e\u003ctt\u003eUTF-16BE\u003c/tt\u003e\u003c/td\u003e\n     \u003ctd\u003eSixteen-bit UCS Transformation Format,\n         big-endian byte\u0026nbsp;order\u003c/td\u003e\u003c/tr\u003e\n \u003ctr\u003e\u003ctd valign\u003dtop\u003e\u003ctt\u003eUTF-16LE\u003c/tt\u003e\u003c/td\u003e\n     \u003ctd\u003eSixteen-bit UCS Transformation Format,\n         little-endian byte\u0026nbsp;order\u003c/td\u003e\u003c/tr\u003e\n \u003ctr\u003e\u003ctd valign\u003dtop\u003e\u003ctt\u003eUTF-16\u003c/tt\u003e\u003c/td\u003e\n     \u003ctd\u003eSixteen-bit UCS Transformation Format,\n         byte\u0026nbsp;order identified by an optional byte-order mark\u003c/td\u003e\u003c/tr\u003e\n \u003c/table\u003e\u003c/blockquote\u003e\n\n \u003cp\u003e The \u003ctt\u003eUTF-8\u003c/tt\u003e charset is specified by \u003ca\n href\u003d\"http://www.ietf.org/rfc/rfc2279.txt\"\u003e\u003ci\u003eRFC\u0026nbsp;2279\u003c/i\u003e\u003c/a\u003e; the\n transformation format upon which it is based is specified in\n Amendment\u0026nbsp;2 of ISO\u0026nbsp;10646-1 and is also described in the \u003ca\n href\u003d\"http://www.unicode.org/unicode/standard/standard.html\"\u003e\u003ci\u003eUnicode\n Standard\u003c/i\u003e\u003c/a\u003e.\n\n \u003cp\u003e The \u003ctt\u003eUTF-16\u003c/tt\u003e charsets are specified by \u003ca\n href\u003d\"http://www.ietf.org/rfc/rfc2781.txt\"\u003e\u003ci\u003eRFC\u0026nbsp;2781\u003c/i\u003e\u003c/a\u003e; the\n transformation formats upon which they are based are specified in\n Amendment\u0026nbsp;1 of ISO\u0026nbsp;10646-1 and are also described in the \u003ca\n href\u003d\"http://www.unicode.org/unicode/standard/standard.html\"\u003e\u003ci\u003eUnicode\n Standard\u003c/i\u003e\u003c/a\u003e.\n\n \u003cp\u003e The \u003ctt\u003eUTF-16\u003c/tt\u003e charsets use sixteen-bit quantities and are\n therefore sensitive to byte order.  In these encodings the byte order of a\n stream may be indicated by an initial \u003ci\u003ebyte-order mark\u003c/i\u003e represented by\n the Unicode character \u003ctt\u003e\u0027\u0026#92;uFEFF\u0027\u003c/tt\u003e.  Byte-order marks are handled\n as follows:\n\n \u003cul\u003e\n\n   \u003cli\u003e\u003cp\u003e When decoding, the \u003ctt\u003eUTF-16BE\u003c/tt\u003e and \u003ctt\u003eUTF-16LE\u003c/tt\u003e\n   charsets interpret the initial byte-order marks as a \u003csmall\u003eZERO-WIDTH\n   NON-BREAKING SPACE\u003c/small\u003e; when encoding, they do not write\n   byte-order marks. \u003c/p\u003e\u003c/li\u003e\n\n\n   \u003cli\u003e\u003cp\u003e When decoding, the \u003ctt\u003eUTF-16\u003c/tt\u003e charset interprets the\n   byte-order mark at the beginning of the input stream to indicate the\n   byte-order of the stream but defaults to big-endian if there is no\n   byte-order mark; when encoding, it uses big-endian byte order and writes\n   a big-endian byte-order mark. \u003c/p\u003e\u003c/li\u003e\n\n \u003c/ul\u003e\n\n In any case, byte order marks occurring after the first element of an\n input sequence are not omitted since the same code is used to represent\n \u003csmall\u003eZERO-WIDTH NON-BREAKING SPACE\u003c/small\u003e.\n\n \u003cp\u003e Every instance of the Java virtual machine has a default charset, which\n may or may not be one of the standard charsets.  The default charset is\n determined during virtual-machine startup and typically depends upon the\n locale and charset being used by the underlying operating system. \u003c/p\u003e\n\n \u003cp\u003eThe {@link StandardCharsets} class defines constants for each of the\n standard charsets.\n\n \u003ch2\u003eTerminology\u003c/h2\u003e\n\n \u003cp\u003e The name of this class is taken from the terms used in\n \u003ca href\u003d\"http://www.ietf.org/rfc/rfc2278.txt\"\u003e\u003ci\u003eRFC\u0026nbsp;2278\u003c/i\u003e\u003c/a\u003e.\n In that document a \u003ci\u003echarset\u003c/i\u003e is defined as the combination of\n one or more coded character sets and a character-encoding scheme.\n (This definition is confusing; some other software systems define\n \u003ci\u003echarset\u003c/i\u003e as a synonym for \u003ci\u003ecoded character set\u003c/i\u003e.)\n\n \u003cp\u003e A \u003ci\u003ecoded character set\u003c/i\u003e is a mapping between a set of abstract\n characters and a set of integers.  US-ASCII, ISO\u0026nbsp;8859-1,\n JIS\u0026nbsp;X\u0026nbsp;0201, and Unicode are examples of coded character sets.\n\n \u003cp\u003e Some standards have defined a \u003ci\u003echaracter set\u003c/i\u003e to be simply a\n set of abstract characters without an associated assigned numbering.\n An alphabet is an example of such a character set.  However, the subtle\n distinction between \u003ci\u003echaracter set\u003c/i\u003e and \u003ci\u003ecoded character set\u003c/i\u003e\n is rarely used in practice; the former has become a short form for the\n latter, including in the Java API specification.\n\n \u003cp\u003e A \u003ci\u003echaracter-encoding scheme\u003c/i\u003e is a mapping between one or more\n coded character sets and a set of octet (eight-bit byte) sequences.\n UTF-8, UTF-16, ISO\u0026nbsp;2022, and EUC are examples of\n character-encoding schemes.  Encoding schemes are often associated with\n a particular coded character set; UTF-8, for example, is used only to\n encode Unicode.  Some schemes, however, are associated with multiple\n coded character sets; EUC, for example, can be used to encode\n characters in a variety of Asian coded character sets.\n\n \u003cp\u003e When a coded character set is used exclusively with a single\n character-encoding scheme then the corresponding charset is usually\n named for the coded character set; otherwise a charset is usually named\n for the encoding scheme and, possibly, the locale of the coded\n character sets that it supports.  Hence \u003ctt\u003eUS-ASCII\u003c/tt\u003e is both the\n name of a coded character set and of the charset that encodes it, while\n \u003ctt\u003eEUC-JP\u003c/tt\u003e is the name of the charset that encodes the\n JIS\u0026nbsp;X\u0026nbsp;0201, JIS\u0026nbsp;X\u0026nbsp;0208, and JIS\u0026nbsp;X\u0026nbsp;0212\n coded character sets for the Japanese language.\n\n \u003cp\u003e The native character encoding of the Java programming language is\n UTF-16.  A charset in the Java platform therefore defines a mapping\n between sequences of sixteen-bit UTF-16 code units (that is, sequences\n of chars) and sequences of bytes. \u003c/p\u003e","isClass":true,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":false,"isOrdinaryClass":true,"isPrimitive":false,"simpleName":"Charset","qualifiedName":"java.nio.charset.Charset","dimension":"","elementType":{},"package":"java.nio.charset","superclass":"java.lang.Object","interfaces":["java.lang.Comparable"],"isAbstract":true,"isStatic":false,"since":"1.4","innerClasses":[],"isInnerClass":false,"constructors":[],"fields":[],"methods":[{"name":"isSupported","comment":"Tells whether the named charset is supported.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.lang.String)","flatSignature":"(String)","returnType":{"isPrimitive":true,"simpleName":"boolean","qualifiedName":"boolean","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"charsetName","type":{"isPrimitive":false,"simpleName":"String","qualifiedName":"java.lang.String","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"forName","comment":"Returns a charset object for the named charset.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.lang.String)","flatSignature":"(String)","returnType":{"isPrimitive":false,"simpleName":"Charset","qualifiedName":"java.nio.charset.Charset","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"charsetName","type":{"isPrimitive":false,"simpleName":"String","qualifiedName":"java.lang.String","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"availableCharsets","comment":"Constructs a sorted map from canonical charset names to charset objects.\n\n \u003cp\u003e The map returned by this method will have one entry for each charset\n for which support is available in the current Java virtual machine.  If\n two or more supported charsets have the same canonical name then the\n resulting map will contain just one of them; which one it will contain\n is not specified. \u003c/p\u003e\n\n \u003cp\u003e The invocation of this method, and the subsequent use of the\n resulting map, may cause time-consuming disk or network I/O operations\n to occur.  This method is provided for applications that need to\n enumerate all of the available charsets, for example to allow user\n charset selection.  This method is not used by the {@link #forName\n forName} method, which instead employs an efficient incremental lookup\n algorithm.\n\n \u003cp\u003e This method may return different results at different times if new\n charset providers are dynamically made available to the current Java\n virtual machine.  In the absence of such changes, the charsets returned\n by this method are exactly those that can be retrieved via the {@link\n #forName forName} method.  \u003c/p\u003e","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":false,"simpleName":"SortedMap","qualifiedName":"java.util.SortedMap","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[],"typeParameters":[]},{"name":"defaultCharset","comment":"Returns the default charset of this Java virtual machine.\n\n \u003cp\u003e The default charset is determined during virtual-machine startup and\n typically depends upon the locale and charset of the underlying\n operating system.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":false,"simpleName":"Charset","qualifiedName":"java.nio.charset.Charset","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[],"typeParameters":[]},{"name":"name","comment":"Returns this charset\u0027s canonical name.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":false,"simpleName":"String","qualifiedName":"java.lang.String","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[],"typeParameters":[]},{"name":"aliases","comment":"Returns a set containing this charset\u0027s aliases.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":false,"simpleName":"Set","qualifiedName":"java.util.Set","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[],"typeParameters":[]},{"name":"displayName","comment":"Returns this charset\u0027s human-readable name for the default locale.\n\n \u003cp\u003e The default implementation of this method simply returns this\n charset\u0027s canonical name.  Concrete subclasses of this class may\n override this method in order to provide a localized display name. \u003c/p\u003e","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":false,"simpleName":"String","qualifiedName":"java.lang.String","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[],"typeParameters":[]},{"name":"isRegistered","comment":"Tells whether or not this charset is registered in the \u003ca\n href\u003d\"http://www.iana.org/assignments/character-sets\"\u003eIANA Charset\n Registry\u003c/a\u003e.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":true,"simpleName":"boolean","qualifiedName":"boolean","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[],"typeParameters":[]},{"name":"displayName","comment":"Returns this charset\u0027s human-readable name for the given locale.\n\n \u003cp\u003e The default implementation of this method simply returns this\n charset\u0027s canonical name.  Concrete subclasses of this class may\n override this method in order to provide a localized display name. \u003c/p\u003e","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.util.Locale)","flatSignature":"(Locale)","returnType":{"isPrimitive":false,"simpleName":"String","qualifiedName":"java.lang.String","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[{"name":"locale","type":{"isPrimitive":false,"simpleName":"Locale","qualifiedName":"java.util.Locale","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"contains","comment":"Tells whether or not this charset contains the given charset.\n\n \u003cp\u003e A charset \u003ci\u003eC\u003c/i\u003e is said to \u003ci\u003econtain\u003c/i\u003e a charset \u003ci\u003eD\u003c/i\u003e if,\n and only if, every character representable in \u003ci\u003eD\u003c/i\u003e is also\n representable in \u003ci\u003eC\u003c/i\u003e.  If this relationship holds then it is\n guaranteed that every string that can be encoded in \u003ci\u003eD\u003c/i\u003e can also be\n encoded in \u003ci\u003eC\u003c/i\u003e without performing any replacements.\n\n \u003cp\u003e That \u003ci\u003eC\u003c/i\u003e contains \u003ci\u003eD\u003c/i\u003e does not imply that each character\n representable in \u003ci\u003eC\u003c/i\u003e by a particular byte sequence is represented\n in \u003ci\u003eD\u003c/i\u003e by the same byte sequence, although sometimes this is the\n case.\n\n \u003cp\u003e Every charset contains itself.\n\n \u003cp\u003e This method computes an approximation of the containment relation:\n If it returns \u003ctt\u003etrue\u003c/tt\u003e then the given charset is known to be\n contained by this charset; if it returns \u003ctt\u003efalse\u003c/tt\u003e, however, then\n it is not necessarily the case that the given charset is not contained\n in this charset.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.nio.charset.Charset)","flatSignature":"(Charset)","returnType":{"isPrimitive":true,"simpleName":"boolean","qualifiedName":"boolean","dimension":"","elementType":{}},"isAbstract":true,"isDefault":false,"isStatic":false,"parameters":[{"name":"cs","type":{"isPrimitive":false,"simpleName":"Charset","qualifiedName":"java.nio.charset.Charset","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"newDecoder","comment":"Constructs a new decoder for this charset.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":false,"simpleName":"CharsetDecoder","qualifiedName":"java.nio.charset.CharsetDecoder","dimension":"","elementType":{}},"isAbstract":true,"isDefault":false,"isStatic":false,"parameters":[],"typeParameters":[]},{"name":"newEncoder","comment":"Constructs a new encoder for this charset.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":false,"simpleName":"CharsetEncoder","qualifiedName":"java.nio.charset.CharsetEncoder","dimension":"","elementType":{}},"isAbstract":true,"isDefault":false,"isStatic":false,"parameters":[],"typeParameters":[]},{"name":"canEncode","comment":"Tells whether or not this charset supports encoding.\n\n \u003cp\u003e Nearly all charsets support encoding.  The primary exceptions are\n special-purpose \u003ci\u003eauto-detect\u003c/i\u003e charsets whose decoders can determine\n which of several possible encoding schemes is in use by examining the\n input byte sequence.  Such charsets do not support encoding because\n there is no way to determine which encoding should be used on output.\n Implementations of such charsets should override this method to return\n \u003ctt\u003efalse\u003c/tt\u003e. \u003c/p\u003e","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":true,"simpleName":"boolean","qualifiedName":"boolean","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[],"typeParameters":[]},{"name":"decode","comment":"Convenience method that decodes bytes in this charset into Unicode\n characters.\n\n \u003cp\u003e An invocation of this method upon a charset \u003ctt\u003ecs\u003c/tt\u003e returns the\n same result as the expression\n\n \u003cpre\u003e\n     cs.newDecoder()\n       .onMalformedInput(CodingErrorAction.REPLACE)\n       .onUnmappableCharacter(CodingErrorAction.REPLACE)\n       .decode(bb); \u003c/pre\u003e\n\n except that it is potentially more efficient because it can cache\n decoders between successive invocations.\n\n \u003cp\u003e This method always replaces malformed-input and unmappable-character\n sequences with this charset\u0027s default replacement byte array.  In order\n to detect such sequences, use the {@link\n CharsetDecoder#decode(java.nio.ByteBuffer)} method directly.  \u003c/p\u003e","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.nio.ByteBuffer)","flatSignature":"(ByteBuffer)","returnType":{"isPrimitive":false,"simpleName":"CharBuffer","qualifiedName":"java.nio.CharBuffer","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[{"name":"bb","type":{"isPrimitive":false,"simpleName":"ByteBuffer","qualifiedName":"java.nio.ByteBuffer","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"encode","comment":"Convenience method that encodes Unicode characters into bytes in this\n charset.\n\n \u003cp\u003e An invocation of this method upon a charset \u003ctt\u003ecs\u003c/tt\u003e returns the\n same result as the expression\n\n \u003cpre\u003e\n     cs.newEncoder()\n       .onMalformedInput(CodingErrorAction.REPLACE)\n       .onUnmappableCharacter(CodingErrorAction.REPLACE)\n       .encode(bb); \u003c/pre\u003e\n\n except that it is potentially more efficient because it can cache\n encoders between successive invocations.\n\n \u003cp\u003e This method always replaces malformed-input and unmappable-character\n sequences with this charset\u0027s default replacement string.  In order to\n detect such sequences, use the {@link\n CharsetEncoder#encode(java.nio.CharBuffer)} method directly.  \u003c/p\u003e","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.nio.CharBuffer)","flatSignature":"(CharBuffer)","returnType":{"isPrimitive":false,"simpleName":"ByteBuffer","qualifiedName":"java.nio.ByteBuffer","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[{"name":"cb","type":{"isPrimitive":false,"simpleName":"CharBuffer","qualifiedName":"java.nio.CharBuffer","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"encode","comment":"Convenience method that encodes a string into bytes in this charset.\n\n \u003cp\u003e An invocation of this method upon a charset \u003ctt\u003ecs\u003c/tt\u003e returns the\n same result as the expression\n\n \u003cpre\u003e\n     cs.encode(CharBuffer.wrap(s)); \u003c/pre\u003e","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.lang.String)","flatSignature":"(String)","returnType":{"isPrimitive":false,"simpleName":"ByteBuffer","qualifiedName":"java.nio.ByteBuffer","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[{"name":"str","type":{"isPrimitive":false,"simpleName":"String","qualifiedName":"java.lang.String","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"compareTo","comment":"Compares this charset to another.\n\n \u003cp\u003e Charsets are ordered by their canonical names, without regard to\n case. \u003c/p\u003e","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.nio.charset.Charset)","flatSignature":"(Charset)","returnType":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[{"name":"that","type":{"isPrimitive":false,"simpleName":"Charset","qualifiedName":"java.nio.charset.Charset","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"hashCode","comment":"Computes a hashcode for this charset.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[],"typeParameters":[]},{"name":"equals","comment":"Tells whether or not this object is equal to another.\n\n \u003cp\u003e Two charsets are equal if, and only if, they have the same canonical\n names.  A charset is never equal to any other type of object.  \u003c/p\u003e","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.lang.Object)","flatSignature":"(Object)","returnType":{"isPrimitive":true,"simpleName":"boolean","qualifiedName":"boolean","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[{"name":"ob","type":{"isPrimitive":false,"simpleName":"Object","qualifiedName":"java.lang.Object","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"toString","comment":"Returns a string describing this charset.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":false,"simpleName":"String","qualifiedName":"java.lang.String","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[],"typeParameters":[]}],"typeParameters":[],"enumConstants":[]}