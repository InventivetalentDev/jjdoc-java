{"name":"AsynchronousSocketChannel","comment":"An asynchronous channel for stream-oriented connecting sockets.\n\n \u003cp\u003e Asynchronous socket channels are created in one of two ways. A newly-created\n {@code AsynchronousSocketChannel} is created by invoking one of the {@link\n #open open} methods defined by this class. A newly-created channel is open but\n not yet connected. A connected {@code AsynchronousSocketChannel} is created\n when a connection is made to the socket of an {@link AsynchronousServerSocketChannel}.\n It is not possible to create an asynchronous socket channel for an arbitrary,\n pre-existing {@link java.net.Socket socket}.\n\n \u003cp\u003e A newly-created channel is connected by invoking its {@link #connect connect}\n method; once connected, a channel remains connected until it is closed.  Whether\n or not a socket channel is connected may be determined by invoking its {@link\n #getRemoteAddress getRemoteAddress} method. An attempt to invoke an I/O\n operation upon an unconnected channel will cause a {@link NotYetConnectedException}\n to be thrown.\n\n \u003cp\u003e Channels of this type are safe for use by multiple concurrent threads.\n They support concurrent reading and writing, though at most one read operation\n and one write operation can be outstanding at any time.\n If a thread initiates a read operation before a previous read operation has\n completed then a {@link ReadPendingException} will be thrown. Similarly, an\n attempt to initiate a write operation before a previous write has completed\n will throw a {@link WritePendingException}.\n\n \u003cp\u003e Socket options are configured using the {@link #setOption(SocketOption,Object)\n setOption} method. Asynchronous socket channels support the following options:\n \u003cblockquote\u003e\n \u003ctable border summary\u003d\"Socket options\"\u003e\n   \u003ctr\u003e\n     \u003cth\u003eOption Name\u003c/th\u003e\n     \u003cth\u003eDescription\u003c/th\u003e\n   \u003c/tr\u003e\n   \u003ctr\u003e\n     \u003ctd\u003e {@link java.net.StandardSocketOptions#SO_SNDBUF SO_SNDBUF} \u003c/td\u003e\n     \u003ctd\u003e The size of the socket send buffer \u003c/td\u003e\n   \u003c/tr\u003e\n   \u003ctr\u003e\n     \u003ctd\u003e {@link java.net.StandardSocketOptions#SO_RCVBUF SO_RCVBUF} \u003c/td\u003e\n     \u003ctd\u003e The size of the socket receive buffer \u003c/td\u003e\n   \u003c/tr\u003e\n   \u003ctr\u003e\n     \u003ctd\u003e {@link java.net.StandardSocketOptions#SO_KEEPALIVE SO_KEEPALIVE} \u003c/td\u003e\n     \u003ctd\u003e Keep connection alive \u003c/td\u003e\n   \u003c/tr\u003e\n   \u003ctr\u003e\n     \u003ctd\u003e {@link java.net.StandardSocketOptions#SO_REUSEADDR SO_REUSEADDR} \u003c/td\u003e\n     \u003ctd\u003e Re-use address \u003c/td\u003e\n   \u003c/tr\u003e\n   \u003ctr\u003e\n     \u003ctd\u003e {@link java.net.StandardSocketOptions#TCP_NODELAY TCP_NODELAY} \u003c/td\u003e\n     \u003ctd\u003e Disable the Nagle algorithm \u003c/td\u003e\n   \u003c/tr\u003e\n \u003c/table\u003e\n \u003c/blockquote\u003e\n Additional (implementation specific) options may also be supported.\n\n \u003ch2\u003eTimeouts\u003c/h2\u003e\n\n \u003cp\u003e The {@link #read(ByteBuffer,long,TimeUnit,Object,CompletionHandler) read}\n and {@link #write(ByteBuffer,long,TimeUnit,Object,CompletionHandler) write}\n methods defined by this class allow a timeout to be specified when initiating\n a read or write operation. If the timeout elapses before an operation completes\n then the operation completes with the exception {@link\n InterruptedByTimeoutException}. A timeout may leave the channel, or the\n underlying connection, in an inconsistent state. Where the implementation\n cannot guarantee that bytes have not been read from the channel then it puts\n the channel into an implementation specific \u003cem\u003eerror state\u003c/em\u003e. A subsequent\n attempt to initiate a {@code read} operation causes an unspecified runtime\n exception to be thrown. Similarly if a {@code write} operation times out and\n the implementation cannot guarantee bytes have not been written to the\n channel then further attempts to {@code write} to the channel cause an\n unspecified runtime exception to be thrown. When a timeout elapses then the\n state of the {@link ByteBuffer}, or the sequence of buffers, for the I/O\n operation is not defined. Buffers should be discarded or at least care must\n be taken to ensure that the buffers are not accessed while the channel remains\n open. All methods that accept timeout parameters treat values less than or\n equal to zero to mean that the I/O operation does not timeout.","isClass":true,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":false,"isOrdinaryClass":true,"isPrimitive":false,"simpleName":"AsynchronousSocketChannel","qualifiedName":"java.nio.channels.AsynchronousSocketChannel","dimension":"","elementType":{},"package":"java.nio.channels","superclass":"java.lang.Object","interfaces":["java.nio.channels.AsynchronousByteChannel","java.nio.channels.NetworkChannel"],"isAbstract":true,"isStatic":false,"since":"1.7","innerClasses":[],"isInnerClass":false,"constructors":[],"fields":[],"methods":[{"name":"provider","comment":"Returns the provider that created this channel.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":false,"simpleName":"AsynchronousChannelProvider","qualifiedName":"java.nio.channels.spi.AsynchronousChannelProvider","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[],"typeParameters":[]},{"name":"open","comment":"Opens an asynchronous socket channel.\n\n \u003cp\u003e The new channel is created by invoking the {@link\n AsynchronousChannelProvider#openAsynchronousSocketChannel\n openAsynchronousSocketChannel} method on the {@link\n AsynchronousChannelProvider} that created the group. If the group parameter\n is {@code null} then the resulting channel is created by the system-wide\n default provider, and bound to the \u003cem\u003edefault group\u003c/em\u003e.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.nio.channels.AsynchronousChannelGroup)","flatSignature":"(AsynchronousChannelGroup)","returnType":{"isPrimitive":false,"simpleName":"AsynchronousSocketChannel","qualifiedName":"java.nio.channels.AsynchronousSocketChannel","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"group","type":{"isPrimitive":false,"simpleName":"AsynchronousChannelGroup","qualifiedName":"java.nio.channels.AsynchronousChannelGroup","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"open","comment":"Opens an asynchronous socket channel.\n\n \u003cp\u003e This method returns an asynchronous socket channel that is bound to\n the \u003cem\u003edefault group\u003c/em\u003e.This method is equivalent to evaluating the\n expression:\n \u003cblockquote\u003e\u003cpre\u003e\n open((AsynchronousChannelGroup)null);\n \u003c/pre\u003e\u003c/blockquote\u003e","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":false,"simpleName":"AsynchronousSocketChannel","qualifiedName":"java.nio.channels.AsynchronousSocketChannel","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[],"typeParameters":[]},{"name":"bind","comment":"","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.net.SocketAddress)","flatSignature":"(SocketAddress)","returnType":{"isPrimitive":false,"simpleName":"AsynchronousSocketChannel","qualifiedName":"java.nio.channels.AsynchronousSocketChannel","dimension":"","elementType":{}},"isAbstract":true,"isDefault":false,"isStatic":false,"parameters":[{"name":"local","type":{"isPrimitive":false,"simpleName":"SocketAddress","qualifiedName":"java.net.SocketAddress","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"setOption","comment":"","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.net.SocketOption\u003cT\u003e, T)","flatSignature":"(SocketOption\u003cT\u003e, T)","returnType":{"isPrimitive":false,"simpleName":"AsynchronousSocketChannel","qualifiedName":"java.nio.channels.AsynchronousSocketChannel","dimension":"","elementType":{}},"isAbstract":true,"isDefault":false,"isStatic":false,"parameters":[{"name":"name","type":{"isPrimitive":false,"simpleName":"SocketOption","qualifiedName":"java.net.SocketOption","dimension":"","elementType":{}}},{"name":"value","type":{"isPrimitive":false,"simpleName":"T","qualifiedName":"T","dimension":"","elementType":{},"typeVariable":{"name":"T","bounds":[]}}}],"typeParameters":[{"name":"T","bounds":[]}]},{"name":"shutdownInput","comment":"Shutdown the connection for reading without closing the channel.\n\n \u003cp\u003e Once shutdown for reading then further reads on the channel will\n return {@code -1}, the end-of-stream indication. If the input side of the\n connection is already shutdown then invoking this method has no effect.\n The effect on an outstanding read operation is system dependent and\n therefore not specified. The effect, if any, when there is data in the\n socket receive buffer that has not been read, or data arrives subsequently,\n is also system dependent.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":false,"simpleName":"AsynchronousSocketChannel","qualifiedName":"java.nio.channels.AsynchronousSocketChannel","dimension":"","elementType":{}},"isAbstract":true,"isDefault":false,"isStatic":false,"parameters":[],"typeParameters":[]},{"name":"shutdownOutput","comment":"Shutdown the connection for writing without closing the channel.\n\n \u003cp\u003e Once shutdown for writing then further attempts to write to the\n channel will throw {@link ClosedChannelException}. If the output side of\n the connection is already shutdown then invoking this method has no\n effect. The effect on an outstanding write operation is system dependent\n and therefore not specified.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":false,"simpleName":"AsynchronousSocketChannel","qualifiedName":"java.nio.channels.AsynchronousSocketChannel","dimension":"","elementType":{}},"isAbstract":true,"isDefault":false,"isStatic":false,"parameters":[],"typeParameters":[]},{"name":"getRemoteAddress","comment":"Returns the remote address to which this channel\u0027s socket is connected.\n\n \u003cp\u003e Where the channel is bound and connected to an Internet Protocol\n socket address then the return value from this method is of type {@link\n java.net.InetSocketAddress}.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":false,"simpleName":"SocketAddress","qualifiedName":"java.net.SocketAddress","dimension":"","elementType":{}},"isAbstract":true,"isDefault":false,"isStatic":false,"parameters":[],"typeParameters":[]},{"name":"connect","comment":"Connects this channel.\n\n \u003cp\u003e This method initiates an operation to connect this channel. The\n {@code handler} parameter is a completion handler that is invoked when\n the connection is successfully established or connection cannot be\n established. If the connection cannot be established then the channel is\n closed.\n\n \u003cp\u003e This method performs exactly the same security checks as the {@link\n java.net.Socket} class.  That is, if a security manager has been\n installed then this method verifies that its {@link\n java.lang.SecurityManager#checkConnect checkConnect} method permits\n connecting to the address and port number of the given remote endpoint.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.net.SocketAddress, A, java.nio.channels.CompletionHandler\u003cjava.lang.Void, ? super A\u003e)","flatSignature":"(SocketAddress, A, CompletionHandler\u003cVoid, ? super A\u003e)","returnType":{"isPrimitive":true,"simpleName":"void","qualifiedName":"void","dimension":"","elementType":{}},"isAbstract":true,"isDefault":false,"isStatic":false,"parameters":[{"name":"remote","type":{"isPrimitive":false,"simpleName":"SocketAddress","qualifiedName":"java.net.SocketAddress","dimension":"","elementType":{}}},{"name":"attachment","type":{"isPrimitive":false,"simpleName":"A","qualifiedName":"A","dimension":"","elementType":{},"typeVariable":{"name":"A","bounds":[]}}},{"name":"handler","type":{"isPrimitive":false,"simpleName":"CompletionHandler","qualifiedName":"java.nio.channels.CompletionHandler","dimension":"","elementType":{}}}],"typeParameters":[{"name":"A","bounds":[]}]},{"name":"connect","comment":"Connects this channel.\n\n \u003cp\u003e This method initiates an operation to connect this channel. This\n method behaves in exactly the same manner as the {@link\n #connect(SocketAddress, Object, CompletionHandler)} method except that\n instead of specifying a completion handler, this method returns a {@code\n Future} representing the pending result. The {@code Future}\u0027s {@link\n Future#get() get} method returns {@code null} on successful completion.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.net.SocketAddress)","flatSignature":"(SocketAddress)","returnType":{"isPrimitive":false,"simpleName":"Future","qualifiedName":"java.util.concurrent.Future","dimension":"","elementType":{}},"isAbstract":true,"isDefault":false,"isStatic":false,"parameters":[{"name":"remote","type":{"isPrimitive":false,"simpleName":"SocketAddress","qualifiedName":"java.net.SocketAddress","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"read","comment":"Reads a sequence of bytes from this channel into the given buffer.\n\n \u003cp\u003e This method initiates an asynchronous read operation to read a\n sequence of bytes from this channel into the given buffer. The {@code\n handler} parameter is a completion handler that is invoked when the read\n operation completes (or fails). The result passed to the completion\n handler is the number of bytes read or {@code -1} if no bytes could be\n read because the channel has reached end-of-stream.\n\n \u003cp\u003e If a timeout is specified and the timeout elapses before the operation\n completes then the operation completes with the exception {@link\n InterruptedByTimeoutException}. Where a timeout occurs, and the\n implementation cannot guarantee that bytes have not been read, or will not\n be read from the channel into the given buffer, then further attempts to\n read from the channel will cause an unspecific runtime exception to be\n thrown.\n\n \u003cp\u003e Otherwise this method works in the same manner as the {@link\n AsynchronousByteChannel#read(ByteBuffer,Object,CompletionHandler)}\n method.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.nio.ByteBuffer, long, java.util.concurrent.TimeUnit, A, java.nio.channels.CompletionHandler\u003cjava.lang.Integer, ? super A\u003e)","flatSignature":"(ByteBuffer, long, TimeUnit, A, CompletionHandler\u003cInteger, ? super A\u003e)","returnType":{"isPrimitive":true,"simpleName":"void","qualifiedName":"void","dimension":"","elementType":{}},"isAbstract":true,"isDefault":false,"isStatic":false,"parameters":[{"name":"dst","type":{"isPrimitive":false,"simpleName":"ByteBuffer","qualifiedName":"java.nio.ByteBuffer","dimension":"","elementType":{}}},{"name":"timeout","type":{"isPrimitive":true,"simpleName":"long","qualifiedName":"long","dimension":"","elementType":{}}},{"name":"unit","type":{"isPrimitive":false,"simpleName":"TimeUnit","qualifiedName":"java.util.concurrent.TimeUnit","dimension":"","elementType":{}}},{"name":"attachment","type":{"isPrimitive":false,"simpleName":"A","qualifiedName":"A","dimension":"","elementType":{},"typeVariable":{"name":"A","bounds":[]}}},{"name":"handler","type":{"isPrimitive":false,"simpleName":"CompletionHandler","qualifiedName":"java.nio.channels.CompletionHandler","dimension":"","elementType":{}}}],"typeParameters":[{"name":"A","bounds":[]}]},{"name":"read","comment":"","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.nio.ByteBuffer, A, java.nio.channels.CompletionHandler\u003cjava.lang.Integer, ? super A\u003e)","flatSignature":"(ByteBuffer, A, CompletionHandler\u003cInteger, ? super A\u003e)","returnType":{"isPrimitive":true,"simpleName":"void","qualifiedName":"void","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[{"name":"dst","type":{"isPrimitive":false,"simpleName":"ByteBuffer","qualifiedName":"java.nio.ByteBuffer","dimension":"","elementType":{}}},{"name":"attachment","type":{"isPrimitive":false,"simpleName":"A","qualifiedName":"A","dimension":"","elementType":{},"typeVariable":{"name":"A","bounds":[]}}},{"name":"handler","type":{"isPrimitive":false,"simpleName":"CompletionHandler","qualifiedName":"java.nio.channels.CompletionHandler","dimension":"","elementType":{}}}],"typeParameters":[{"name":"A","bounds":[]}]},{"name":"read","comment":"","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.nio.ByteBuffer)","flatSignature":"(ByteBuffer)","returnType":{"isPrimitive":false,"simpleName":"Future","qualifiedName":"java.util.concurrent.Future","dimension":"","elementType":{}},"isAbstract":true,"isDefault":false,"isStatic":false,"parameters":[{"name":"dst","type":{"isPrimitive":false,"simpleName":"ByteBuffer","qualifiedName":"java.nio.ByteBuffer","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"read","comment":"Reads a sequence of bytes from this channel into a subsequence of the\n given buffers. This operation, sometimes called a \u003cem\u003escattering read\u003c/em\u003e,\n is often useful when implementing network protocols that group data into\n segments consisting of one or more fixed-length headers followed by a\n variable-length body. The {@code handler} parameter is a completion\n handler that is invoked when the read operation completes (or fails). The\n result passed to the completion handler is the number of bytes read or\n {@code -1} if no bytes could be read because the channel has reached\n end-of-stream.\n\n \u003cp\u003e This method initiates a read of up to \u003ci\u003er\u003c/i\u003e bytes from this channel,\n where \u003ci\u003er\u003c/i\u003e is the total number of bytes remaining in the specified\n subsequence of the given buffer array, that is,\n\n \u003cblockquote\u003e\u003cpre\u003e\n dsts[offset].remaining()\n     + dsts[offset+1].remaining()\n     + ... + dsts[offset+length-1].remaining()\u003c/pre\u003e\u003c/blockquote\u003e\n\n at the moment that the read is attempted.\n\n \u003cp\u003e Suppose that a byte sequence of length \u003ci\u003en\u003c/i\u003e is read, where\n \u003ctt\u003e0\u003c/tt\u003e\u0026nbsp;\u003ctt\u003e\u0026lt;\u003c/tt\u003e\u0026nbsp;\u003ci\u003en\u003c/i\u003e\u0026nbsp;\u003ctt\u003e\u0026lt;\u003d\u003c/tt\u003e\u0026nbsp;\u003ci\u003er\u003c/i\u003e.\n Up to the first \u003ctt\u003edsts[offset].remaining()\u003c/tt\u003e bytes of this sequence\n are transferred into buffer \u003ctt\u003edsts[offset]\u003c/tt\u003e, up to the next\n \u003ctt\u003edsts[offset+1].remaining()\u003c/tt\u003e bytes are transferred into buffer\n \u003ctt\u003edsts[offset+1]\u003c/tt\u003e, and so forth, until the entire byte sequence\n is transferred into the given buffers.  As many bytes as possible are\n transferred into each buffer, hence the final position of each updated\n buffer, except the last updated buffer, is guaranteed to be equal to\n that buffer\u0027s limit. The underlying operating system may impose a limit\n on the number of buffers that may be used in an I/O operation. Where the\n number of buffers (with bytes remaining), exceeds this limit, then the\n I/O operation is performed with the maximum number of buffers allowed by\n the operating system.\n\n \u003cp\u003e If a timeout is specified and the timeout elapses before the operation\n completes then it completes with the exception {@link\n InterruptedByTimeoutException}. Where a timeout occurs, and the\n implementation cannot guarantee that bytes have not been read, or will not\n be read from the channel into the given buffers, then further attempts to\n read from the channel will cause an unspecific runtime exception to be\n thrown.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.nio.ByteBuffer[], int, int, long, java.util.concurrent.TimeUnit, A, java.nio.channels.CompletionHandler\u003cjava.lang.Long, ? super A\u003e)","flatSignature":"(ByteBuffer[], int, int, long, TimeUnit, A, CompletionHandler\u003cLong, ? super A\u003e)","returnType":{"isPrimitive":true,"simpleName":"void","qualifiedName":"void","dimension":"","elementType":{}},"isAbstract":true,"isDefault":false,"isStatic":false,"parameters":[{"name":"dsts","type":{"isPrimitive":false,"simpleName":"ByteBuffer","qualifiedName":"java.nio.ByteBuffer","dimension":"[]","elementType":{"isPrimitive":false,"simpleName":"ByteBuffer","qualifiedName":"java.nio.ByteBuffer","dimension":"","elementType":{}}}},{"name":"offset","type":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}}},{"name":"length","type":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}}},{"name":"timeout","type":{"isPrimitive":true,"simpleName":"long","qualifiedName":"long","dimension":"","elementType":{}}},{"name":"unit","type":{"isPrimitive":false,"simpleName":"TimeUnit","qualifiedName":"java.util.concurrent.TimeUnit","dimension":"","elementType":{}}},{"name":"attachment","type":{"isPrimitive":false,"simpleName":"A","qualifiedName":"A","dimension":"","elementType":{},"typeVariable":{"name":"A","bounds":[]}}},{"name":"handler","type":{"isPrimitive":false,"simpleName":"CompletionHandler","qualifiedName":"java.nio.channels.CompletionHandler","dimension":"","elementType":{}}}],"typeParameters":[{"name":"A","bounds":[]}]},{"name":"write","comment":"Writes a sequence of bytes to this channel from the given buffer.\n\n \u003cp\u003e This method initiates an asynchronous write operation to write a\n sequence of bytes to this channel from the given buffer. The {@code\n handler} parameter is a completion handler that is invoked when the write\n operation completes (or fails). The result passed to the completion\n handler is the number of bytes written.\n\n \u003cp\u003e If a timeout is specified and the timeout elapses before the operation\n completes then it completes with the exception {@link\n InterruptedByTimeoutException}. Where a timeout occurs, and the\n implementation cannot guarantee that bytes have not been written, or will\n not be written to the channel from the given buffer, then further attempts\n to write to the channel will cause an unspecific runtime exception to be\n thrown.\n\n \u003cp\u003e Otherwise this method works in the same manner as the {@link\n AsynchronousByteChannel#write(ByteBuffer,Object,CompletionHandler)}\n method.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.nio.ByteBuffer, long, java.util.concurrent.TimeUnit, A, java.nio.channels.CompletionHandler\u003cjava.lang.Integer, ? super A\u003e)","flatSignature":"(ByteBuffer, long, TimeUnit, A, CompletionHandler\u003cInteger, ? super A\u003e)","returnType":{"isPrimitive":true,"simpleName":"void","qualifiedName":"void","dimension":"","elementType":{}},"isAbstract":true,"isDefault":false,"isStatic":false,"parameters":[{"name":"src","type":{"isPrimitive":false,"simpleName":"ByteBuffer","qualifiedName":"java.nio.ByteBuffer","dimension":"","elementType":{}}},{"name":"timeout","type":{"isPrimitive":true,"simpleName":"long","qualifiedName":"long","dimension":"","elementType":{}}},{"name":"unit","type":{"isPrimitive":false,"simpleName":"TimeUnit","qualifiedName":"java.util.concurrent.TimeUnit","dimension":"","elementType":{}}},{"name":"attachment","type":{"isPrimitive":false,"simpleName":"A","qualifiedName":"A","dimension":"","elementType":{},"typeVariable":{"name":"A","bounds":[]}}},{"name":"handler","type":{"isPrimitive":false,"simpleName":"CompletionHandler","qualifiedName":"java.nio.channels.CompletionHandler","dimension":"","elementType":{}}}],"typeParameters":[{"name":"A","bounds":[]}]},{"name":"write","comment":"","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.nio.ByteBuffer, A, java.nio.channels.CompletionHandler\u003cjava.lang.Integer, ? super A\u003e)","flatSignature":"(ByteBuffer, A, CompletionHandler\u003cInteger, ? super A\u003e)","returnType":{"isPrimitive":true,"simpleName":"void","qualifiedName":"void","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[{"name":"src","type":{"isPrimitive":false,"simpleName":"ByteBuffer","qualifiedName":"java.nio.ByteBuffer","dimension":"","elementType":{}}},{"name":"attachment","type":{"isPrimitive":false,"simpleName":"A","qualifiedName":"A","dimension":"","elementType":{},"typeVariable":{"name":"A","bounds":[]}}},{"name":"handler","type":{"isPrimitive":false,"simpleName":"CompletionHandler","qualifiedName":"java.nio.channels.CompletionHandler","dimension":"","elementType":{}}}],"typeParameters":[{"name":"A","bounds":[]}]},{"name":"write","comment":"","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.nio.ByteBuffer)","flatSignature":"(ByteBuffer)","returnType":{"isPrimitive":false,"simpleName":"Future","qualifiedName":"java.util.concurrent.Future","dimension":"","elementType":{}},"isAbstract":true,"isDefault":false,"isStatic":false,"parameters":[{"name":"src","type":{"isPrimitive":false,"simpleName":"ByteBuffer","qualifiedName":"java.nio.ByteBuffer","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"write","comment":"Writes a sequence of bytes to this channel from a subsequence of the given\n buffers. This operation, sometimes called a \u003cem\u003egathering write\u003c/em\u003e, is\n often useful when implementing network protocols that group data into\n segments consisting of one or more fixed-length headers followed by a\n variable-length body. The {@code handler} parameter is a completion\n handler that is invoked when the write operation completes (or fails).\n The result passed to the completion handler is the number of bytes written.\n\n \u003cp\u003e This method initiates a write of up to \u003ci\u003er\u003c/i\u003e bytes to this channel,\n where \u003ci\u003er\u003c/i\u003e is the total number of bytes remaining in the specified\n subsequence of the given buffer array, that is,\n\n \u003cblockquote\u003e\u003cpre\u003e\n srcs[offset].remaining()\n     + srcs[offset+1].remaining()\n     + ... + srcs[offset+length-1].remaining()\u003c/pre\u003e\u003c/blockquote\u003e\n\n at the moment that the write is attempted.\n\n \u003cp\u003e Suppose that a byte sequence of length \u003ci\u003en\u003c/i\u003e is written, where\n \u003ctt\u003e0\u003c/tt\u003e\u0026nbsp;\u003ctt\u003e\u0026lt;\u003c/tt\u003e\u0026nbsp;\u003ci\u003en\u003c/i\u003e\u0026nbsp;\u003ctt\u003e\u0026lt;\u003d\u003c/tt\u003e\u0026nbsp;\u003ci\u003er\u003c/i\u003e.\n Up to the first \u003ctt\u003esrcs[offset].remaining()\u003c/tt\u003e bytes of this sequence\n are written from buffer \u003ctt\u003esrcs[offset]\u003c/tt\u003e, up to the next\n \u003ctt\u003esrcs[offset+1].remaining()\u003c/tt\u003e bytes are written from buffer\n \u003ctt\u003esrcs[offset+1]\u003c/tt\u003e, and so forth, until the entire byte sequence is\n written.  As many bytes as possible are written from each buffer, hence\n the final position of each updated buffer, except the last updated\n buffer, is guaranteed to be equal to that buffer\u0027s limit. The underlying\n operating system may impose a limit on the number of buffers that may be\n used in an I/O operation. Where the number of buffers (with bytes\n remaining), exceeds this limit, then the I/O operation is performed with\n the maximum number of buffers allowed by the operating system.\n\n \u003cp\u003e If a timeout is specified and the timeout elapses before the operation\n completes then it completes with the exception {@link\n InterruptedByTimeoutException}. Where a timeout occurs, and the\n implementation cannot guarantee that bytes have not been written, or will\n not be written to the channel from the given buffers, then further attempts\n to write to the channel will cause an unspecific runtime exception to be\n thrown.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.nio.ByteBuffer[], int, int, long, java.util.concurrent.TimeUnit, A, java.nio.channels.CompletionHandler\u003cjava.lang.Long, ? super A\u003e)","flatSignature":"(ByteBuffer[], int, int, long, TimeUnit, A, CompletionHandler\u003cLong, ? super A\u003e)","returnType":{"isPrimitive":true,"simpleName":"void","qualifiedName":"void","dimension":"","elementType":{}},"isAbstract":true,"isDefault":false,"isStatic":false,"parameters":[{"name":"srcs","type":{"isPrimitive":false,"simpleName":"ByteBuffer","qualifiedName":"java.nio.ByteBuffer","dimension":"[]","elementType":{"isPrimitive":false,"simpleName":"ByteBuffer","qualifiedName":"java.nio.ByteBuffer","dimension":"","elementType":{}}}},{"name":"offset","type":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}}},{"name":"length","type":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}}},{"name":"timeout","type":{"isPrimitive":true,"simpleName":"long","qualifiedName":"long","dimension":"","elementType":{}}},{"name":"unit","type":{"isPrimitive":false,"simpleName":"TimeUnit","qualifiedName":"java.util.concurrent.TimeUnit","dimension":"","elementType":{}}},{"name":"attachment","type":{"isPrimitive":false,"simpleName":"A","qualifiedName":"A","dimension":"","elementType":{},"typeVariable":{"name":"A","bounds":[]}}},{"name":"handler","type":{"isPrimitive":false,"simpleName":"CompletionHandler","qualifiedName":"java.nio.channels.CompletionHandler","dimension":"","elementType":{}}}],"typeParameters":[{"name":"A","bounds":[]}]},{"name":"getLocalAddress","comment":"{@inheritDoc}\n \u003cp\u003e\n If there is a security manager set, its {@code checkConnect} method is\n called with the local address and {@code -1} as its arguments to see\n if the operation is allowed. If the operation is not allowed,\n a {@code SocketAddress} representing the\n {@link java.net.InetAddress#getLoopbackAddress loopback} address and the\n local port of the channel\u0027s socket is returned.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":false,"simpleName":"SocketAddress","qualifiedName":"java.net.SocketAddress","dimension":"","elementType":{}},"isAbstract":true,"isDefault":false,"isStatic":false,"parameters":[],"typeParameters":[]}],"typeParameters":[],"enumConstants":[]}