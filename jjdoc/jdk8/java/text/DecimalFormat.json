{"name":"DecimalFormat","comment":"\u003ccode\u003eDecimalFormat\u003c/code\u003e is a concrete subclass of\n \u003ccode\u003eNumberFormat\u003c/code\u003e that formats decimal numbers. It has a variety of\n features designed to make it possible to parse and format numbers in any\n locale, including support for Western, Arabic, and Indic digits.  It also\n supports different kinds of numbers, including integers (123), fixed-point\n numbers (123.4), scientific notation (1.23E4), percentages (12%), and\n currency amounts ($123).  All of these can be localized.\n\n \u003cp\u003eTo obtain a \u003ccode\u003eNumberFormat\u003c/code\u003e for a specific locale, including the\n default locale, call one of \u003ccode\u003eNumberFormat\u003c/code\u003e\u0027s factory methods, such\n as \u003ccode\u003egetInstance()\u003c/code\u003e.  In general, do not call the\n \u003ccode\u003eDecimalFormat\u003c/code\u003e constructors directly, since the\n \u003ccode\u003eNumberFormat\u003c/code\u003e factory methods may return subclasses other than\n \u003ccode\u003eDecimalFormat\u003c/code\u003e. If you need to customize the format object, do\n something like this:\n\n \u003cblockquote\u003e\u003cpre\u003e\n NumberFormat f \u003d NumberFormat.getInstance(loc);\n if (f instanceof DecimalFormat) {\n     ((DecimalFormat) f).setDecimalSeparatorAlwaysShown(true);\n }\n \u003c/pre\u003e\u003c/blockquote\u003e\n\n \u003cp\u003eA \u003ccode\u003eDecimalFormat\u003c/code\u003e comprises a \u003cem\u003epattern\u003c/em\u003e and a set of\n \u003cem\u003esymbols\u003c/em\u003e.  The pattern may be set directly using\n \u003ccode\u003eapplyPattern()\u003c/code\u003e, or indirectly using the API methods.  The\n symbols are stored in a \u003ccode\u003eDecimalFormatSymbols\u003c/code\u003e object.  When using\n the \u003ccode\u003eNumberFormat\u003c/code\u003e factory methods, the pattern and symbols are\n read from localized \u003ccode\u003eResourceBundle\u003c/code\u003es.\n\n \u003ch3\u003ePatterns\u003c/h3\u003e\n\n \u003ccode\u003eDecimalFormat\u003c/code\u003e patterns have the following syntax:\n \u003cblockquote\u003e\u003cpre\u003e\n \u003ci\u003ePattern:\u003c/i\u003e\n         \u003ci\u003ePositivePattern\u003c/i\u003e\n         \u003ci\u003ePositivePattern\u003c/i\u003e ; \u003ci\u003eNegativePattern\u003c/i\u003e\n \u003ci\u003ePositivePattern:\u003c/i\u003e\n         \u003ci\u003ePrefix\u003csub\u003eopt\u003c/sub\u003e\u003c/i\u003e \u003ci\u003eNumber\u003c/i\u003e \u003ci\u003eSuffix\u003csub\u003eopt\u003c/sub\u003e\u003c/i\u003e\n \u003ci\u003eNegativePattern:\u003c/i\u003e\n         \u003ci\u003ePrefix\u003csub\u003eopt\u003c/sub\u003e\u003c/i\u003e \u003ci\u003eNumber\u003c/i\u003e \u003ci\u003eSuffix\u003csub\u003eopt\u003c/sub\u003e\u003c/i\u003e\n \u003ci\u003ePrefix:\u003c/i\u003e\n         any Unicode characters except \u0026#92;uFFFE, \u0026#92;uFFFF, and special characters\n \u003ci\u003eSuffix:\u003c/i\u003e\n         any Unicode characters except \u0026#92;uFFFE, \u0026#92;uFFFF, and special characters\n \u003ci\u003eNumber:\u003c/i\u003e\n         \u003ci\u003eInteger\u003c/i\u003e \u003ci\u003eExponent\u003csub\u003eopt\u003c/sub\u003e\u003c/i\u003e\n         \u003ci\u003eInteger\u003c/i\u003e . \u003ci\u003eFraction\u003c/i\u003e \u003ci\u003eExponent\u003csub\u003eopt\u003c/sub\u003e\u003c/i\u003e\n \u003ci\u003eInteger:\u003c/i\u003e\n         \u003ci\u003eMinimumInteger\u003c/i\u003e\n         #\n         # \u003ci\u003eInteger\u003c/i\u003e\n         # , \u003ci\u003eInteger\u003c/i\u003e\n \u003ci\u003eMinimumInteger:\u003c/i\u003e\n         0\n         0 \u003ci\u003eMinimumInteger\u003c/i\u003e\n         0 , \u003ci\u003eMinimumInteger\u003c/i\u003e\n \u003ci\u003eFraction:\u003c/i\u003e\n         \u003ci\u003eMinimumFraction\u003csub\u003eopt\u003c/sub\u003e\u003c/i\u003e \u003ci\u003eOptionalFraction\u003csub\u003eopt\u003c/sub\u003e\u003c/i\u003e\n \u003ci\u003eMinimumFraction:\u003c/i\u003e\n         0 \u003ci\u003eMinimumFraction\u003csub\u003eopt\u003c/sub\u003e\u003c/i\u003e\n \u003ci\u003eOptionalFraction:\u003c/i\u003e\n         # \u003ci\u003eOptionalFraction\u003csub\u003eopt\u003c/sub\u003e\u003c/i\u003e\n \u003ci\u003eExponent:\u003c/i\u003e\n         E \u003ci\u003eMinimumExponent\u003c/i\u003e\n \u003ci\u003eMinimumExponent:\u003c/i\u003e\n         0 \u003ci\u003eMinimumExponent\u003csub\u003eopt\u003c/sub\u003e\u003c/i\u003e\n \u003c/pre\u003e\u003c/blockquote\u003e\n\n \u003cp\u003eA \u003ccode\u003eDecimalFormat\u003c/code\u003e pattern contains a positive and negative\n subpattern, for example, \u003ccode\u003e\"#,##0.00;(#,##0.00)\"\u003c/code\u003e.  Each\n subpattern has a prefix, numeric part, and suffix. The negative subpattern\n is optional; if absent, then the positive subpattern prefixed with the\n localized minus sign (\u003ccode\u003e\u0027-\u0027\u003c/code\u003e in most locales) is used as the\n negative subpattern. That is, \u003ccode\u003e\"0.00\"\u003c/code\u003e alone is equivalent to\n \u003ccode\u003e\"0.00;-0.00\"\u003c/code\u003e.  If there is an explicit negative subpattern, it\n serves only to specify the negative prefix and suffix; the number of digits,\n minimal digits, and other characteristics are all the same as the positive\n pattern. That means that \u003ccode\u003e\"#,##0.0#;(#)\"\u003c/code\u003e produces precisely\n the same behavior as \u003ccode\u003e\"#,##0.0#;(#,##0.0#)\"\u003c/code\u003e.\n\n \u003cp\u003eThe prefixes, suffixes, and various symbols used for infinity, digits,\n thousands separators, decimal separators, etc. may be set to arbitrary\n values, and they will appear properly during formatting.  However, care must\n be taken that the symbols and strings do not conflict, or parsing will be\n unreliable.  For example, either the positive and negative prefixes or the\n suffixes must be distinct for \u003ccode\u003eDecimalFormat.parse()\u003c/code\u003e to be able\n to distinguish positive from negative values.  (If they are identical, then\n \u003ccode\u003eDecimalFormat\u003c/code\u003e will behave as if no negative subpattern was\n specified.)  Another example is that the decimal separator and thousands\n separator should be distinct characters, or parsing will be impossible.\n\n \u003cp\u003eThe grouping separator is commonly used for thousands, but in some\n countries it separates ten-thousands. The grouping size is a constant number\n of digits between the grouping characters, such as 3 for 100,000,000 or 4 for\n 1,0000,0000.  If you supply a pattern with multiple grouping characters, the\n interval between the last one and the end of the integer is the one that is\n used. So \u003ccode\u003e\"#,##,###,####\"\u003c/code\u003e \u003d\u003d \u003ccode\u003e\"######,####\"\u003c/code\u003e \u003d\u003d\n \u003ccode\u003e\"##,####,####\"\u003c/code\u003e.\n\n \u003ch4\u003eSpecial Pattern Characters\u003c/h4\u003e\n\n \u003cp\u003eMany characters in a pattern are taken literally; they are matched during\n parsing and output unchanged during formatting.  Special characters, on the\n other hand, stand for other characters, strings, or classes of characters.\n They must be quoted, unless noted otherwise, if they are to appear in the\n prefix or suffix as literals.\n\n \u003cp\u003eThe characters listed here are used in non-localized patterns.  Localized\n patterns use the corresponding characters taken from this formatter\u0027s\n \u003ccode\u003eDecimalFormatSymbols\u003c/code\u003e object instead, and these characters lose\n their special status.  Two exceptions are the currency sign and quote, which\n are not localized.\n\n \u003cblockquote\u003e\n \u003ctable border\u003d0 cellspacing\u003d3 cellpadding\u003d0 summary\u003d\"Chart showing symbol,\n  location, localized, and meaning.\"\u003e\n     \u003ctr style\u003d\"background-color: rgb(204, 204, 255);\"\u003e\n          \u003cth align\u003dleft\u003eSymbol\n          \u003cth align\u003dleft\u003eLocation\n          \u003cth align\u003dleft\u003eLocalized?\n          \u003cth align\u003dleft\u003eMeaning\n     \u003ctr valign\u003dtop\u003e\n          \u003ctd\u003e\u003ccode\u003e0\u003c/code\u003e\n          \u003ctd\u003eNumber\n          \u003ctd\u003eYes\n          \u003ctd\u003eDigit\n     \u003ctr style\u003d\"vertical-align: top; background-color: rgb(238, 238, 255);\"\u003e\n          \u003ctd\u003e\u003ccode\u003e#\u003c/code\u003e\n          \u003ctd\u003eNumber\n          \u003ctd\u003eYes\n          \u003ctd\u003eDigit, zero shows as absent\n     \u003ctr valign\u003dtop\u003e\n          \u003ctd\u003e\u003ccode\u003e.\u003c/code\u003e\n          \u003ctd\u003eNumber\n          \u003ctd\u003eYes\n          \u003ctd\u003eDecimal separator or monetary decimal separator\n     \u003ctr style\u003d\"vertical-align: top; background-color: rgb(238, 238, 255);\"\u003e\n          \u003ctd\u003e\u003ccode\u003e-\u003c/code\u003e\n          \u003ctd\u003eNumber\n          \u003ctd\u003eYes\n          \u003ctd\u003eMinus sign\n     \u003ctr valign\u003dtop\u003e\n          \u003ctd\u003e\u003ccode\u003e,\u003c/code\u003e\n          \u003ctd\u003eNumber\n          \u003ctd\u003eYes\n          \u003ctd\u003eGrouping separator\n     \u003ctr style\u003d\"vertical-align: top; background-color: rgb(238, 238, 255);\"\u003e\n          \u003ctd\u003e\u003ccode\u003eE\u003c/code\u003e\n          \u003ctd\u003eNumber\n          \u003ctd\u003eYes\n          \u003ctd\u003eSeparates mantissa and exponent in scientific notation.\n              \u003cem\u003eNeed not be quoted in prefix or suffix.\u003c/em\u003e\n     \u003ctr valign\u003dtop\u003e\n          \u003ctd\u003e\u003ccode\u003e;\u003c/code\u003e\n          \u003ctd\u003eSubpattern boundary\n          \u003ctd\u003eYes\n          \u003ctd\u003eSeparates positive and negative subpatterns\n     \u003ctr style\u003d\"vertical-align: top; background-color: rgb(238, 238, 255);\"\u003e\n          \u003ctd\u003e\u003ccode\u003e%\u003c/code\u003e\n          \u003ctd\u003ePrefix or suffix\n          \u003ctd\u003eYes\n          \u003ctd\u003eMultiply by 100 and show as percentage\n     \u003ctr valign\u003dtop\u003e\n          \u003ctd\u003e\u003ccode\u003e\u0026#92;u2030\u003c/code\u003e\n          \u003ctd\u003ePrefix or suffix\n          \u003ctd\u003eYes\n          \u003ctd\u003eMultiply by 1000 and show as per mille value\n     \u003ctr style\u003d\"vertical-align: top; background-color: rgb(238, 238, 255);\"\u003e\n          \u003ctd\u003e\u003ccode\u003e\u0026#164;\u003c/code\u003e (\u003ccode\u003e\u0026#92;u00A4\u003c/code\u003e)\n          \u003ctd\u003ePrefix or suffix\n          \u003ctd\u003eNo\n          \u003ctd\u003eCurrency sign, replaced by currency symbol.  If\n              doubled, replaced by international currency symbol.\n              If present in a pattern, the monetary decimal separator\n              is used instead of the decimal separator.\n     \u003ctr valign\u003dtop\u003e\n          \u003ctd\u003e\u003ccode\u003e\u0027\u003c/code\u003e\n          \u003ctd\u003ePrefix or suffix\n          \u003ctd\u003eNo\n          \u003ctd\u003eUsed to quote special characters in a prefix or suffix,\n              for example, \u003ccode\u003e\"\u0027#\u0027#\"\u003c/code\u003e formats 123 to\n              \u003ccode\u003e\"#123\"\u003c/code\u003e.  To create a single quote\n              itself, use two in a row: \u003ccode\u003e\"# o\u0027\u0027clock\"\u003c/code\u003e.\n \u003c/table\u003e\n \u003c/blockquote\u003e\n\n \u003ch4\u003eScientific Notation\u003c/h4\u003e\n\n \u003cp\u003eNumbers in scientific notation are expressed as the product of a mantissa\n and a power of ten, for example, 1234 can be expressed as 1.234 x 10^3.  The\n mantissa is often in the range 1.0 \u0026le; x {@literal \u003c} 10.0, but it need not\n be.\n \u003ccode\u003eDecimalFormat\u003c/code\u003e can be instructed to format and parse scientific\n notation \u003cem\u003eonly via a pattern\u003c/em\u003e; there is currently no factory method\n that creates a scientific notation format.  In a pattern, the exponent\n character immediately followed by one or more digit characters indicates\n scientific notation.  Example: \u003ccode\u003e\"0.###E0\"\u003c/code\u003e formats the number\n 1234 as \u003ccode\u003e\"1.234E3\"\u003c/code\u003e.\n\n \u003cul\u003e\n \u003cli\u003eThe number of digit characters after the exponent character gives the\n minimum exponent digit count.  There is no maximum.  Negative exponents are\n formatted using the localized minus sign, \u003cem\u003enot\u003c/em\u003e the prefix and suffix\n from the pattern.  This allows patterns such as \u003ccode\u003e\"0.###E0 m/s\"\u003c/code\u003e.\n\n \u003cli\u003eThe minimum and maximum number of integer digits are interpreted\n together:\n\n \u003cul\u003e\n \u003cli\u003eIf the maximum number of integer digits is greater than their minimum number\n and greater than 1, it forces the exponent to be a multiple of the maximum\n number of integer digits, and the minimum number of integer digits to be\n interpreted as 1.  The most common use of this is to generate\n \u003cem\u003eengineering notation\u003c/em\u003e, in which the exponent is a multiple of three,\n e.g., \u003ccode\u003e\"##0.#####E0\"\u003c/code\u003e. Using this pattern, the number 12345\n formats to \u003ccode\u003e\"12.345E3\"\u003c/code\u003e, and 123456 formats to\n \u003ccode\u003e\"123.456E3\"\u003c/code\u003e.\n\n \u003cli\u003eOtherwise, the minimum number of integer digits is achieved by adjusting the\n exponent.  Example: 0.00123 formatted with \u003ccode\u003e\"00.###E0\"\u003c/code\u003e yields\n \u003ccode\u003e\"12.3E-4\"\u003c/code\u003e.\n \u003c/ul\u003e\n\n \u003cli\u003eThe number of significant digits in the mantissa is the sum of the\n \u003cem\u003eminimum integer\u003c/em\u003e and \u003cem\u003emaximum fraction\u003c/em\u003e digits, and is\n unaffected by the maximum integer digits.  For example, 12345 formatted with\n \u003ccode\u003e\"##0.##E0\"\u003c/code\u003e is \u003ccode\u003e\"12.3E3\"\u003c/code\u003e. To show all digits, set\n the significant digits count to zero.  The number of significant digits\n does not affect parsing.\n\n \u003cli\u003eExponential patterns may not contain grouping separators.\n \u003c/ul\u003e\n\n \u003ch4\u003eRounding\u003c/h4\u003e\n\n \u003ccode\u003eDecimalFormat\u003c/code\u003e provides rounding modes defined in\n {@link java.math.RoundingMode} for formatting.  By default, it uses\n {@link java.math.RoundingMode#HALF_EVEN RoundingMode.HALF_EVEN}.\n\n \u003ch4\u003eDigits\u003c/h4\u003e\n\n For formatting, \u003ccode\u003eDecimalFormat\u003c/code\u003e uses the ten consecutive\n characters starting with the localized zero digit defined in the\n \u003ccode\u003eDecimalFormatSymbols\u003c/code\u003e object as digits. For parsing, these\n digits as well as all Unicode decimal digits, as defined by\n {@link Character#digit Character.digit}, are recognized.\n\n \u003ch4\u003eSpecial Values\u003c/h4\u003e\n\n \u003cp\u003e\u003ccode\u003eNaN\u003c/code\u003e is formatted as a string, which typically has a single character\n \u003ccode\u003e\u0026#92;uFFFD\u003c/code\u003e.  This string is determined by the\n \u003ccode\u003eDecimalFormatSymbols\u003c/code\u003e object.  This is the only value for which\n the prefixes and suffixes are not used.\n\n \u003cp\u003eInfinity is formatted as a string, which typically has a single character\n \u003ccode\u003e\u0026#92;u221E\u003c/code\u003e, with the positive or negative prefixes and suffixes\n applied.  The infinity string is determined by the\n \u003ccode\u003eDecimalFormatSymbols\u003c/code\u003e object.\n\n \u003cp\u003eNegative zero (\u003ccode\u003e\"-0\"\u003c/code\u003e) parses to\n \u003cul\u003e\n \u003cli\u003e\u003ccode\u003eBigDecimal(0)\u003c/code\u003e if \u003ccode\u003eisParseBigDecimal()\u003c/code\u003e is\n true,\n \u003cli\u003e\u003ccode\u003eLong(0)\u003c/code\u003e if \u003ccode\u003eisParseBigDecimal()\u003c/code\u003e is false\n     and \u003ccode\u003eisParseIntegerOnly()\u003c/code\u003e is true,\n \u003cli\u003e\u003ccode\u003eDouble(-0.0)\u003c/code\u003e if both \u003ccode\u003eisParseBigDecimal()\u003c/code\u003e\n and \u003ccode\u003eisParseIntegerOnly()\u003c/code\u003e are false.\n \u003c/ul\u003e\n\n \u003ch4\u003e\u003ca name\u003d\"synchronization\"\u003eSynchronization\u003c/a\u003e\u003c/h4\u003e\n\n \u003cp\u003e\n Decimal formats are generally not synchronized.\n It is recommended to create separate format instances for each thread.\n If multiple threads access a format concurrently, it must be synchronized\n externally.\n\n \u003ch4\u003eExample\u003c/h4\u003e\n\n \u003cblockquote\u003e\u003cpre\u003e{@code\n \u003cstrong\u003e// Print out a number using the localized number, integer, currency,\n // and percent format for each locale\u003c/strong\u003e\n Locale[] locales \u003d NumberFormat.getAvailableLocales();\n double myNumber \u003d -1234.56;\n NumberFormat form;\n for (int j \u003d 0; j \u003c 4; ++j) {\n     System.out.println(\"FORMAT\");\n     for (int i \u003d 0; i \u003c locales.length; ++i) {\n         if (locales[i].getCountry().length() \u003d\u003d 0) {\n            continue; // Skip language-only locales\n         }\n         System.out.print(locales[i].getDisplayName());\n         switch (j) {\n         case 0:\n             form \u003d NumberFormat.getInstance(locales[i]); break;\n         case 1:\n             form \u003d NumberFormat.getIntegerInstance(locales[i]); break;\n         case 2:\n             form \u003d NumberFormat.getCurrencyInstance(locales[i]); break;\n         default:\n             form \u003d NumberFormat.getPercentInstance(locales[i]); break;\n         }\n         if (form instanceof DecimalFormat) {\n             System.out.print(\": \" + ((DecimalFormat) form).toPattern());\n         }\n         System.out.print(\" -\u003e \" + form.format(myNumber));\n         try {\n             System.out.println(\" -\u003e \" + form.parse(form.format(myNumber)));\n         } catch (ParseException e) {}\n     }\n }\n }\u003c/pre\u003e\u003c/blockquote\u003e","isClass":true,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":false,"isOrdinaryClass":true,"isPrimitive":false,"simpleName":"DecimalFormat","qualifiedName":"java.text.DecimalFormat","dimension":"","elementType":{},"package":"java.text","superclass":"java.text.NumberFormat","interfaces":[],"isAbstract":false,"isStatic":false,"innerClasses":[],"isInnerClass":false,"constructors":[{"name":"DecimalFormat","comment":"Creates a DecimalFormat using the default pattern and symbols\n for the default {@link java.util.Locale.Category#FORMAT FORMAT} locale.\n This is a convenient way to obtain a\n DecimalFormat when internationalization is not the main concern.\n \u003cp\u003e\n To obtain standard formats for a given locale, use the factory methods\n on NumberFormat such as getNumberInstance. These factories will\n return the most appropriate sub-class of NumberFormat for a given\n locale.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":true,"isField":false,"isMethod":false,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","parameters":[],"typeParameters":[]},{"name":"DecimalFormat","comment":"Creates a DecimalFormat using the given pattern and the symbols\n for the default {@link java.util.Locale.Category#FORMAT FORMAT} locale.\n This is a convenient way to obtain a\n DecimalFormat when internationalization is not the main concern.\n \u003cp\u003e\n To obtain standard formats for a given locale, use the factory methods\n on NumberFormat such as getNumberInstance. These factories will\n return the most appropriate sub-class of NumberFormat for a given\n locale.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":true,"isField":false,"isMethod":false,"isOrdinaryClass":false,"signature":"(java.lang.String)","flatSignature":"(String)","parameters":[{"name":"pattern","type":{"isPrimitive":false,"simpleName":"String","qualifiedName":"java.lang.String","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"DecimalFormat","comment":"Creates a DecimalFormat using the given pattern and symbols.\n Use this constructor when you need to completely customize the\n behavior of the format.\n \u003cp\u003e\n To obtain standard formats for a given\n locale, use the factory methods on NumberFormat such as\n getInstance or getCurrencyInstance. If you need only minor adjustments\n to a standard format, you can modify the format returned by\n a NumberFormat factory method.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":true,"isField":false,"isMethod":false,"isOrdinaryClass":false,"signature":"(java.lang.String, java.text.DecimalFormatSymbols)","flatSignature":"(String, DecimalFormatSymbols)","parameters":[{"name":"pattern","type":{"isPrimitive":false,"simpleName":"String","qualifiedName":"java.lang.String","dimension":"","elementType":{}}},{"name":"symbols","type":{"isPrimitive":false,"simpleName":"DecimalFormatSymbols","qualifiedName":"java.text.DecimalFormatSymbols","dimension":"","elementType":{}}}],"typeParameters":[]}],"fields":[],"methods":[{"name":"format","comment":"Formats a number and appends the resulting text to the given string\n buffer.\n The number can be of any subclass of {@link java.lang.Number}.\n \u003cp\u003e\n This implementation uses the maximum precision permitted.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.lang.Object, java.lang.StringBuffer, java.text.FieldPosition)","flatSignature":"(Object, StringBuffer, FieldPosition)","returnType":{"isPrimitive":false,"simpleName":"StringBuffer","qualifiedName":"java.lang.StringBuffer","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[{"name":"number","type":{"isPrimitive":false,"simpleName":"Object","qualifiedName":"java.lang.Object","dimension":"","elementType":{}}},{"name":"toAppendTo","type":{"isPrimitive":false,"simpleName":"StringBuffer","qualifiedName":"java.lang.StringBuffer","dimension":"","elementType":{}}},{"name":"pos","type":{"isPrimitive":false,"simpleName":"FieldPosition","qualifiedName":"java.text.FieldPosition","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"format","comment":"Formats a double to produce a string.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(double, java.lang.StringBuffer, java.text.FieldPosition)","flatSignature":"(double, StringBuffer, FieldPosition)","returnType":{"isPrimitive":false,"simpleName":"StringBuffer","qualifiedName":"java.lang.StringBuffer","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[{"name":"number","type":{"isPrimitive":true,"simpleName":"double","qualifiedName":"double","dimension":"","elementType":{}}},{"name":"result","type":{"isPrimitive":false,"simpleName":"StringBuffer","qualifiedName":"java.lang.StringBuffer","dimension":"","elementType":{}}},{"name":"fieldPosition","type":{"isPrimitive":false,"simpleName":"FieldPosition","qualifiedName":"java.text.FieldPosition","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"format","comment":"Format a long to produce a string.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(long, java.lang.StringBuffer, java.text.FieldPosition)","flatSignature":"(long, StringBuffer, FieldPosition)","returnType":{"isPrimitive":false,"simpleName":"StringBuffer","qualifiedName":"java.lang.StringBuffer","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[{"name":"number","type":{"isPrimitive":true,"simpleName":"long","qualifiedName":"long","dimension":"","elementType":{}}},{"name":"result","type":{"isPrimitive":false,"simpleName":"StringBuffer","qualifiedName":"java.lang.StringBuffer","dimension":"","elementType":{}}},{"name":"fieldPosition","type":{"isPrimitive":false,"simpleName":"FieldPosition","qualifiedName":"java.text.FieldPosition","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"formatToCharacterIterator","comment":"Formats an Object producing an \u003ccode\u003eAttributedCharacterIterator\u003c/code\u003e.\n You can use the returned \u003ccode\u003eAttributedCharacterIterator\u003c/code\u003e\n to build the resulting String, as well as to determine information\n about the resulting String.\n \u003cp\u003e\n Each attribute key of the AttributedCharacterIterator will be of type\n \u003ccode\u003eNumberFormat.Field\u003c/code\u003e, with the attribute value being the\n same as the attribute key.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.lang.Object)","flatSignature":"(Object)","returnType":{"isPrimitive":false,"simpleName":"AttributedCharacterIterator","qualifiedName":"java.text.AttributedCharacterIterator","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[{"name":"obj","type":{"isPrimitive":false,"simpleName":"Object","qualifiedName":"java.lang.Object","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"parse","comment":"Parses text from a string to produce a \u003ccode\u003eNumber\u003c/code\u003e.\n \u003cp\u003e\n The method attempts to parse text starting at the index given by\n \u003ccode\u003epos\u003c/code\u003e.\n If parsing succeeds, then the index of \u003ccode\u003epos\u003c/code\u003e is updated\n to the index after the last character used (parsing does not necessarily\n use all characters up to the end of the string), and the parsed\n number is returned. The updated \u003ccode\u003epos\u003c/code\u003e can be used to\n indicate the starting point for the next call to this method.\n If an error occurs, then the index of \u003ccode\u003epos\u003c/code\u003e is not\n changed, the error index of \u003ccode\u003epos\u003c/code\u003e is set to the index of\n the character where the error occurred, and null is returned.\n \u003cp\u003e\n The subclass returned depends on the value of {@link #isParseBigDecimal}\n as well as on the string being parsed.\n \u003cul\u003e\n   \u003cli\u003eIf \u003ccode\u003eisParseBigDecimal()\u003c/code\u003e is false (the default),\n       most integer values are returned as \u003ccode\u003eLong\u003c/code\u003e\n       objects, no matter how they are written: \u003ccode\u003e\"17\"\u003c/code\u003e and\n       \u003ccode\u003e\"17.000\"\u003c/code\u003e both parse to \u003ccode\u003eLong(17)\u003c/code\u003e.\n       Values that cannot fit into a \u003ccode\u003eLong\u003c/code\u003e are returned as\n       \u003ccode\u003eDouble\u003c/code\u003es. This includes values with a fractional part,\n       infinite values, \u003ccode\u003eNaN\u003c/code\u003e, and the value -0.0.\n       \u003ccode\u003eDecimalFormat\u003c/code\u003e does \u003cem\u003enot\u003c/em\u003e decide whether to\n       return a \u003ccode\u003eDouble\u003c/code\u003e or a \u003ccode\u003eLong\u003c/code\u003e based on the\n       presence of a decimal separator in the source string. Doing so\n       would prevent integers that overflow the mantissa of a double,\n       such as \u003ccode\u003e\"-9,223,372,036,854,775,808.00\"\u003c/code\u003e, from being\n       parsed accurately.\n       \u003cp\u003e\n       Callers may use the \u003ccode\u003eNumber\u003c/code\u003e methods\n       \u003ccode\u003edoubleValue\u003c/code\u003e, \u003ccode\u003elongValue\u003c/code\u003e, etc., to obtain\n       the type they want.\n   \u003cli\u003eIf \u003ccode\u003eisParseBigDecimal()\u003c/code\u003e is true, values are returned\n       as \u003ccode\u003eBigDecimal\u003c/code\u003e objects. The values are the ones\n       constructed by {@link java.math.BigDecimal#BigDecimal(String)}\n       for corresponding strings in locale-independent format. The\n       special cases negative and positive infinity and NaN are returned\n       as \u003ccode\u003eDouble\u003c/code\u003e instances holding the values of the\n       corresponding \u003ccode\u003eDouble\u003c/code\u003e constants.\n \u003c/ul\u003e\n \u003cp\u003e\n \u003ccode\u003eDecimalFormat\u003c/code\u003e parses all Unicode characters that represent\n decimal digits, as defined by \u003ccode\u003eCharacter.digit()\u003c/code\u003e. In\n addition, \u003ccode\u003eDecimalFormat\u003c/code\u003e also recognizes as digits the ten\n consecutive characters starting with the localized zero digit defined in\n the \u003ccode\u003eDecimalFormatSymbols\u003c/code\u003e object.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.lang.String, java.text.ParsePosition)","flatSignature":"(String, ParsePosition)","returnType":{"isPrimitive":false,"simpleName":"Number","qualifiedName":"java.lang.Number","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[{"name":"text","type":{"isPrimitive":false,"simpleName":"String","qualifiedName":"java.lang.String","dimension":"","elementType":{}}},{"name":"pos","type":{"isPrimitive":false,"simpleName":"ParsePosition","qualifiedName":"java.text.ParsePosition","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"getDecimalFormatSymbols","comment":"Returns a copy of the decimal format symbols, which is generally not\n changed by the programmer or user.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":false,"simpleName":"DecimalFormatSymbols","qualifiedName":"java.text.DecimalFormatSymbols","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[],"typeParameters":[]},{"name":"setDecimalFormatSymbols","comment":"Sets the decimal format symbols, which is generally not changed\n by the programmer or user.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.text.DecimalFormatSymbols)","flatSignature":"(DecimalFormatSymbols)","returnType":{"isPrimitive":true,"simpleName":"void","qualifiedName":"void","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[{"name":"newSymbols","type":{"isPrimitive":false,"simpleName":"DecimalFormatSymbols","qualifiedName":"java.text.DecimalFormatSymbols","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"getPositivePrefix","comment":"Get the positive prefix.\n \u003cP\u003eExamples: +123, $123, sFr123","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":false,"simpleName":"String","qualifiedName":"java.lang.String","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[],"typeParameters":[]},{"name":"setPositivePrefix","comment":"Set the positive prefix.\n \u003cP\u003eExamples: +123, $123, sFr123","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.lang.String)","flatSignature":"(String)","returnType":{"isPrimitive":true,"simpleName":"void","qualifiedName":"void","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[{"name":"newValue","type":{"isPrimitive":false,"simpleName":"String","qualifiedName":"java.lang.String","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"getNegativePrefix","comment":"Get the negative prefix.\n \u003cP\u003eExamples: -123, ($123) (with negative suffix), sFr-123","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":false,"simpleName":"String","qualifiedName":"java.lang.String","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[],"typeParameters":[]},{"name":"setNegativePrefix","comment":"Set the negative prefix.\n \u003cP\u003eExamples: -123, ($123) (with negative suffix), sFr-123","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.lang.String)","flatSignature":"(String)","returnType":{"isPrimitive":true,"simpleName":"void","qualifiedName":"void","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[{"name":"newValue","type":{"isPrimitive":false,"simpleName":"String","qualifiedName":"java.lang.String","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"getPositiveSuffix","comment":"Get the positive suffix.\n \u003cP\u003eExample: 123%","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":false,"simpleName":"String","qualifiedName":"java.lang.String","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[],"typeParameters":[]},{"name":"setPositiveSuffix","comment":"Set the positive suffix.\n \u003cP\u003eExample: 123%","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.lang.String)","flatSignature":"(String)","returnType":{"isPrimitive":true,"simpleName":"void","qualifiedName":"void","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[{"name":"newValue","type":{"isPrimitive":false,"simpleName":"String","qualifiedName":"java.lang.String","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"getNegativeSuffix","comment":"Get the negative suffix.\n \u003cP\u003eExamples: -123%, ($123) (with positive suffixes)","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":false,"simpleName":"String","qualifiedName":"java.lang.String","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[],"typeParameters":[]},{"name":"setNegativeSuffix","comment":"Set the negative suffix.\n \u003cP\u003eExamples: 123%","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.lang.String)","flatSignature":"(String)","returnType":{"isPrimitive":true,"simpleName":"void","qualifiedName":"void","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[{"name":"newValue","type":{"isPrimitive":false,"simpleName":"String","qualifiedName":"java.lang.String","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"getMultiplier","comment":"Gets the multiplier for use in percent, per mille, and similar\n formats.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[],"typeParameters":[]},{"name":"setMultiplier","comment":"Sets the multiplier for use in percent, per mille, and similar\n formats.\n For a percent format, set the multiplier to 100 and the suffixes to\n have \u0027%\u0027 (for Arabic, use the Arabic percent sign).\n For a per mille format, set the multiplier to 1000 and the suffixes to\n have \u0027\u0026#92;u2030\u0027.\n\n \u003cP\u003eExample: with multiplier 100, 1.23 is formatted as \"123\", and\n \"123\" is parsed into 1.23.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(int)","flatSignature":"(int)","returnType":{"isPrimitive":true,"simpleName":"void","qualifiedName":"void","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[{"name":"newValue","type":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"setGroupingUsed","comment":"{@inheritDoc}","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(boolean)","flatSignature":"(boolean)","returnType":{"isPrimitive":true,"simpleName":"void","qualifiedName":"void","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[{"name":"newValue","type":{"isPrimitive":true,"simpleName":"boolean","qualifiedName":"boolean","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"getGroupingSize","comment":"Return the grouping size. Grouping size is the number of digits between\n grouping separators in the integer portion of a number.  For example,\n in the number \"123,456.78\", the grouping size is 3.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[],"typeParameters":[]},{"name":"setGroupingSize","comment":"Set the grouping size. Grouping size is the number of digits between\n grouping separators in the integer portion of a number.  For example,\n in the number \"123,456.78\", the grouping size is 3.\n \u003cbr\u003e\n The value passed in is converted to a byte, which may lose information.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(int)","flatSignature":"(int)","returnType":{"isPrimitive":true,"simpleName":"void","qualifiedName":"void","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[{"name":"newValue","type":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"isDecimalSeparatorAlwaysShown","comment":"Allows you to get the behavior of the decimal separator with integers.\n (The decimal separator will always appear with decimals.)\n \u003cP\u003eExample: Decimal ON: 12345 \u0026rarr; 12345.; OFF: 12345 \u0026rarr; 12345","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":true,"simpleName":"boolean","qualifiedName":"boolean","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[],"typeParameters":[]},{"name":"setDecimalSeparatorAlwaysShown","comment":"Allows you to set the behavior of the decimal separator with integers.\n (The decimal separator will always appear with decimals.)\n \u003cP\u003eExample: Decimal ON: 12345 \u0026rarr; 12345.; OFF: 12345 \u0026rarr; 12345","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(boolean)","flatSignature":"(boolean)","returnType":{"isPrimitive":true,"simpleName":"void","qualifiedName":"void","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[{"name":"newValue","type":{"isPrimitive":true,"simpleName":"boolean","qualifiedName":"boolean","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"isParseBigDecimal","comment":"Returns whether the {@link #parse(java.lang.String, java.text.ParsePosition)}\n method returns \u003ccode\u003eBigDecimal\u003c/code\u003e. The default value is false.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":true,"simpleName":"boolean","qualifiedName":"boolean","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[],"typeParameters":[]},{"name":"setParseBigDecimal","comment":"Sets whether the {@link #parse(java.lang.String, java.text.ParsePosition)}\n method returns \u003ccode\u003eBigDecimal\u003c/code\u003e.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(boolean)","flatSignature":"(boolean)","returnType":{"isPrimitive":true,"simpleName":"void","qualifiedName":"void","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[{"name":"newValue","type":{"isPrimitive":true,"simpleName":"boolean","qualifiedName":"boolean","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"clone","comment":"Standard override; no change in semantics.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":false,"simpleName":"Object","qualifiedName":"java.lang.Object","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[],"typeParameters":[]},{"name":"equals","comment":"Overrides equals","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.lang.Object)","flatSignature":"(Object)","returnType":{"isPrimitive":true,"simpleName":"boolean","qualifiedName":"boolean","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[{"name":"obj","type":{"isPrimitive":false,"simpleName":"Object","qualifiedName":"java.lang.Object","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"hashCode","comment":"Overrides hashCode","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[],"typeParameters":[]},{"name":"toPattern","comment":"Synthesizes a pattern string that represents the current state\n of this Format object.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":false,"simpleName":"String","qualifiedName":"java.lang.String","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[],"typeParameters":[]},{"name":"toLocalizedPattern","comment":"Synthesizes a localized pattern string that represents the current\n state of this Format object.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":false,"simpleName":"String","qualifiedName":"java.lang.String","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[],"typeParameters":[]},{"name":"applyPattern","comment":"Apply the given pattern to this Format object.  A pattern is a\n short-hand specification for the various formatting properties.\n These properties can also be changed individually through the\n various setter methods.\n \u003cp\u003e\n There is no limit to integer digits set\n by this routine, since that is the typical end-user desire;\n use setMaximumInteger if you want to set a real value.\n For negative numbers, use a second pattern, separated by a semicolon\n \u003cP\u003eExample \u003ccode\u003e\"#,#00.0#\"\u003c/code\u003e \u0026rarr; 1,234.56\n \u003cP\u003eThis means a minimum of 2 integer digits, 1 fraction digit, and\n a maximum of 2 fraction digits.\n \u003cp\u003eExample: \u003ccode\u003e\"#,#00.0#;(#,#00.0#)\"\u003c/code\u003e for negatives in\n parentheses.\n \u003cp\u003eIn negative patterns, the minimum and maximum counts are ignored;\n these are presumed to be set in the positive pattern.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.lang.String)","flatSignature":"(String)","returnType":{"isPrimitive":true,"simpleName":"void","qualifiedName":"void","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[{"name":"pattern","type":{"isPrimitive":false,"simpleName":"String","qualifiedName":"java.lang.String","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"applyLocalizedPattern","comment":"Apply the given pattern to this Format object.  The pattern\n is assumed to be in a localized notation. A pattern is a\n short-hand specification for the various formatting properties.\n These properties can also be changed individually through the\n various setter methods.\n \u003cp\u003e\n There is no limit to integer digits set\n by this routine, since that is the typical end-user desire;\n use setMaximumInteger if you want to set a real value.\n For negative numbers, use a second pattern, separated by a semicolon\n \u003cP\u003eExample \u003ccode\u003e\"#,#00.0#\"\u003c/code\u003e \u0026rarr; 1,234.56\n \u003cP\u003eThis means a minimum of 2 integer digits, 1 fraction digit, and\n a maximum of 2 fraction digits.\n \u003cp\u003eExample: \u003ccode\u003e\"#,#00.0#;(#,#00.0#)\"\u003c/code\u003e for negatives in\n parentheses.\n \u003cp\u003eIn negative patterns, the minimum and maximum counts are ignored;\n these are presumed to be set in the positive pattern.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.lang.String)","flatSignature":"(String)","returnType":{"isPrimitive":true,"simpleName":"void","qualifiedName":"void","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[{"name":"pattern","type":{"isPrimitive":false,"simpleName":"String","qualifiedName":"java.lang.String","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"setMaximumIntegerDigits","comment":"Sets the maximum number of digits allowed in the integer portion of a\n number.\n For formatting numbers other than \u003ccode\u003eBigInteger\u003c/code\u003e and\n \u003ccode\u003eBigDecimal\u003c/code\u003e objects, the lower of \u003ccode\u003enewValue\u003c/code\u003e and\n 309 is used. Negative input values are replaced with 0.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(int)","flatSignature":"(int)","returnType":{"isPrimitive":true,"simpleName":"void","qualifiedName":"void","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[{"name":"newValue","type":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"setMinimumIntegerDigits","comment":"Sets the minimum number of digits allowed in the integer portion of a\n number.\n For formatting numbers other than \u003ccode\u003eBigInteger\u003c/code\u003e and\n \u003ccode\u003eBigDecimal\u003c/code\u003e objects, the lower of \u003ccode\u003enewValue\u003c/code\u003e and\n 309 is used. Negative input values are replaced with 0.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(int)","flatSignature":"(int)","returnType":{"isPrimitive":true,"simpleName":"void","qualifiedName":"void","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[{"name":"newValue","type":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"setMaximumFractionDigits","comment":"Sets the maximum number of digits allowed in the fraction portion of a\n number.\n For formatting numbers other than \u003ccode\u003eBigInteger\u003c/code\u003e and\n \u003ccode\u003eBigDecimal\u003c/code\u003e objects, the lower of \u003ccode\u003enewValue\u003c/code\u003e and\n 340 is used. Negative input values are replaced with 0.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(int)","flatSignature":"(int)","returnType":{"isPrimitive":true,"simpleName":"void","qualifiedName":"void","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[{"name":"newValue","type":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"setMinimumFractionDigits","comment":"Sets the minimum number of digits allowed in the fraction portion of a\n number.\n For formatting numbers other than \u003ccode\u003eBigInteger\u003c/code\u003e and\n \u003ccode\u003eBigDecimal\u003c/code\u003e objects, the lower of \u003ccode\u003enewValue\u003c/code\u003e and\n 340 is used. Negative input values are replaced with 0.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(int)","flatSignature":"(int)","returnType":{"isPrimitive":true,"simpleName":"void","qualifiedName":"void","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[{"name":"newValue","type":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"getMaximumIntegerDigits","comment":"Gets the maximum number of digits allowed in the integer portion of a\n number.\n For formatting numbers other than \u003ccode\u003eBigInteger\u003c/code\u003e and\n \u003ccode\u003eBigDecimal\u003c/code\u003e objects, the lower of the return value and\n 309 is used.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[],"typeParameters":[]},{"name":"getMinimumIntegerDigits","comment":"Gets the minimum number of digits allowed in the integer portion of a\n number.\n For formatting numbers other than \u003ccode\u003eBigInteger\u003c/code\u003e and\n \u003ccode\u003eBigDecimal\u003c/code\u003e objects, the lower of the return value and\n 309 is used.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[],"typeParameters":[]},{"name":"getMaximumFractionDigits","comment":"Gets the maximum number of digits allowed in the fraction portion of a\n number.\n For formatting numbers other than \u003ccode\u003eBigInteger\u003c/code\u003e and\n \u003ccode\u003eBigDecimal\u003c/code\u003e objects, the lower of the return value and\n 340 is used.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[],"typeParameters":[]},{"name":"getMinimumFractionDigits","comment":"Gets the minimum number of digits allowed in the fraction portion of a\n number.\n For formatting numbers other than \u003ccode\u003eBigInteger\u003c/code\u003e and\n \u003ccode\u003eBigDecimal\u003c/code\u003e objects, the lower of the return value and\n 340 is used.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[],"typeParameters":[]},{"name":"getCurrency","comment":"Gets the currency used by this decimal format when formatting\n currency values.\n The currency is obtained by calling\n {@link DecimalFormatSymbols#getCurrency DecimalFormatSymbols.getCurrency}\n on this number format\u0027s symbols.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":false,"simpleName":"Currency","qualifiedName":"java.util.Currency","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[],"typeParameters":[]},{"name":"setCurrency","comment":"Sets the currency used by this number format when formatting\n currency values. This does not update the minimum or maximum\n number of fraction digits used by the number format.\n The currency is set by calling\n {@link DecimalFormatSymbols#setCurrency DecimalFormatSymbols.setCurrency}\n on this number format\u0027s symbols.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.util.Currency)","flatSignature":"(Currency)","returnType":{"isPrimitive":true,"simpleName":"void","qualifiedName":"void","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[{"name":"currency","type":{"isPrimitive":false,"simpleName":"Currency","qualifiedName":"java.util.Currency","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"getRoundingMode","comment":"Gets the {@link java.math.RoundingMode} used in this DecimalFormat.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":false,"simpleName":"RoundingMode","qualifiedName":"java.math.RoundingMode","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[],"typeParameters":[]},{"name":"setRoundingMode","comment":"Sets the {@link java.math.RoundingMode} used in this DecimalFormat.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.math.RoundingMode)","flatSignature":"(RoundingMode)","returnType":{"isPrimitive":true,"simpleName":"void","qualifiedName":"void","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[{"name":"roundingMode","type":{"isPrimitive":false,"simpleName":"RoundingMode","qualifiedName":"java.math.RoundingMode","dimension":"","elementType":{}}}],"typeParameters":[]}],"typeParameters":[],"enumConstants":[]}