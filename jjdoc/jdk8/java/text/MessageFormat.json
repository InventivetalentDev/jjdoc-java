{"name":"MessageFormat","comment":"\u003ccode\u003eMessageFormat\u003c/code\u003e provides a means to produce concatenated\n messages in a language-neutral way. Use this to construct messages\n displayed for end users.\n\n \u003cp\u003e\n \u003ccode\u003eMessageFormat\u003c/code\u003e takes a set of objects, formats them, then\n inserts the formatted strings into the pattern at the appropriate places.\n\n \u003cp\u003e\n \u003cstrong\u003eNote:\u003c/strong\u003e\n \u003ccode\u003eMessageFormat\u003c/code\u003e differs from the other \u003ccode\u003eFormat\u003c/code\u003e\n classes in that you create a \u003ccode\u003eMessageFormat\u003c/code\u003e object with one\n of its constructors (not with a \u003ccode\u003egetInstance\u003c/code\u003e style factory\n method). The factory methods aren\u0027t necessary because \u003ccode\u003eMessageFormat\u003c/code\u003e\n itself doesn\u0027t implement locale specific behavior. Any locale specific\n behavior is defined by the pattern that you provide as well as the\n subformats used for inserted arguments.\n\n \u003ch3\u003e\u003ca name\u003d\"patterns\"\u003ePatterns and Their Interpretation\u003c/a\u003e\u003c/h3\u003e\n\n \u003ccode\u003eMessageFormat\u003c/code\u003e uses patterns of the following form:\n \u003cblockquote\u003e\u003cpre\u003e\n \u003ci\u003eMessageFormatPattern:\u003c/i\u003e\n         \u003ci\u003eString\u003c/i\u003e\n         \u003ci\u003eMessageFormatPattern\u003c/i\u003e \u003ci\u003eFormatElement\u003c/i\u003e \u003ci\u003eString\u003c/i\u003e\n\n \u003ci\u003eFormatElement:\u003c/i\u003e\n         { \u003ci\u003eArgumentIndex\u003c/i\u003e }\n         { \u003ci\u003eArgumentIndex\u003c/i\u003e , \u003ci\u003eFormatType\u003c/i\u003e }\n         { \u003ci\u003eArgumentIndex\u003c/i\u003e , \u003ci\u003eFormatType\u003c/i\u003e , \u003ci\u003eFormatStyle\u003c/i\u003e }\n\n \u003ci\u003eFormatType: one of \u003c/i\u003e\n         number date time choice\n\n \u003ci\u003eFormatStyle:\u003c/i\u003e\n         short\n         medium\n         long\n         full\n         integer\n         currency\n         percent\n         \u003ci\u003eSubformatPattern\u003c/i\u003e\n \u003c/pre\u003e\u003c/blockquote\u003e\n\n \u003cp\u003eWithin a \u003ci\u003eString\u003c/i\u003e, a pair of single quotes can be used to\n quote any arbitrary characters except single quotes. For example,\n pattern string \u003ccode\u003e\"\u0027{0}\u0027\"\u003c/code\u003e represents string\n \u003ccode\u003e\"{0}\"\u003c/code\u003e, not a \u003ci\u003eFormatElement\u003c/i\u003e. A single quote itself\n must be represented by doubled single quotes {@code \u0027\u0027} throughout a\n \u003ci\u003eString\u003c/i\u003e.  For example, pattern string \u003ccode\u003e\"\u0027{\u0027\u0027}\u0027\"\u003c/code\u003e is\n interpreted as a sequence of \u003ccode\u003e\u0027{\u003c/code\u003e (start of quoting and a\n left curly brace), \u003ccode\u003e\u0027\u0027\u003c/code\u003e (a single quote), and\n \u003ccode\u003e}\u0027\u003c/code\u003e (a right curly brace and end of quoting),\n \u003cem\u003enot\u003c/em\u003e \u003ccode\u003e\u0027{\u0027\u003c/code\u003e and \u003ccode\u003e\u0027}\u0027\u003c/code\u003e (quoted left and\n right curly braces): representing string \u003ccode\u003e\"{\u0027}\"\u003c/code\u003e,\n \u003cem\u003enot\u003c/em\u003e \u003ccode\u003e\"{}\"\u003c/code\u003e.\n\n \u003cp\u003eA \u003ci\u003eSubformatPattern\u003c/i\u003e is interpreted by its corresponding\n subformat, and subformat-dependent pattern rules apply. For example,\n pattern string \u003ccode\u003e\"{1,number,\u003cu\u003e$\u0027#\u0027,##\u003c/u\u003e}\"\u003c/code\u003e\n (\u003ci\u003eSubformatPattern\u003c/i\u003e with underline) will produce a number format\n with the pound-sign quoted, with a result such as: {@code\n \"$#31,45\"}. Refer to each {@code Format} subclass documentation for\n details.\n\n \u003cp\u003eAny unmatched quote is treated as closed at the end of the given\n pattern. For example, pattern string {@code \"\u0027{0}\"} is treated as\n pattern {@code \"\u0027{0}\u0027\"}.\n\n \u003cp\u003eAny curly braces within an unquoted pattern must be balanced. For\n example, \u003ccode\u003e\"ab {0} de\"\u003c/code\u003e and \u003ccode\u003e\"ab \u0027}\u0027 de\"\u003c/code\u003e are\n valid patterns, but \u003ccode\u003e\"ab {0\u0027}\u0027 de\"\u003c/code\u003e, \u003ccode\u003e\"ab } de\"\u003c/code\u003e\n and \u003ccode\u003e\"\u0027\u0027{\u0027\u0027\"\u003c/code\u003e are not.\n\n \u003cdl\u003e\u003cdt\u003e\u003cb\u003eWarning:\u003c/b\u003e\u003cdd\u003eThe rules for using quotes within message\n format patterns unfortunately have shown to be somewhat confusing.\n In particular, it isn\u0027t always obvious to localizers whether single\n quotes need to be doubled or not. Make sure to inform localizers about\n the rules, and tell them (for example, by using comments in resource\n bundle source files) which strings will be processed by {@code MessageFormat}.\n Note that localizers may need to use single quotes in translated\n strings where the original version doesn\u0027t have them.\n \u003c/dl\u003e\n \u003cp\u003e\n The \u003ci\u003eArgumentIndex\u003c/i\u003e value is a non-negative integer written\n using the digits {@code \u00270\u0027} through {@code \u00279\u0027}, and represents an index into the\n {@code arguments} array passed to the {@code format} methods\n or the result array returned by the {@code parse} methods.\n \u003cp\u003e\n The \u003ci\u003eFormatType\u003c/i\u003e and \u003ci\u003eFormatStyle\u003c/i\u003e values are used to create\n a {@code Format} instance for the format element. The following\n table shows how the values map to {@code Format} instances. Combinations not\n shown in the table are illegal. A \u003ci\u003eSubformatPattern\u003c/i\u003e must\n be a valid pattern string for the {@code Format} subclass used.\n\n \u003ctable border\u003d1 summary\u003d\"Shows how FormatType and FormatStyle values map to Format instances\"\u003e\n    \u003ctr\u003e\n       \u003cth id\u003d\"ft\" class\u003d\"TableHeadingColor\"\u003eFormatType\n       \u003cth id\u003d\"fs\" class\u003d\"TableHeadingColor\"\u003eFormatStyle\n       \u003cth id\u003d\"sc\" class\u003d\"TableHeadingColor\"\u003eSubformat Created\n    \u003ctr\u003e\n       \u003ctd headers\u003d\"ft\"\u003e\u003ci\u003e(none)\u003c/i\u003e\n       \u003ctd headers\u003d\"fs\"\u003e\u003ci\u003e(none)\u003c/i\u003e\n       \u003ctd headers\u003d\"sc\"\u003e\u003ccode\u003enull\u003c/code\u003e\n    \u003ctr\u003e\n       \u003ctd headers\u003d\"ft\" rowspan\u003d5\u003e\u003ccode\u003enumber\u003c/code\u003e\n       \u003ctd headers\u003d\"fs\"\u003e\u003ci\u003e(none)\u003c/i\u003e\n       \u003ctd headers\u003d\"sc\"\u003e{@link NumberFormat#getInstance(Locale) NumberFormat.getInstance}{@code (getLocale())}\n    \u003ctr\u003e\n       \u003ctd headers\u003d\"fs\"\u003e\u003ccode\u003einteger\u003c/code\u003e\n       \u003ctd headers\u003d\"sc\"\u003e{@link NumberFormat#getIntegerInstance(Locale) NumberFormat.getIntegerInstance}{@code (getLocale())}\n    \u003ctr\u003e\n       \u003ctd headers\u003d\"fs\"\u003e\u003ccode\u003ecurrency\u003c/code\u003e\n       \u003ctd headers\u003d\"sc\"\u003e{@link NumberFormat#getCurrencyInstance(Locale) NumberFormat.getCurrencyInstance}{@code (getLocale())}\n    \u003ctr\u003e\n       \u003ctd headers\u003d\"fs\"\u003e\u003ccode\u003epercent\u003c/code\u003e\n       \u003ctd headers\u003d\"sc\"\u003e{@link NumberFormat#getPercentInstance(Locale) NumberFormat.getPercentInstance}{@code (getLocale())}\n    \u003ctr\u003e\n       \u003ctd headers\u003d\"fs\"\u003e\u003ci\u003eSubformatPattern\u003c/i\u003e\n       \u003ctd headers\u003d\"sc\"\u003e{@code new} {@link DecimalFormat#DecimalFormat(String,DecimalFormatSymbols) DecimalFormat}{@code (subformatPattern,} {@link DecimalFormatSymbols#getInstance(Locale) DecimalFormatSymbols.getInstance}{@code (getLocale()))}\n    \u003ctr\u003e\n       \u003ctd headers\u003d\"ft\" rowspan\u003d6\u003e\u003ccode\u003edate\u003c/code\u003e\n       \u003ctd headers\u003d\"fs\"\u003e\u003ci\u003e(none)\u003c/i\u003e\n       \u003ctd headers\u003d\"sc\"\u003e{@link DateFormat#getDateInstance(int,Locale) DateFormat.getDateInstance}{@code (}{@link DateFormat#DEFAULT}{@code , getLocale())}\n    \u003ctr\u003e\n       \u003ctd headers\u003d\"fs\"\u003e\u003ccode\u003eshort\u003c/code\u003e\n       \u003ctd headers\u003d\"sc\"\u003e{@link DateFormat#getDateInstance(int,Locale) DateFormat.getDateInstance}{@code (}{@link DateFormat#SHORT}{@code , getLocale())}\n    \u003ctr\u003e\n       \u003ctd headers\u003d\"fs\"\u003e\u003ccode\u003emedium\u003c/code\u003e\n       \u003ctd headers\u003d\"sc\"\u003e{@link DateFormat#getDateInstance(int,Locale) DateFormat.getDateInstance}{@code (}{@link DateFormat#DEFAULT}{@code , getLocale())}\n    \u003ctr\u003e\n       \u003ctd headers\u003d\"fs\"\u003e\u003ccode\u003elong\u003c/code\u003e\n       \u003ctd headers\u003d\"sc\"\u003e{@link DateFormat#getDateInstance(int,Locale) DateFormat.getDateInstance}{@code (}{@link DateFormat#LONG}{@code , getLocale())}\n    \u003ctr\u003e\n       \u003ctd headers\u003d\"fs\"\u003e\u003ccode\u003efull\u003c/code\u003e\n       \u003ctd headers\u003d\"sc\"\u003e{@link DateFormat#getDateInstance(int,Locale) DateFormat.getDateInstance}{@code (}{@link DateFormat#FULL}{@code , getLocale())}\n    \u003ctr\u003e\n       \u003ctd headers\u003d\"fs\"\u003e\u003ci\u003eSubformatPattern\u003c/i\u003e\n       \u003ctd headers\u003d\"sc\"\u003e{@code new} {@link SimpleDateFormat#SimpleDateFormat(String,Locale) SimpleDateFormat}{@code (subformatPattern, getLocale())}\n    \u003ctr\u003e\n       \u003ctd headers\u003d\"ft\" rowspan\u003d6\u003e\u003ccode\u003etime\u003c/code\u003e\n       \u003ctd headers\u003d\"fs\"\u003e\u003ci\u003e(none)\u003c/i\u003e\n       \u003ctd headers\u003d\"sc\"\u003e{@link DateFormat#getTimeInstance(int,Locale) DateFormat.getTimeInstance}{@code (}{@link DateFormat#DEFAULT}{@code , getLocale())}\n    \u003ctr\u003e\n       \u003ctd headers\u003d\"fs\"\u003e\u003ccode\u003eshort\u003c/code\u003e\n       \u003ctd headers\u003d\"sc\"\u003e{@link DateFormat#getTimeInstance(int,Locale) DateFormat.getTimeInstance}{@code (}{@link DateFormat#SHORT}{@code , getLocale())}\n    \u003ctr\u003e\n       \u003ctd headers\u003d\"fs\"\u003e\u003ccode\u003emedium\u003c/code\u003e\n       \u003ctd headers\u003d\"sc\"\u003e{@link DateFormat#getTimeInstance(int,Locale) DateFormat.getTimeInstance}{@code (}{@link DateFormat#DEFAULT}{@code , getLocale())}\n    \u003ctr\u003e\n       \u003ctd headers\u003d\"fs\"\u003e\u003ccode\u003elong\u003c/code\u003e\n       \u003ctd headers\u003d\"sc\"\u003e{@link DateFormat#getTimeInstance(int,Locale) DateFormat.getTimeInstance}{@code (}{@link DateFormat#LONG}{@code , getLocale())}\n    \u003ctr\u003e\n       \u003ctd headers\u003d\"fs\"\u003e\u003ccode\u003efull\u003c/code\u003e\n       \u003ctd headers\u003d\"sc\"\u003e{@link DateFormat#getTimeInstance(int,Locale) DateFormat.getTimeInstance}{@code (}{@link DateFormat#FULL}{@code , getLocale())}\n    \u003ctr\u003e\n       \u003ctd headers\u003d\"fs\"\u003e\u003ci\u003eSubformatPattern\u003c/i\u003e\n       \u003ctd headers\u003d\"sc\"\u003e{@code new} {@link SimpleDateFormat#SimpleDateFormat(String,Locale) SimpleDateFormat}{@code (subformatPattern, getLocale())}\n    \u003ctr\u003e\n       \u003ctd headers\u003d\"ft\"\u003e\u003ccode\u003echoice\u003c/code\u003e\n       \u003ctd headers\u003d\"fs\"\u003e\u003ci\u003eSubformatPattern\u003c/i\u003e\n       \u003ctd headers\u003d\"sc\"\u003e{@code new} {@link ChoiceFormat#ChoiceFormat(String) ChoiceFormat}{@code (subformatPattern)}\n \u003c/table\u003e\n\n \u003ch4\u003eUsage Information\u003c/h4\u003e\n\n \u003cp\u003e\n Here are some examples of usage.\n In real internationalized programs, the message format pattern and other\n static strings will, of course, be obtained from resource bundles.\n Other parameters will be dynamically determined at runtime.\n \u003cp\u003e\n The first example uses the static method \u003ccode\u003eMessageFormat.format\u003c/code\u003e,\n which internally creates a \u003ccode\u003eMessageFormat\u003c/code\u003e for one-time use:\n \u003cblockquote\u003e\u003cpre\u003e\n int planet \u003d 7;\n String event \u003d \"a disturbance in the Force\";\n\n String result \u003d MessageFormat.format(\n     \"At {1,time} on {1,date}, there was {2} on planet {0,number,integer}.\",\n     planet, new Date(), event);\n \u003c/pre\u003e\u003c/blockquote\u003e\n The output is:\n \u003cblockquote\u003e\u003cpre\u003e\n At 12:30 PM on Jul 3, 2053, there was a disturbance in the Force on planet 7.\n \u003c/pre\u003e\u003c/blockquote\u003e\n\n \u003cp\u003e\n The following example creates a \u003ccode\u003eMessageFormat\u003c/code\u003e instance that\n can be used repeatedly:\n \u003cblockquote\u003e\u003cpre\u003e\n int fileCount \u003d 1273;\n String diskName \u003d \"MyDisk\";\n Object[] testArgs \u003d {new Long(fileCount), diskName};\n\n MessageFormat form \u003d new MessageFormat(\n     \"The disk \\\"{1}\\\" contains {0} file(s).\");\n\n System.out.println(form.format(testArgs));\n \u003c/pre\u003e\u003c/blockquote\u003e\n The output with different values for \u003ccode\u003efileCount\u003c/code\u003e:\n \u003cblockquote\u003e\u003cpre\u003e\n The disk \"MyDisk\" contains 0 file(s).\n The disk \"MyDisk\" contains 1 file(s).\n The disk \"MyDisk\" contains 1,273 file(s).\n \u003c/pre\u003e\u003c/blockquote\u003e\n\n \u003cp\u003e\n For more sophisticated patterns, you can use a \u003ccode\u003eChoiceFormat\u003c/code\u003e\n to produce correct forms for singular and plural:\n \u003cblockquote\u003e\u003cpre\u003e\n MessageFormat form \u003d new MessageFormat(\"The disk \\\"{1}\\\" contains {0}.\");\n double[] filelimits \u003d {0,1,2};\n String[] filepart \u003d {\"no files\",\"one file\",\"{0,number} files\"};\n ChoiceFormat fileform \u003d new ChoiceFormat(filelimits, filepart);\n form.setFormatByArgumentIndex(0, fileform);\n\n int fileCount \u003d 1273;\n String diskName \u003d \"MyDisk\";\n Object[] testArgs \u003d {new Long(fileCount), diskName};\n\n System.out.println(form.format(testArgs));\n \u003c/pre\u003e\u003c/blockquote\u003e\n The output with different values for \u003ccode\u003efileCount\u003c/code\u003e:\n \u003cblockquote\u003e\u003cpre\u003e\n The disk \"MyDisk\" contains no files.\n The disk \"MyDisk\" contains one file.\n The disk \"MyDisk\" contains 1,273 files.\n \u003c/pre\u003e\u003c/blockquote\u003e\n\n \u003cp\u003e\n You can create the \u003ccode\u003eChoiceFormat\u003c/code\u003e programmatically, as in the\n above example, or by using a pattern. See {@link ChoiceFormat}\n for more information.\n \u003cblockquote\u003e\u003cpre\u003e{@code\n form.applyPattern(\n    \"There {0,choice,0#are no files|1#is one file|1\u003care {0,number,integer} files}.\");\n }\u003c/pre\u003e\u003c/blockquote\u003e\n\n \u003cp\u003e\n \u003cstrong\u003eNote:\u003c/strong\u003e As we see above, the string produced\n by a \u003ccode\u003eChoiceFormat\u003c/code\u003e in \u003ccode\u003eMessageFormat\u003c/code\u003e is treated as special;\n occurrences of \u0027{\u0027 are used to indicate subformats, and cause recursion.\n If you create both a \u003ccode\u003eMessageFormat\u003c/code\u003e and \u003ccode\u003eChoiceFormat\u003c/code\u003e\n programmatically (instead of using the string patterns), then be careful not to\n produce a format that recurses on itself, which will cause an infinite loop.\n \u003cp\u003e\n When a single argument is parsed more than once in the string, the last match\n will be the final result of the parsing.  For example,\n \u003cblockquote\u003e\u003cpre\u003e\n MessageFormat mf \u003d new MessageFormat(\"{0,number,#.##}, {0,number,#.#}\");\n Object[] objs \u003d {new Double(3.1415)};\n String result \u003d mf.format( objs );\n // result now equals \"3.14, 3.1\"\n objs \u003d null;\n objs \u003d mf.parse(result, new ParsePosition(0));\n // objs now equals {new Double(3.1)}\n \u003c/pre\u003e\u003c/blockquote\u003e\n\n \u003cp\u003e\n Likewise, parsing with a {@code MessageFormat} object using patterns containing\n multiple occurrences of the same argument would return the last match.  For\n example,\n \u003cblockquote\u003e\u003cpre\u003e\n MessageFormat mf \u003d new MessageFormat(\"{0}, {0}, {0}\");\n String forParsing \u003d \"x, y, z\";\n Object[] objs \u003d mf.parse(forParsing, new ParsePosition(0));\n // result now equals {new String(\"z\")}\n \u003c/pre\u003e\u003c/blockquote\u003e\n\n \u003ch4\u003e\u003ca name\u003d\"synchronization\"\u003eSynchronization\u003c/a\u003e\u003c/h4\u003e\n\n \u003cp\u003e\n Message formats are not synchronized.\n It is recommended to create separate format instances for each thread.\n If multiple threads access a format concurrently, it must be synchronized\n externally.","isClass":true,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":false,"isOrdinaryClass":true,"isPrimitive":false,"simpleName":"MessageFormat","qualifiedName":"java.text.MessageFormat","dimension":"","elementType":{},"package":"java.text","superclass":"java.text.Format","interfaces":[],"isAbstract":false,"isStatic":false,"innerClasses":["java.text.MessageFormat.Field"],"isInnerClass":false,"constructors":[{"name":"MessageFormat","comment":"Constructs a MessageFormat for the default\n {@link java.util.Locale.Category#FORMAT FORMAT} locale and the\n specified pattern.\n The constructor first sets the locale, then parses the pattern and\n creates a list of subformats for the format elements contained in it.\n Patterns and their interpretation are specified in the\n \u003ca href\u003d\"#patterns\"\u003eclass description\u003c/a\u003e.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":true,"isField":false,"isMethod":false,"isOrdinaryClass":false,"signature":"(java.lang.String)","flatSignature":"(String)","parameters":[{"name":"pattern","type":{"isPrimitive":false,"simpleName":"String","qualifiedName":"java.lang.String","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"MessageFormat","comment":"Constructs a MessageFormat for the specified locale and\n pattern.\n The constructor first sets the locale, then parses the pattern and\n creates a list of subformats for the format elements contained in it.\n Patterns and their interpretation are specified in the\n \u003ca href\u003d\"#patterns\"\u003eclass description\u003c/a\u003e.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":true,"isField":false,"isMethod":false,"isOrdinaryClass":false,"signature":"(java.lang.String, java.util.Locale)","flatSignature":"(String, Locale)","parameters":[{"name":"pattern","type":{"isPrimitive":false,"simpleName":"String","qualifiedName":"java.lang.String","dimension":"","elementType":{}}},{"name":"locale","type":{"isPrimitive":false,"simpleName":"Locale","qualifiedName":"java.util.Locale","dimension":"","elementType":{}}}],"typeParameters":[]}],"fields":[],"methods":[{"name":"setLocale","comment":"Sets the locale to be used when creating or comparing subformats.\n This affects subsequent calls\n \u003cul\u003e\n \u003cli\u003eto the {@link #applyPattern applyPattern}\n     and {@link #toPattern toPattern} methods if format elements specify\n     a format type and therefore have the subformats created in the\n     \u003ccode\u003eapplyPattern\u003c/code\u003e method, as well as\n \u003cli\u003eto the \u003ccode\u003eformat\u003c/code\u003e and\n     {@link #formatToCharacterIterator formatToCharacterIterator} methods\n     if format elements do not specify a format type and therefore have\n     the subformats created in the formatting methods.\n \u003c/ul\u003e\n Subformats that have already been created are not affected.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.util.Locale)","flatSignature":"(Locale)","returnType":{"isPrimitive":true,"simpleName":"void","qualifiedName":"void","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[{"name":"locale","type":{"isPrimitive":false,"simpleName":"Locale","qualifiedName":"java.util.Locale","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"getLocale","comment":"Gets the locale that\u0027s used when creating or comparing subformats.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":false,"simpleName":"Locale","qualifiedName":"java.util.Locale","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[],"typeParameters":[]},{"name":"applyPattern","comment":"Sets the pattern used by this message format.\n The method parses the pattern and creates a list of subformats\n for the format elements contained in it.\n Patterns and their interpretation are specified in the\n \u003ca href\u003d\"#patterns\"\u003eclass description\u003c/a\u003e.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.lang.String)","flatSignature":"(String)","returnType":{"isPrimitive":true,"simpleName":"void","qualifiedName":"void","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[{"name":"pattern","type":{"isPrimitive":false,"simpleName":"String","qualifiedName":"java.lang.String","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"toPattern","comment":"Returns a pattern representing the current state of the message format.\n The string is constructed from internal information and therefore\n does not necessarily equal the previously applied pattern.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":false,"simpleName":"String","qualifiedName":"java.lang.String","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[],"typeParameters":[]},{"name":"setFormatsByArgumentIndex","comment":"Sets the formats to use for the values passed into\n \u003ccode\u003eformat\u003c/code\u003e methods or returned from \u003ccode\u003eparse\u003c/code\u003e\n methods. The indices of elements in \u003ccode\u003enewFormats\u003c/code\u003e\n correspond to the argument indices used in the previously set\n pattern string.\n The order of formats in \u003ccode\u003enewFormats\u003c/code\u003e thus corresponds to\n the order of elements in the \u003ccode\u003earguments\u003c/code\u003e array passed\n to the \u003ccode\u003eformat\u003c/code\u003e methods or the result array returned\n by the \u003ccode\u003eparse\u003c/code\u003e methods.\n \u003cp\u003e\n If an argument index is used for more than one format element\n in the pattern string, then the corresponding new format is used\n for all such format elements. If an argument index is not used\n for any format element in the pattern string, then the\n corresponding new format is ignored. If fewer formats are provided\n than needed, then only the formats for argument indices less\n than \u003ccode\u003enewFormats.length\u003c/code\u003e are replaced.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.text.Format[])","flatSignature":"(Format[])","returnType":{"isPrimitive":true,"simpleName":"void","qualifiedName":"void","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[{"name":"newFormats","type":{"isPrimitive":false,"simpleName":"Format","qualifiedName":"java.text.Format","dimension":"[]","elementType":{"isPrimitive":false,"simpleName":"Format","qualifiedName":"java.text.Format","dimension":"","elementType":{}}}}],"typeParameters":[]},{"name":"setFormats","comment":"Sets the formats to use for the format elements in the\n previously set pattern string.\n The order of formats in \u003ccode\u003enewFormats\u003c/code\u003e corresponds to\n the order of format elements in the pattern string.\n \u003cp\u003e\n If more formats are provided than needed by the pattern string,\n the remaining ones are ignored. If fewer formats are provided\n than needed, then only the first \u003ccode\u003enewFormats.length\u003c/code\u003e\n formats are replaced.\n \u003cp\u003e\n Since the order of format elements in a pattern string often\n changes during localization, it is generally better to use the\n {@link #setFormatsByArgumentIndex setFormatsByArgumentIndex}\n method, which assumes an order of formats corresponding to the\n order of elements in the \u003ccode\u003earguments\u003c/code\u003e array passed to\n the \u003ccode\u003eformat\u003c/code\u003e methods or the result array returned by\n the \u003ccode\u003eparse\u003c/code\u003e methods.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.text.Format[])","flatSignature":"(Format[])","returnType":{"isPrimitive":true,"simpleName":"void","qualifiedName":"void","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[{"name":"newFormats","type":{"isPrimitive":false,"simpleName":"Format","qualifiedName":"java.text.Format","dimension":"[]","elementType":{"isPrimitive":false,"simpleName":"Format","qualifiedName":"java.text.Format","dimension":"","elementType":{}}}}],"typeParameters":[]},{"name":"setFormatByArgumentIndex","comment":"Sets the format to use for the format elements within the\n previously set pattern string that use the given argument\n index.\n The argument index is part of the format element definition and\n represents an index into the \u003ccode\u003earguments\u003c/code\u003e array passed\n to the \u003ccode\u003eformat\u003c/code\u003e methods or the result array returned\n by the \u003ccode\u003eparse\u003c/code\u003e methods.\n \u003cp\u003e\n If the argument index is used for more than one format element\n in the pattern string, then the new format is used for all such\n format elements. If the argument index is not used for any format\n element in the pattern string, then the new format is ignored.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(int, java.text.Format)","flatSignature":"(int, Format)","returnType":{"isPrimitive":true,"simpleName":"void","qualifiedName":"void","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[{"name":"argumentIndex","type":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}}},{"name":"newFormat","type":{"isPrimitive":false,"simpleName":"Format","qualifiedName":"java.text.Format","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"setFormat","comment":"Sets the format to use for the format element with the given\n format element index within the previously set pattern string.\n The format element index is the zero-based number of the format\n element counting from the start of the pattern string.\n \u003cp\u003e\n Since the order of format elements in a pattern string often\n changes during localization, it is generally better to use the\n {@link #setFormatByArgumentIndex setFormatByArgumentIndex}\n method, which accesses format elements based on the argument\n index they specify.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(int, java.text.Format)","flatSignature":"(int, Format)","returnType":{"isPrimitive":true,"simpleName":"void","qualifiedName":"void","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[{"name":"formatElementIndex","type":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}}},{"name":"newFormat","type":{"isPrimitive":false,"simpleName":"Format","qualifiedName":"java.text.Format","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"getFormatsByArgumentIndex","comment":"Gets the formats used for the values passed into\n \u003ccode\u003eformat\u003c/code\u003e methods or returned from \u003ccode\u003eparse\u003c/code\u003e\n methods. The indices of elements in the returned array\n correspond to the argument indices used in the previously set\n pattern string.\n The order of formats in the returned array thus corresponds to\n the order of elements in the \u003ccode\u003earguments\u003c/code\u003e array passed\n to the \u003ccode\u003eformat\u003c/code\u003e methods or the result array returned\n by the \u003ccode\u003eparse\u003c/code\u003e methods.\n \u003cp\u003e\n If an argument index is used for more than one format element\n in the pattern string, then the format used for the last such\n format element is returned in the array. If an argument index\n is not used for any format element in the pattern string, then\n null is returned in the array.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":false,"simpleName":"Format","qualifiedName":"java.text.Format","dimension":"[]","elementType":{"isPrimitive":false,"simpleName":"Format","qualifiedName":"java.text.Format","dimension":"","elementType":{}}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[],"typeParameters":[]},{"name":"getFormats","comment":"Gets the formats used for the format elements in the\n previously set pattern string.\n The order of formats in the returned array corresponds to\n the order of format elements in the pattern string.\n \u003cp\u003e\n Since the order of format elements in a pattern string often\n changes during localization, it\u0027s generally better to use the\n {@link #getFormatsByArgumentIndex getFormatsByArgumentIndex}\n method, which assumes an order of formats corresponding to the\n order of elements in the \u003ccode\u003earguments\u003c/code\u003e array passed to\n the \u003ccode\u003eformat\u003c/code\u003e methods or the result array returned by\n the \u003ccode\u003eparse\u003c/code\u003e methods.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":false,"simpleName":"Format","qualifiedName":"java.text.Format","dimension":"[]","elementType":{"isPrimitive":false,"simpleName":"Format","qualifiedName":"java.text.Format","dimension":"","elementType":{}}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[],"typeParameters":[]},{"name":"format","comment":"Formats an array of objects and appends the \u003ccode\u003eMessageFormat\u003c/code\u003e\u0027s\n pattern, with format elements replaced by the formatted objects, to the\n provided \u003ccode\u003eStringBuffer\u003c/code\u003e.\n \u003cp\u003e\n The text substituted for the individual format elements is derived from\n the current subformat of the format element and the\n \u003ccode\u003earguments\u003c/code\u003e element at the format element\u0027s argument index\n as indicated by the first matching line of the following table. An\n argument is \u003ci\u003eunavailable\u003c/i\u003e if \u003ccode\u003earguments\u003c/code\u003e is\n \u003ccode\u003enull\u003c/code\u003e or has fewer than argumentIndex+1 elements.\n\n \u003ctable border\u003d1 summary\u003d\"Examples of subformat,argument,and formatted text\"\u003e\n    \u003ctr\u003e\n       \u003cth\u003eSubformat\n       \u003cth\u003eArgument\n       \u003cth\u003eFormatted Text\n    \u003ctr\u003e\n       \u003ctd\u003e\u003ci\u003eany\u003c/i\u003e\n       \u003ctd\u003e\u003ci\u003eunavailable\u003c/i\u003e\n       \u003ctd\u003e\u003ccode\u003e\"{\" + argumentIndex + \"}\"\u003c/code\u003e\n    \u003ctr\u003e\n       \u003ctd\u003e\u003ci\u003eany\u003c/i\u003e\n       \u003ctd\u003e\u003ccode\u003enull\u003c/code\u003e\n       \u003ctd\u003e\u003ccode\u003e\"null\"\u003c/code\u003e\n    \u003ctr\u003e\n       \u003ctd\u003e\u003ccode\u003einstanceof ChoiceFormat\u003c/code\u003e\n       \u003ctd\u003e\u003ci\u003eany\u003c/i\u003e\n       \u003ctd\u003e\u003ccode\u003esubformat.format(argument).indexOf(\u0027{\u0027) \u0026gt;\u003d 0 ?\u003cbr\u003e\n           (new MessageFormat(subformat.format(argument), getLocale())).format(argument) :\n           subformat.format(argument)\u003c/code\u003e\n    \u003ctr\u003e\n       \u003ctd\u003e\u003ccode\u003e!\u003d null\u003c/code\u003e\n       \u003ctd\u003e\u003ci\u003eany\u003c/i\u003e\n       \u003ctd\u003e\u003ccode\u003esubformat.format(argument)\u003c/code\u003e\n    \u003ctr\u003e\n       \u003ctd\u003e\u003ccode\u003enull\u003c/code\u003e\n       \u003ctd\u003e\u003ccode\u003einstanceof Number\u003c/code\u003e\n       \u003ctd\u003e\u003ccode\u003eNumberFormat.getInstance(getLocale()).format(argument)\u003c/code\u003e\n    \u003ctr\u003e\n       \u003ctd\u003e\u003ccode\u003enull\u003c/code\u003e\n       \u003ctd\u003e\u003ccode\u003einstanceof Date\u003c/code\u003e\n       \u003ctd\u003e\u003ccode\u003eDateFormat.getDateTimeInstance(DateFormat.SHORT, DateFormat.SHORT, getLocale()).format(argument)\u003c/code\u003e\n    \u003ctr\u003e\n       \u003ctd\u003e\u003ccode\u003enull\u003c/code\u003e\n       \u003ctd\u003e\u003ccode\u003einstanceof String\u003c/code\u003e\n       \u003ctd\u003e\u003ccode\u003eargument\u003c/code\u003e\n    \u003ctr\u003e\n       \u003ctd\u003e\u003ccode\u003enull\u003c/code\u003e\n       \u003ctd\u003e\u003ci\u003eany\u003c/i\u003e\n       \u003ctd\u003e\u003ccode\u003eargument.toString()\u003c/code\u003e\n \u003c/table\u003e\n \u003cp\u003e\n If \u003ccode\u003epos\u003c/code\u003e is non-null, and refers to\n \u003ccode\u003eField.ARGUMENT\u003c/code\u003e, the location of the first formatted\n string will be returned.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.lang.Object[], java.lang.StringBuffer, java.text.FieldPosition)","flatSignature":"(Object[], StringBuffer, FieldPosition)","returnType":{"isPrimitive":false,"simpleName":"StringBuffer","qualifiedName":"java.lang.StringBuffer","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[{"name":"arguments","type":{"isPrimitive":false,"simpleName":"Object","qualifiedName":"java.lang.Object","dimension":"[]","elementType":{"isPrimitive":false,"simpleName":"Object","qualifiedName":"java.lang.Object","dimension":"","elementType":{}}}},{"name":"result","type":{"isPrimitive":false,"simpleName":"StringBuffer","qualifiedName":"java.lang.StringBuffer","dimension":"","elementType":{}}},{"name":"pos","type":{"isPrimitive":false,"simpleName":"FieldPosition","qualifiedName":"java.text.FieldPosition","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"format","comment":"Creates a MessageFormat with the given pattern and uses it\n to format the given arguments. This is equivalent to\n \u003cblockquote\u003e\n     \u003ccode\u003e(new {@link #MessageFormat(String) MessageFormat}(pattern)).{@link #format(java.lang.Object[], java.lang.StringBuffer, java.text.FieldPosition) format}(arguments, new StringBuffer(), null).toString()\u003c/code\u003e\n \u003c/blockquote\u003e","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.lang.String, java.lang.Object...)","flatSignature":"(String, Object...)","returnType":{"isPrimitive":false,"simpleName":"String","qualifiedName":"java.lang.String","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"pattern","type":{"isPrimitive":false,"simpleName":"String","qualifiedName":"java.lang.String","dimension":"","elementType":{}}},{"name":"arguments","type":{"isPrimitive":false,"simpleName":"Object","qualifiedName":"java.lang.Object","dimension":"[]","elementType":{"isPrimitive":false,"simpleName":"Object","qualifiedName":"java.lang.Object","dimension":"","elementType":{}}}}],"typeParameters":[]},{"name":"format","comment":"Formats an array of objects and appends the \u003ccode\u003eMessageFormat\u003c/code\u003e\u0027s\n pattern, with format elements replaced by the formatted objects, to the\n provided \u003ccode\u003eStringBuffer\u003c/code\u003e.\n This is equivalent to\n \u003cblockquote\u003e\n     \u003ccode\u003e{@link #format(java.lang.Object[], java.lang.StringBuffer, java.text.FieldPosition) format}((Object[]) arguments, result, pos)\u003c/code\u003e\n \u003c/blockquote\u003e","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.lang.Object, java.lang.StringBuffer, java.text.FieldPosition)","flatSignature":"(Object, StringBuffer, FieldPosition)","returnType":{"isPrimitive":false,"simpleName":"StringBuffer","qualifiedName":"java.lang.StringBuffer","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[{"name":"arguments","type":{"isPrimitive":false,"simpleName":"Object","qualifiedName":"java.lang.Object","dimension":"","elementType":{}}},{"name":"result","type":{"isPrimitive":false,"simpleName":"StringBuffer","qualifiedName":"java.lang.StringBuffer","dimension":"","elementType":{}}},{"name":"pos","type":{"isPrimitive":false,"simpleName":"FieldPosition","qualifiedName":"java.text.FieldPosition","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"formatToCharacterIterator","comment":"Formats an array of objects and inserts them into the\n \u003ccode\u003eMessageFormat\u003c/code\u003e\u0027s pattern, producing an\n \u003ccode\u003eAttributedCharacterIterator\u003c/code\u003e.\n You can use the returned \u003ccode\u003eAttributedCharacterIterator\u003c/code\u003e\n to build the resulting String, as well as to determine information\n about the resulting String.\n \u003cp\u003e\n The text of the returned \u003ccode\u003eAttributedCharacterIterator\u003c/code\u003e is\n the same that would be returned by\n \u003cblockquote\u003e\n     \u003ccode\u003e{@link #format(java.lang.Object[], java.lang.StringBuffer, java.text.FieldPosition) format}(arguments, new StringBuffer(), null).toString()\u003c/code\u003e\n \u003c/blockquote\u003e\n \u003cp\u003e\n In addition, the \u003ccode\u003eAttributedCharacterIterator\u003c/code\u003e contains at\n least attributes indicating where text was generated from an\n argument in the \u003ccode\u003earguments\u003c/code\u003e array. The keys of these attributes are of\n type \u003ccode\u003eMessageFormat.Field\u003c/code\u003e, their values are\n \u003ccode\u003eInteger\u003c/code\u003e objects indicating the index in the \u003ccode\u003earguments\u003c/code\u003e\n array of the argument from which the text was generated.\n \u003cp\u003e\n The attributes/value from the underlying \u003ccode\u003eFormat\u003c/code\u003e\n instances that \u003ccode\u003eMessageFormat\u003c/code\u003e uses will also be\n placed in the resulting \u003ccode\u003eAttributedCharacterIterator\u003c/code\u003e.\n This allows you to not only find where an argument is placed in the\n resulting String, but also which fields it contains in turn.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.lang.Object)","flatSignature":"(Object)","returnType":{"isPrimitive":false,"simpleName":"AttributedCharacterIterator","qualifiedName":"java.text.AttributedCharacterIterator","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[{"name":"arguments","type":{"isPrimitive":false,"simpleName":"Object","qualifiedName":"java.lang.Object","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"parse","comment":"Parses the string.\n\n \u003cp\u003eCaveats: The parse may fail in a number of circumstances.\n For example:\n \u003cul\u003e\n \u003cli\u003eIf one of the arguments does not occur in the pattern.\n \u003cli\u003eIf the format of an argument loses information, such as\n     with a choice format where a large number formats to \"many\".\n \u003cli\u003eDoes not yet handle recursion (where\n     the substituted strings contain {n} references.)\n \u003cli\u003eWill not always find a match (or the correct match)\n     if some part of the parse is ambiguous.\n     For example, if the pattern \"{1},{2}\" is used with the\n     string arguments {\"a,b\", \"c\"}, it will format as \"a,b,c\".\n     When the result is parsed, it will return {\"a\", \"b,c\"}.\n \u003cli\u003eIf a single argument is parsed more than once in the string,\n     then the later parse wins.\n \u003c/ul\u003e\n When the parse fails, use ParsePosition.getErrorIndex() to find out\n where in the string the parsing failed.  The returned error\n index is the starting offset of the sub-patterns that the string\n is comparing with.  For example, if the parsing string \"AAA {0} BBB\"\n is comparing against the pattern \"AAD {0} BBB\", the error index is\n 0. When an error occurs, the call to this method will return null.\n If the source is null, return an empty array.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.lang.String, java.text.ParsePosition)","flatSignature":"(String, ParsePosition)","returnType":{"isPrimitive":false,"simpleName":"Object","qualifiedName":"java.lang.Object","dimension":"[]","elementType":{"isPrimitive":false,"simpleName":"Object","qualifiedName":"java.lang.Object","dimension":"","elementType":{}}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[{"name":"source","type":{"isPrimitive":false,"simpleName":"String","qualifiedName":"java.lang.String","dimension":"","elementType":{}}},{"name":"pos","type":{"isPrimitive":false,"simpleName":"ParsePosition","qualifiedName":"java.text.ParsePosition","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"parse","comment":"Parses text from the beginning of the given string to produce an object\n array.\n The method may not use the entire text of the given string.\n \u003cp\u003e\n See the {@link #parse(String, ParsePosition)} method for more information\n on message parsing.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.lang.String)","flatSignature":"(String)","returnType":{"isPrimitive":false,"simpleName":"Object","qualifiedName":"java.lang.Object","dimension":"[]","elementType":{"isPrimitive":false,"simpleName":"Object","qualifiedName":"java.lang.Object","dimension":"","elementType":{}}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[{"name":"source","type":{"isPrimitive":false,"simpleName":"String","qualifiedName":"java.lang.String","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"parseObject","comment":"Parses text from a string to produce an object array.\n \u003cp\u003e\n The method attempts to parse text starting at the index given by\n \u003ccode\u003epos\u003c/code\u003e.\n If parsing succeeds, then the index of \u003ccode\u003epos\u003c/code\u003e is updated\n to the index after the last character used (parsing does not necessarily\n use all characters up to the end of the string), and the parsed\n object array is returned. The updated \u003ccode\u003epos\u003c/code\u003e can be used to\n indicate the starting point for the next call to this method.\n If an error occurs, then the index of \u003ccode\u003epos\u003c/code\u003e is not\n changed, the error index of \u003ccode\u003epos\u003c/code\u003e is set to the index of\n the character where the error occurred, and null is returned.\n \u003cp\u003e\n See the {@link #parse(String, ParsePosition)} method for more information\n on message parsing.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.lang.String, java.text.ParsePosition)","flatSignature":"(String, ParsePosition)","returnType":{"isPrimitive":false,"simpleName":"Object","qualifiedName":"java.lang.Object","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[{"name":"source","type":{"isPrimitive":false,"simpleName":"String","qualifiedName":"java.lang.String","dimension":"","elementType":{}}},{"name":"pos","type":{"isPrimitive":false,"simpleName":"ParsePosition","qualifiedName":"java.text.ParsePosition","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"clone","comment":"Creates and returns a copy of this object.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":false,"simpleName":"Object","qualifiedName":"java.lang.Object","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[],"typeParameters":[]},{"name":"equals","comment":"Equality comparison between two message format objects","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.lang.Object)","flatSignature":"(Object)","returnType":{"isPrimitive":true,"simpleName":"boolean","qualifiedName":"boolean","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[{"name":"obj","type":{"isPrimitive":false,"simpleName":"Object","qualifiedName":"java.lang.Object","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"hashCode","comment":"Generates a hash code for the message format object.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[],"typeParameters":[]}],"typeParameters":[],"enumConstants":[]}