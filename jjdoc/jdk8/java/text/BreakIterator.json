{"name":"BreakIterator","comment":"The \u003ccode\u003eBreakIterator\u003c/code\u003e class implements methods for finding\n the location of boundaries in text. Instances of \u003ccode\u003eBreakIterator\u003c/code\u003e\n maintain a current position and scan over text\n returning the index of characters where boundaries occur.\n Internally, \u003ccode\u003eBreakIterator\u003c/code\u003e scans text using a\n \u003ccode\u003eCharacterIterator\u003c/code\u003e, and is thus able to scan text held\n by any object implementing that protocol. A \u003ccode\u003eStringCharacterIterator\u003c/code\u003e\n is used to scan \u003ccode\u003eString\u003c/code\u003e objects passed to \u003ccode\u003esetText\u003c/code\u003e.\n\n \u003cp\u003e\n You use the factory methods provided by this class to create\n instances of various types of break iterators. In particular,\n use \u003ccode\u003egetWordInstance\u003c/code\u003e, \u003ccode\u003egetLineInstance\u003c/code\u003e,\n \u003ccode\u003egetSentenceInstance\u003c/code\u003e, and \u003ccode\u003egetCharacterInstance\u003c/code\u003e\n to create \u003ccode\u003eBreakIterator\u003c/code\u003es that perform\n word, line, sentence, and character boundary analysis respectively.\n A single \u003ccode\u003eBreakIterator\u003c/code\u003e can work only on one unit\n (word, line, sentence, and so on). You must use a different iterator\n for each unit boundary analysis you wish to perform.\n\n \u003cp\u003e\u003ca name\u003d\"line\"\u003e\u003c/a\u003e\n Line boundary analysis determines where a text string can be\n broken when line-wrapping. The mechanism correctly handles\n punctuation and hyphenated words. Actual line breaking needs\n to also consider the available line width and is handled by\n higher-level software.\n\n \u003cp\u003e\u003ca name\u003d\"sentence\"\u003e\u003c/a\u003e\n Sentence boundary analysis allows selection with correct interpretation\n of periods within numbers and abbreviations, and trailing punctuation\n marks such as quotation marks and parentheses.\n\n \u003cp\u003e\u003ca name\u003d\"word\"\u003e\u003c/a\u003e\n Word boundary analysis is used by search and replace functions, as\n well as within text editing applications that allow the user to\n select words with a double click. Word selection provides correct\n interpretation of punctuation marks within and following\n words. Characters that are not part of a word, such as symbols\n or punctuation marks, have word-breaks on both sides.\n\n \u003cp\u003e\u003ca name\u003d\"character\"\u003e\u003c/a\u003e\n Character boundary analysis allows users to interact with characters\n as they expect to, for example, when moving the cursor through a text\n string. Character boundary analysis provides correct navigation\n through character strings, regardless of how the character is stored.\n The boundaries returned may be those of supplementary characters,\n combining character sequences, or ligature clusters.\n For example, an accented character might be stored as a base character\n and a diacritical mark. What users consider to be a character can\n differ between languages.\n\n \u003cp\u003e\n The \u003ccode\u003eBreakIterator\u003c/code\u003e instances returned by the factory methods\n of this class are intended for use with natural languages only, not for\n programming language text. It is however possible to define subclasses\n that tokenize a programming language.\n\n \u003cP\u003e\n \u003cstrong\u003eExamples\u003c/strong\u003e:\u003cP\u003e\n Creating and using text boundaries:\n \u003cblockquote\u003e\n \u003cpre\u003e\n public static void main(String args[]) {\n      if (args.length \u003d\u003d 1) {\n          String stringToExamine \u003d args[0];\n          //print each word in order\n          BreakIterator boundary \u003d BreakIterator.getWordInstance();\n          boundary.setText(stringToExamine);\n          printEachForward(boundary, stringToExamine);\n          //print each sentence in reverse order\n          boundary \u003d BreakIterator.getSentenceInstance(Locale.US);\n          boundary.setText(stringToExamine);\n          printEachBackward(boundary, stringToExamine);\n          printFirst(boundary, stringToExamine);\n          printLast(boundary, stringToExamine);\n      }\n }\n \u003c/pre\u003e\n \u003c/blockquote\u003e\n\n Print each element in order:\n \u003cblockquote\u003e\n \u003cpre\u003e\n public static void printEachForward(BreakIterator boundary, String source) {\n     int start \u003d boundary.first();\n     for (int end \u003d boundary.next();\n          end !\u003d BreakIterator.DONE;\n          start \u003d end, end \u003d boundary.next()) {\n          System.out.println(source.substring(start,end));\n     }\n }\n \u003c/pre\u003e\n \u003c/blockquote\u003e\n\n Print each element in reverse order:\n \u003cblockquote\u003e\n \u003cpre\u003e\n public static void printEachBackward(BreakIterator boundary, String source) {\n     int end \u003d boundary.last();\n     for (int start \u003d boundary.previous();\n          start !\u003d BreakIterator.DONE;\n          end \u003d start, start \u003d boundary.previous()) {\n         System.out.println(source.substring(start,end));\n     }\n }\n \u003c/pre\u003e\n \u003c/blockquote\u003e\n\n Print first element:\n \u003cblockquote\u003e\n \u003cpre\u003e\n public static void printFirst(BreakIterator boundary, String source) {\n     int start \u003d boundary.first();\n     int end \u003d boundary.next();\n     System.out.println(source.substring(start,end));\n }\n \u003c/pre\u003e\n \u003c/blockquote\u003e\n\n Print last element:\n \u003cblockquote\u003e\n \u003cpre\u003e\n public static void printLast(BreakIterator boundary, String source) {\n     int end \u003d boundary.last();\n     int start \u003d boundary.previous();\n     System.out.println(source.substring(start,end));\n }\n \u003c/pre\u003e\n \u003c/blockquote\u003e\n\n Print the element at a specified position:\n \u003cblockquote\u003e\n \u003cpre\u003e\n public static void printAt(BreakIterator boundary, int pos, String source) {\n     int end \u003d boundary.following(pos);\n     int start \u003d boundary.previous();\n     System.out.println(source.substring(start,end));\n }\n \u003c/pre\u003e\n \u003c/blockquote\u003e\n\n Find the next word:\n \u003cblockquote\u003e\n \u003cpre\u003e{@code\n public static int nextWordStartAfter(int pos, String text) {\n     BreakIterator wb \u003d BreakIterator.getWordInstance();\n     wb.setText(text);\n     int last \u003d wb.following(pos);\n     int current \u003d wb.next();\n     while (current !\u003d BreakIterator.DONE) {\n         for (int p \u003d last; p \u003c current; p++) {\n             if (Character.isLetter(text.codePointAt(p)))\n                 return last;\n         }\n         last \u003d current;\n         current \u003d wb.next();\n     }\n     return BreakIterator.DONE;\n }\n }\u003c/pre\u003e\n (The iterator returned by BreakIterator.getWordInstance() is unique in that\n the break positions it returns don\u0027t represent both the start and end of the\n thing being iterated over.  That is, a sentence-break iterator returns breaks\n that each represent the end of one sentence and the beginning of the next.\n With the word-break iterator, the characters between two boundaries might be a\n word, or they might be the punctuation or whitespace between two words.  The\n above code uses a simple heuristic to determine which boundary is the beginning\n of a word: If the characters between this boundary and the next boundary\n include at least one letter (this can be an alphabetical letter, a CJK ideograph,\n a Hangul syllable, a Kana character, etc.), then the text between this boundary\n and the next is a word; otherwise, it\u0027s the material between words.)\n \u003c/blockquote\u003e","isClass":true,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":false,"isOrdinaryClass":true,"isPrimitive":false,"simpleName":"BreakIterator","qualifiedName":"java.text.BreakIterator","dimension":"","elementType":{},"package":"java.text","superclass":"java.lang.Object","interfaces":["java.lang.Cloneable"],"isAbstract":true,"isStatic":false,"innerClasses":[],"isInnerClass":false,"constructors":[],"fields":[{"name":"DONE","comment":"DONE is returned by previous(), next(), next(int), preceding(int)\n and following(int) when either the first or last text boundary has been\n reached.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":true,"isMethod":false,"isOrdinaryClass":false,"type":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}},"isStatic":true,"constantValue":"-1"}],"methods":[{"name":"clone","comment":"Create a copy of this iterator","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":false,"simpleName":"Object","qualifiedName":"java.lang.Object","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[],"typeParameters":[]},{"name":"first","comment":"Returns the first boundary. The iterator\u0027s current position is set\n to the first text boundary.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}},"isAbstract":true,"isDefault":false,"isStatic":false,"parameters":[],"typeParameters":[]},{"name":"last","comment":"Returns the last boundary. The iterator\u0027s current position is set\n to the last text boundary.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}},"isAbstract":true,"isDefault":false,"isStatic":false,"parameters":[],"typeParameters":[]},{"name":"next","comment":"Returns the nth boundary from the current boundary. If either\n the first or last text boundary has been reached, it returns\n \u003ccode\u003eBreakIterator.DONE\u003c/code\u003e and the current position is set to either\n the first or last text boundary depending on which one is reached. Otherwise,\n the iterator\u0027s current position is set to the new boundary.\n For example, if the iterator\u0027s current position is the mth text boundary\n and three more boundaries exist from the current boundary to the last text\n boundary, the next(2) call will return m + 2. The new text position is set\n to the (m + 2)th text boundary. A next(4) call would return\n \u003ccode\u003eBreakIterator.DONE\u003c/code\u003e and the last text boundary would become the\n new text position.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(int)","flatSignature":"(int)","returnType":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}},"isAbstract":true,"isDefault":false,"isStatic":false,"parameters":[{"name":"n","type":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"next","comment":"Returns the boundary following the current boundary. If the current boundary\n is the last text boundary, it returns \u003ccode\u003eBreakIterator.DONE\u003c/code\u003e and\n the iterator\u0027s current position is unchanged. Otherwise, the iterator\u0027s\n current position is set to the boundary following the current boundary.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}},"isAbstract":true,"isDefault":false,"isStatic":false,"parameters":[],"typeParameters":[]},{"name":"previous","comment":"Returns the boundary preceding the current boundary. If the current boundary\n is the first text boundary, it returns \u003ccode\u003eBreakIterator.DONE\u003c/code\u003e and\n the iterator\u0027s current position is unchanged. Otherwise, the iterator\u0027s\n current position is set to the boundary preceding the current boundary.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}},"isAbstract":true,"isDefault":false,"isStatic":false,"parameters":[],"typeParameters":[]},{"name":"following","comment":"Returns the first boundary following the specified character offset. If the\n specified offset equals to the last text boundary, it returns\n \u003ccode\u003eBreakIterator.DONE\u003c/code\u003e and the iterator\u0027s current position is unchanged.\n Otherwise, the iterator\u0027s current position is set to the returned boundary.\n The value returned is always greater than the offset or the value\n \u003ccode\u003eBreakIterator.DONE\u003c/code\u003e.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(int)","flatSignature":"(int)","returnType":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}},"isAbstract":true,"isDefault":false,"isStatic":false,"parameters":[{"name":"offset","type":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"preceding","comment":"Returns the last boundary preceding the specified character offset. If the\n specified offset equals to the first text boundary, it returns\n \u003ccode\u003eBreakIterator.DONE\u003c/code\u003e and the iterator\u0027s current position is unchanged.\n Otherwise, the iterator\u0027s current position is set to the returned boundary.\n The value returned is always less than the offset or the value\n \u003ccode\u003eBreakIterator.DONE\u003c/code\u003e.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(int)","flatSignature":"(int)","returnType":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[{"name":"offset","type":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"isBoundary","comment":"Returns true if the specified character offset is a text boundary.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(int)","flatSignature":"(int)","returnType":{"isPrimitive":true,"simpleName":"boolean","qualifiedName":"boolean","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[{"name":"offset","type":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"current","comment":"Returns character index of the text boundary that was most\n recently returned by next(), next(int), previous(), first(), last(),\n following(int) or preceding(int). If any of these methods returns\n \u003ccode\u003eBreakIterator.DONE\u003c/code\u003e because either first or last text boundary\n has been reached, it returns the first or last text boundary depending on\n which one is reached.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}},"isAbstract":true,"isDefault":false,"isStatic":false,"parameters":[],"typeParameters":[]},{"name":"getText","comment":"Get the text being scanned","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":false,"simpleName":"CharacterIterator","qualifiedName":"java.text.CharacterIterator","dimension":"","elementType":{}},"isAbstract":true,"isDefault":false,"isStatic":false,"parameters":[],"typeParameters":[]},{"name":"setText","comment":"Set a new text string to be scanned.  The current scan\n position is reset to first().","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.lang.String)","flatSignature":"(String)","returnType":{"isPrimitive":true,"simpleName":"void","qualifiedName":"void","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[{"name":"newText","type":{"isPrimitive":false,"simpleName":"String","qualifiedName":"java.lang.String","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"setText","comment":"Set a new text for scanning.  The current scan\n position is reset to first().","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.text.CharacterIterator)","flatSignature":"(CharacterIterator)","returnType":{"isPrimitive":true,"simpleName":"void","qualifiedName":"void","dimension":"","elementType":{}},"isAbstract":true,"isDefault":false,"isStatic":false,"parameters":[{"name":"newText","type":{"isPrimitive":false,"simpleName":"CharacterIterator","qualifiedName":"java.text.CharacterIterator","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"getWordInstance","comment":"Returns a new \u003ccode\u003eBreakIterator\u003c/code\u003e instance\n for \u003ca href\u003d\"BreakIterator.html#word\"\u003eword breaks\u003c/a\u003e\n for the {@linkplain Locale#getDefault() default locale}.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":false,"simpleName":"BreakIterator","qualifiedName":"java.text.BreakIterator","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[],"typeParameters":[]},{"name":"getWordInstance","comment":"Returns a new \u003ccode\u003eBreakIterator\u003c/code\u003e instance\n for \u003ca href\u003d\"BreakIterator.html#word\"\u003eword breaks\u003c/a\u003e\n for the given locale.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.util.Locale)","flatSignature":"(Locale)","returnType":{"isPrimitive":false,"simpleName":"BreakIterator","qualifiedName":"java.text.BreakIterator","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"locale","type":{"isPrimitive":false,"simpleName":"Locale","qualifiedName":"java.util.Locale","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"getLineInstance","comment":"Returns a new \u003ccode\u003eBreakIterator\u003c/code\u003e instance\n for \u003ca href\u003d\"BreakIterator.html#line\"\u003eline breaks\u003c/a\u003e\n for the {@linkplain Locale#getDefault() default locale}.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":false,"simpleName":"BreakIterator","qualifiedName":"java.text.BreakIterator","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[],"typeParameters":[]},{"name":"getLineInstance","comment":"Returns a new \u003ccode\u003eBreakIterator\u003c/code\u003e instance\n for \u003ca href\u003d\"BreakIterator.html#line\"\u003eline breaks\u003c/a\u003e\n for the given locale.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.util.Locale)","flatSignature":"(Locale)","returnType":{"isPrimitive":false,"simpleName":"BreakIterator","qualifiedName":"java.text.BreakIterator","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"locale","type":{"isPrimitive":false,"simpleName":"Locale","qualifiedName":"java.util.Locale","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"getCharacterInstance","comment":"Returns a new \u003ccode\u003eBreakIterator\u003c/code\u003e instance\n for \u003ca href\u003d\"BreakIterator.html#character\"\u003echaracter breaks\u003c/a\u003e\n for the {@linkplain Locale#getDefault() default locale}.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":false,"simpleName":"BreakIterator","qualifiedName":"java.text.BreakIterator","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[],"typeParameters":[]},{"name":"getCharacterInstance","comment":"Returns a new \u003ccode\u003eBreakIterator\u003c/code\u003e instance\n for \u003ca href\u003d\"BreakIterator.html#character\"\u003echaracter breaks\u003c/a\u003e\n for the given locale.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.util.Locale)","flatSignature":"(Locale)","returnType":{"isPrimitive":false,"simpleName":"BreakIterator","qualifiedName":"java.text.BreakIterator","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"locale","type":{"isPrimitive":false,"simpleName":"Locale","qualifiedName":"java.util.Locale","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"getSentenceInstance","comment":"Returns a new \u003ccode\u003eBreakIterator\u003c/code\u003e instance\n for \u003ca href\u003d\"BreakIterator.html#sentence\"\u003esentence breaks\u003c/a\u003e\n for the {@linkplain Locale#getDefault() default locale}.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":false,"simpleName":"BreakIterator","qualifiedName":"java.text.BreakIterator","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[],"typeParameters":[]},{"name":"getSentenceInstance","comment":"Returns a new \u003ccode\u003eBreakIterator\u003c/code\u003e instance\n for \u003ca href\u003d\"BreakIterator.html#sentence\"\u003esentence breaks\u003c/a\u003e\n for the given locale.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.util.Locale)","flatSignature":"(Locale)","returnType":{"isPrimitive":false,"simpleName":"BreakIterator","qualifiedName":"java.text.BreakIterator","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"locale","type":{"isPrimitive":false,"simpleName":"Locale","qualifiedName":"java.util.Locale","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"getAvailableLocales","comment":"Returns an array of all locales for which the\n \u003ccode\u003eget*Instance\u003c/code\u003e methods of this class can return\n localized instances.\n The returned array represents the union of locales supported by the Java\n runtime and by installed\n {@link java.text.spi.BreakIteratorProvider BreakIteratorProvider} implementations.\n It must contain at least a \u003ccode\u003eLocale\u003c/code\u003e\n instance equal to {@link java.util.Locale#US Locale.US}.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":false,"simpleName":"Locale","qualifiedName":"java.util.Locale","dimension":"[]","elementType":{"isPrimitive":false,"simpleName":"Locale","qualifiedName":"java.util.Locale","dimension":"","elementType":{}}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[],"typeParameters":[]}],"typeParameters":[],"enumConstants":[]}