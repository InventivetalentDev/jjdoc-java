{"name":"ChoiceFormat","comment":"A \u003ccode\u003eChoiceFormat\u003c/code\u003e allows you to attach a format to a range of numbers.\n It is generally used in a \u003ccode\u003eMessageFormat\u003c/code\u003e for handling plurals.\n The choice is specified with an ascending list of doubles, where each item\n specifies a half-open interval up to the next item:\n \u003cblockquote\u003e\n \u003cpre\u003e\n X matches j if and only if limit[j] \u0026le; X \u0026lt; limit[j+1]\n \u003c/pre\u003e\n \u003c/blockquote\u003e\n If there is no match, then either the first or last index is used, depending\n on whether the number (X) is too low or too high.  If the limit array is not\n in ascending order, the results of formatting will be incorrect.  ChoiceFormat\n also accepts \u003ccode\u003e\u0026#92;u221E\u003c/code\u003e as equivalent to infinity(INF).\n\n \u003cp\u003e\n \u003cstrong\u003eNote:\u003c/strong\u003e\n \u003ccode\u003eChoiceFormat\u003c/code\u003e differs from the other \u003ccode\u003eFormat\u003c/code\u003e\n classes in that you create a \u003ccode\u003eChoiceFormat\u003c/code\u003e object with a\n constructor (not with a \u003ccode\u003egetInstance\u003c/code\u003e style factory\n method). The factory methods aren\u0027t necessary because \u003ccode\u003eChoiceFormat\u003c/code\u003e\n doesn\u0027t require any complex setup for a given locale. In fact,\n \u003ccode\u003eChoiceFormat\u003c/code\u003e doesn\u0027t implement any locale specific behavior.\n\n \u003cp\u003e\n When creating a \u003ccode\u003eChoiceFormat\u003c/code\u003e, you must specify an array of formats\n and an array of limits. The length of these arrays must be the same.\n For example,\n \u003cul\u003e\n \u003cli\u003e\n     \u003cem\u003elimits\u003c/em\u003e \u003d {1,2,3,4,5,6,7}\u003cbr\u003e\n     \u003cem\u003eformats\u003c/em\u003e \u003d {\"Sun\",\"Mon\",\"Tue\",\"Wed\",\"Thur\",\"Fri\",\"Sat\"}\n \u003cli\u003e\n     \u003cem\u003elimits\u003c/em\u003e \u003d {0, 1, ChoiceFormat.nextDouble(1)}\u003cbr\u003e\n     \u003cem\u003eformats\u003c/em\u003e \u003d {\"no files\", \"one file\", \"many files\"}\u003cbr\u003e\n     (\u003ccode\u003enextDouble\u003c/code\u003e can be used to get the next higher double, to\n     make the half-open interval.)\n \u003c/ul\u003e\n\n \u003cp\u003e\n Here is a simple example that shows formatting and parsing:\n \u003cblockquote\u003e\n \u003cpre\u003e{@code\n double[] limits \u003d {1,2,3,4,5,6,7};\n String[] dayOfWeekNames \u003d {\"Sun\",\"Mon\",\"Tue\",\"Wed\",\"Thur\",\"Fri\",\"Sat\"};\n ChoiceFormat form \u003d new ChoiceFormat(limits, dayOfWeekNames);\n ParsePosition status \u003d new ParsePosition(0);\n for (double i \u003d 0.0; i \u003c\u003d 8.0; ++i) {\n     status.setIndex(0);\n     System.out.println(i + \" -\u003e \" + form.format(i) + \" -\u003e \"\n                              + form.parse(form.format(i),status));\n }\n }\u003c/pre\u003e\n \u003c/blockquote\u003e\n Here is a more complex example, with a pattern format:\n \u003cblockquote\u003e\n \u003cpre\u003e{@code\n double[] filelimits \u003d {0,1,2};\n String[] filepart \u003d {\"are no files\",\"is one file\",\"are {2} files\"};\n ChoiceFormat fileform \u003d new ChoiceFormat(filelimits, filepart);\n Format[] testFormats \u003d {fileform, null, NumberFormat.getInstance()};\n MessageFormat pattform \u003d new MessageFormat(\"There {0} on {1}\");\n pattform.setFormats(testFormats);\n Object[] testArgs \u003d {null, \"ADisk\", null};\n for (int i \u003d 0; i \u003c 4; ++i) {\n     testArgs[0] \u003d new Integer(i);\n     testArgs[2] \u003d testArgs[0];\n     System.out.println(pattform.format(testArgs));\n }\n }\u003c/pre\u003e\n \u003c/blockquote\u003e\n \u003cp\u003e\n Specifying a pattern for ChoiceFormat objects is fairly straightforward.\n For example:\n \u003cblockquote\u003e\n \u003cpre\u003e{@code\n ChoiceFormat fmt \u003d new ChoiceFormat(\n      \"-1#is negative| 0#is zero or fraction | 1#is one |1.0\u003cis 1+ |2#is two |2\u003cis more than 2.\");\n System.out.println(\"Formatter Pattern : \" + fmt.toPattern());\n\n System.out.println(\"Format with -INF : \" + fmt.format(Double.NEGATIVE_INFINITY));\n System.out.println(\"Format with -1.0 : \" + fmt.format(-1.0));\n System.out.println(\"Format with 0 : \" + fmt.format(0));\n System.out.println(\"Format with 0.9 : \" + fmt.format(0.9));\n System.out.println(\"Format with 1.0 : \" + fmt.format(1));\n System.out.println(\"Format with 1.5 : \" + fmt.format(1.5));\n System.out.println(\"Format with 2 : \" + fmt.format(2));\n System.out.println(\"Format with 2.1 : \" + fmt.format(2.1));\n System.out.println(\"Format with NaN : \" + fmt.format(Double.NaN));\n System.out.println(\"Format with +INF : \" + fmt.format(Double.POSITIVE_INFINITY));\n }\u003c/pre\u003e\n \u003c/blockquote\u003e\n And the output result would be like the following:\n \u003cblockquote\u003e\n \u003cpre\u003e{@code\n Format with -INF : is negative\n Format with -1.0 : is negative\n Format with 0 : is zero or fraction\n Format with 0.9 : is zero or fraction\n Format with 1.0 : is one\n Format with 1.5 : is 1+\n Format with 2 : is two\n Format with 2.1 : is more than 2.\n Format with NaN : is negative\n Format with +INF : is more than 2.\n }\u003c/pre\u003e\n \u003c/blockquote\u003e\n\n \u003ch3\u003e\u003ca name\u003d\"synchronization\"\u003eSynchronization\u003c/a\u003e\u003c/h3\u003e\n\n \u003cp\u003e\n Choice formats are not synchronized.\n It is recommended to create separate format instances for each thread.\n If multiple threads access a format concurrently, it must be synchronized\n externally.","isClass":true,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":false,"isOrdinaryClass":true,"isPrimitive":false,"simpleName":"ChoiceFormat","qualifiedName":"java.text.ChoiceFormat","dimension":"","elementType":{},"package":"java.text","superclass":"java.text.NumberFormat","interfaces":[],"isAbstract":false,"isStatic":false,"innerClasses":[],"isInnerClass":false,"constructors":[{"name":"ChoiceFormat","comment":"Constructs with limits and corresponding formats based on the pattern.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":true,"isField":false,"isMethod":false,"isOrdinaryClass":false,"signature":"(java.lang.String)","flatSignature":"(String)","parameters":[{"name":"newPattern","type":{"isPrimitive":false,"simpleName":"String","qualifiedName":"java.lang.String","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"ChoiceFormat","comment":"Constructs with the limits and the corresponding formats.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":true,"isField":false,"isMethod":false,"isOrdinaryClass":false,"signature":"(double[], java.lang.String[])","flatSignature":"(double[], String[])","parameters":[{"name":"limits","type":{"isPrimitive":true,"simpleName":"double","qualifiedName":"double","dimension":"[]","elementType":{"isPrimitive":true,"simpleName":"double","qualifiedName":"double","dimension":"","elementType":{}}}},{"name":"formats","type":{"isPrimitive":false,"simpleName":"String","qualifiedName":"java.lang.String","dimension":"[]","elementType":{"isPrimitive":false,"simpleName":"String","qualifiedName":"java.lang.String","dimension":"","elementType":{}}}}],"typeParameters":[]}],"fields":[],"methods":[{"name":"applyPattern","comment":"Sets the pattern.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.lang.String)","flatSignature":"(String)","returnType":{"isPrimitive":true,"simpleName":"void","qualifiedName":"void","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[{"name":"newPattern","type":{"isPrimitive":false,"simpleName":"String","qualifiedName":"java.lang.String","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"toPattern","comment":"Gets the pattern.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":false,"simpleName":"String","qualifiedName":"java.lang.String","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[],"typeParameters":[]},{"name":"setChoices","comment":"Set the choices to be used in formatting.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(double[], java.lang.String[])","flatSignature":"(double[], String[])","returnType":{"isPrimitive":true,"simpleName":"void","qualifiedName":"void","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[{"name":"limits","type":{"isPrimitive":true,"simpleName":"double","qualifiedName":"double","dimension":"[]","elementType":{"isPrimitive":true,"simpleName":"double","qualifiedName":"double","dimension":"","elementType":{}}}},{"name":"formats","type":{"isPrimitive":false,"simpleName":"String","qualifiedName":"java.lang.String","dimension":"[]","elementType":{"isPrimitive":false,"simpleName":"String","qualifiedName":"java.lang.String","dimension":"","elementType":{}}}}],"typeParameters":[]},{"name":"getLimits","comment":"Get the limits passed in the constructor.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":true,"simpleName":"double","qualifiedName":"double","dimension":"[]","elementType":{"isPrimitive":true,"simpleName":"double","qualifiedName":"double","dimension":"","elementType":{}}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[],"typeParameters":[]},{"name":"getFormats","comment":"Get the formats passed in the constructor.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":false,"simpleName":"Object","qualifiedName":"java.lang.Object","dimension":"[]","elementType":{"isPrimitive":false,"simpleName":"Object","qualifiedName":"java.lang.Object","dimension":"","elementType":{}}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[],"typeParameters":[]},{"name":"format","comment":"Specialization of format. This method really calls\n \u003ccode\u003eformat(double, StringBuffer, FieldPosition)\u003c/code\u003e\n thus the range of longs that are supported is only equal to\n the range that can be stored by double. This will never be\n a practical limitation.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(long, java.lang.StringBuffer, java.text.FieldPosition)","flatSignature":"(long, StringBuffer, FieldPosition)","returnType":{"isPrimitive":false,"simpleName":"StringBuffer","qualifiedName":"java.lang.StringBuffer","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[{"name":"number","type":{"isPrimitive":true,"simpleName":"long","qualifiedName":"long","dimension":"","elementType":{}}},{"name":"toAppendTo","type":{"isPrimitive":false,"simpleName":"StringBuffer","qualifiedName":"java.lang.StringBuffer","dimension":"","elementType":{}}},{"name":"status","type":{"isPrimitive":false,"simpleName":"FieldPosition","qualifiedName":"java.text.FieldPosition","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"format","comment":"Returns pattern with formatted double.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(double, java.lang.StringBuffer, java.text.FieldPosition)","flatSignature":"(double, StringBuffer, FieldPosition)","returnType":{"isPrimitive":false,"simpleName":"StringBuffer","qualifiedName":"java.lang.StringBuffer","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[{"name":"number","type":{"isPrimitive":true,"simpleName":"double","qualifiedName":"double","dimension":"","elementType":{}}},{"name":"toAppendTo","type":{"isPrimitive":false,"simpleName":"StringBuffer","qualifiedName":"java.lang.StringBuffer","dimension":"","elementType":{}}},{"name":"status","type":{"isPrimitive":false,"simpleName":"FieldPosition","qualifiedName":"java.text.FieldPosition","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"parse","comment":"Parses a Number from the input text.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.lang.String, java.text.ParsePosition)","flatSignature":"(String, ParsePosition)","returnType":{"isPrimitive":false,"simpleName":"Number","qualifiedName":"java.lang.Number","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[{"name":"text","type":{"isPrimitive":false,"simpleName":"String","qualifiedName":"java.lang.String","dimension":"","elementType":{}}},{"name":"status","type":{"isPrimitive":false,"simpleName":"ParsePosition","qualifiedName":"java.text.ParsePosition","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"nextDouble","comment":"Finds the least double greater than {@code d}.\n If {@code NaN}, returns same value.\n \u003cp\u003eUsed to make half-open intervals.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(double)","flatSignature":"(double)","returnType":{"isPrimitive":true,"simpleName":"double","qualifiedName":"double","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"d","type":{"isPrimitive":true,"simpleName":"double","qualifiedName":"double","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"previousDouble","comment":"Finds the greatest double less than {@code d}.\n If {@code NaN}, returns same value.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(double)","flatSignature":"(double)","returnType":{"isPrimitive":true,"simpleName":"double","qualifiedName":"double","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"d","type":{"isPrimitive":true,"simpleName":"double","qualifiedName":"double","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"clone","comment":"Overrides Cloneable","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":false,"simpleName":"Object","qualifiedName":"java.lang.Object","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[],"typeParameters":[]},{"name":"hashCode","comment":"Generates a hash code for the message format object.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[],"typeParameters":[]},{"name":"equals","comment":"Equality comparision between two","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.lang.Object)","flatSignature":"(Object)","returnType":{"isPrimitive":true,"simpleName":"boolean","qualifiedName":"boolean","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[{"name":"obj","type":{"isPrimitive":false,"simpleName":"Object","qualifiedName":"java.lang.Object","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"nextDouble","comment":"Finds the least double greater than {@code d} (if {@code positive} is\n {@code true}), or the greatest double less than {@code d} (if\n {@code positive} is {@code false}).\n If {@code NaN}, returns same value.\n\n Does not affect floating-point flags,\n provided these member functions do not:\n          Double.longBitsToDouble(long)\n          Double.doubleToLongBits(double)\n          Double.isNaN(double)","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(double, boolean)","flatSignature":"(double, boolean)","returnType":{"isPrimitive":true,"simpleName":"double","qualifiedName":"double","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"d","type":{"isPrimitive":true,"simpleName":"double","qualifiedName":"double","dimension":"","elementType":{}}},{"name":"positive","type":{"isPrimitive":true,"simpleName":"boolean","qualifiedName":"boolean","dimension":"","elementType":{}}}],"typeParameters":[]}],"typeParameters":[],"enumConstants":[]}