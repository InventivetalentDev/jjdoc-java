{"name":"RuleBasedCollator","comment":"The \u003ccode\u003eRuleBasedCollator\u003c/code\u003e class is a concrete subclass of\n \u003ccode\u003eCollator\u003c/code\u003e that provides a simple, data-driven, table\n collator.  With this class you can create a customized table-based\n \u003ccode\u003eCollator\u003c/code\u003e.  \u003ccode\u003eRuleBasedCollator\u003c/code\u003e maps\n characters to sort keys.\n\n \u003cp\u003e\n \u003ccode\u003eRuleBasedCollator\u003c/code\u003e has the following restrictions\n for efficiency (other subclasses may be used for more complex languages) :\n \u003col\u003e\n \u003cli\u003eIf a special collation rule controlled by a \u0026lt;modifier\u0026gt; is\n      specified it applies to the whole collator object.\n \u003cli\u003eAll non-mentioned characters are at the end of the\n     collation order.\n \u003c/ol\u003e\n\n \u003cp\u003e\n The collation table is composed of a list of collation rules, where each\n rule is of one of three forms:\n \u003cpre\u003e\n    \u0026lt;modifier\u0026gt;\n    \u0026lt;relation\u0026gt; \u0026lt;text-argument\u0026gt;\n    \u0026lt;reset\u0026gt; \u0026lt;text-argument\u0026gt;\n \u003c/pre\u003e\n The definitions of the rule elements is as follows:\n \u003cUL\u003e\n    \u003cLI\u003e\u003cstrong\u003eText-Argument\u003c/strong\u003e: A text-argument is any sequence of\n        characters, excluding special characters (that is, common\n        whitespace characters [0009-000D, 0020] and rule syntax characters\n        [0021-002F, 003A-0040, 005B-0060, 007B-007E]). If those\n        characters are desired, you can put them in single quotes\n        (e.g. ampersand \u003d\u0026gt; \u0027\u0026amp;\u0027). Note that unquoted white space characters\n        are ignored; e.g. \u003ccode\u003eb c\u003c/code\u003e is treated as \u003ccode\u003ebc\u003c/code\u003e.\n    \u003cLI\u003e\u003cstrong\u003eModifier\u003c/strong\u003e: There are currently two modifiers that\n        turn on special collation rules.\n        \u003cUL\u003e\n            \u003cLI\u003e\u0027@\u0027 : Turns on backwards sorting of accents (secondary\n                      differences), as in French.\n            \u003cLI\u003e\u0027!\u0027 : Turns on Thai/Lao vowel-consonant swapping.  If this\n                      rule is in force when a Thai vowel of the range\n                      \u0026#92;U0E40-\u0026#92;U0E44 precedes a Thai consonant of the range\n                      \u0026#92;U0E01-\u0026#92;U0E2E OR a Lao vowel of the range \u0026#92;U0EC0-\u0026#92;U0EC4\n                      precedes a Lao consonant of the range \u0026#92;U0E81-\u0026#92;U0EAE then\n                      the vowel is placed after the consonant for collation\n                      purposes.\n        \u003c/UL\u003e\n        \u003cp\u003e\u0027@\u0027 : Indicates that accents are sorted backwards, as in French.\n    \u003cLI\u003e\u003cstrong\u003eRelation\u003c/strong\u003e: The relations are the following:\n        \u003cUL\u003e\n            \u003cLI\u003e\u0027\u0026lt;\u0027 : Greater, as a letter difference (primary)\n            \u003cLI\u003e\u0027;\u0027 : Greater, as an accent difference (secondary)\n            \u003cLI\u003e\u0027,\u0027 : Greater, as a case difference (tertiary)\n            \u003cLI\u003e\u0027\u003d\u0027 : Equal\n        \u003c/UL\u003e\n    \u003cLI\u003e\u003cstrong\u003eReset\u003c/strong\u003e: There is a single reset\n        which is used primarily for contractions and expansions, but which\n        can also be used to add a modification at the end of a set of rules.\n        \u003cp\u003e\u0027\u0026amp;\u0027 : Indicates that the next rule follows the position to where\n            the reset text-argument would be sorted.\n \u003c/UL\u003e\n\n \u003cp\u003e\n This sounds more complicated than it is in practice. For example, the\n following are equivalent ways of expressing the same thing:\n \u003cblockquote\u003e\n \u003cpre\u003e\n a \u0026lt; b \u0026lt; c\n a \u0026lt; b \u0026amp; b \u0026lt; c\n a \u0026lt; c \u0026amp; a \u0026lt; b\n \u003c/pre\u003e\n \u003c/blockquote\u003e\n Notice that the order is important, as the subsequent item goes immediately\n after the text-argument. The following are not equivalent:\n \u003cblockquote\u003e\n \u003cpre\u003e\n a \u0026lt; b \u0026amp; a \u0026lt; c\n a \u0026lt; c \u0026amp; a \u0026lt; b\n \u003c/pre\u003e\n \u003c/blockquote\u003e\n Either the text-argument must already be present in the sequence, or some\n initial substring of the text-argument must be present. (e.g. \"a \u0026lt; b \u0026amp; ae \u0026lt;\n e\" is valid since \"a\" is present in the sequence before \"ae\" is reset). In\n this latter case, \"ae\" is not entered and treated as a single character;\n instead, \"e\" is sorted as if it were expanded to two characters: \"a\"\n followed by an \"e\". This difference appears in natural languages: in\n traditional Spanish \"ch\" is treated as though it contracts to a single\n character (expressed as \"c \u0026lt; ch \u0026lt; d\"), while in traditional German\n a-umlaut is treated as though it expanded to two characters\n (expressed as \"a,A \u0026lt; b,B ... \u0026amp;ae;\u0026#92;u00e3\u0026amp;AE;\u0026#92;u00c3\").\n [\u0026#92;u00e3 and \u0026#92;u00c3 are, of course, the escape sequences for a-umlaut.]\n \u003cp\u003e\n \u003cstrong\u003eIgnorable Characters\u003c/strong\u003e\n \u003cp\u003e\n For ignorable characters, the first rule must start with a relation (the\n examples we have used above are really fragments; \"a \u0026lt; b\" really should be\n \"\u0026lt; a \u0026lt; b\"). If, however, the first relation is not \"\u0026lt;\", then all the all\n text-arguments up to the first \"\u0026lt;\" are ignorable. For example, \", - \u0026lt; a \u0026lt; b\"\n makes \"-\" an ignorable character, as we saw earlier in the word\n \"black-birds\". In the samples for different languages, you see that most\n accents are ignorable.\n\n \u003cp\u003e\u003cstrong\u003eNormalization and Accents\u003c/strong\u003e\n \u003cp\u003e\n \u003ccode\u003eRuleBasedCollator\u003c/code\u003e automatically processes its rule table to\n include both pre-composed and combining-character versions of\n accented characters.  Even if the provided rule string contains only\n base characters and separate combining accent characters, the pre-composed\n accented characters matching all canonical combinations of characters from\n the rule string will be entered in the table.\n \u003cp\u003e\n This allows you to use a RuleBasedCollator to compare accented strings\n even when the collator is set to NO_DECOMPOSITION.  There are two caveats,\n however.  First, if the strings to be collated contain combining\n sequences that may not be in canonical order, you should set the collator to\n CANONICAL_DECOMPOSITION or FULL_DECOMPOSITION to enable sorting of\n combining sequences.  Second, if the strings contain characters with\n compatibility decompositions (such as full-width and half-width forms),\n you must use FULL_DECOMPOSITION, since the rule tables only include\n canonical mappings.\n\n \u003cp\u003e\u003cstrong\u003eErrors\u003c/strong\u003e\n \u003cp\u003e\n The following are errors:\n \u003cUL\u003e\n     \u003cLI\u003eA text-argument contains unquoted punctuation symbols\n        (e.g. \"a \u0026lt; b-c \u0026lt; d\").\n     \u003cLI\u003eA relation or reset character not followed by a text-argument\n        (e.g. \"a \u0026lt; ,b\").\n     \u003cLI\u003eA reset where the text-argument (or an initial substring of the\n         text-argument) is not already in the sequence.\n         (e.g. \"a \u0026lt; b \u0026amp; e \u0026lt; f\")\n \u003c/UL\u003e\n If you produce one of these errors, a \u003ccode\u003eRuleBasedCollator\u003c/code\u003e throws\n a \u003ccode\u003eParseException\u003c/code\u003e.\n\n \u003cp\u003e\u003cstrong\u003eExamples\u003c/strong\u003e\n \u003cp\u003eSimple:     \"\u0026lt; a \u0026lt; b \u0026lt; c \u0026lt; d\"\n \u003cp\u003eNorwegian:  \"\u0026lt; a, A \u0026lt; b, B \u0026lt; c, C \u0026lt; d, D \u0026lt; e, E \u0026lt; f, F\n                 \u0026lt; g, G \u0026lt; h, H \u0026lt; i, I \u0026lt; j, J \u0026lt; k, K \u0026lt; l, L\n                 \u0026lt; m, M \u0026lt; n, N \u0026lt; o, O \u0026lt; p, P \u0026lt; q, Q \u0026lt; r, R\n                 \u0026lt; s, S \u0026lt; t, T \u0026lt; u, U \u0026lt; v, V \u0026lt; w, W \u0026lt; x, X\n                 \u0026lt; y, Y \u0026lt; z, Z\n                 \u0026lt; \u0026#92;u00E6, \u0026#92;u00C6\n                 \u0026lt; \u0026#92;u00F8, \u0026#92;u00D8\n                 \u0026lt; \u0026#92;u00E5 \u003d a\u0026#92;u030A, \u0026#92;u00C5 \u003d A\u0026#92;u030A;\n                      aa, AA\"\n\n \u003cp\u003e\n To create a \u003ccode\u003eRuleBasedCollator\u003c/code\u003e object with specialized\n rules tailored to your needs, you construct the \u003ccode\u003eRuleBasedCollator\u003c/code\u003e\n with the rules contained in a \u003ccode\u003eString\u003c/code\u003e object. For example:\n \u003cblockquote\u003e\n \u003cpre\u003e\n String simple \u003d \"\u0026lt; a\u0026lt; b\u0026lt; c\u0026lt; d\";\n RuleBasedCollator mySimple \u003d new RuleBasedCollator(simple);\n \u003c/pre\u003e\n \u003c/blockquote\u003e\n Or:\n \u003cblockquote\u003e\n \u003cpre\u003e\n String Norwegian \u003d \"\u0026lt; a, A \u0026lt; b, B \u0026lt; c, C \u0026lt; d, D \u0026lt; e, E \u0026lt; f, F \u0026lt; g, G \u0026lt; h, H \u0026lt; i, I\" +\n                    \"\u0026lt; j, J \u0026lt; k, K \u0026lt; l, L \u0026lt; m, M \u0026lt; n, N \u0026lt; o, O \u0026lt; p, P \u0026lt; q, Q \u0026lt; r, R\" +\n                    \"\u0026lt; s, S \u0026lt; t, T \u0026lt; u, U \u0026lt; v, V \u0026lt; w, W \u0026lt; x, X \u0026lt; y, Y \u0026lt; z, Z\" +\n                    \"\u0026lt; \u0026#92;u00E6, \u0026#92;u00C6\" +     // Latin letter ae \u0026amp; AE\n                    \"\u0026lt; \u0026#92;u00F8, \u0026#92;u00D8\" +     // Latin letter o \u0026amp; O with stroke\n                    \"\u0026lt; \u0026#92;u00E5 \u003d a\u0026#92;u030A,\" +  // Latin letter a with ring above\n                    \"  \u0026#92;u00C5 \u003d A\u0026#92;u030A;\" +  // Latin letter A with ring above\n                    \"  aa, AA\";\n RuleBasedCollator myNorwegian \u003d new RuleBasedCollator(Norwegian);\n \u003c/pre\u003e\n \u003c/blockquote\u003e\n\n \u003cp\u003e\n A new collation rules string can be created by concatenating rules\n strings. For example, the rules returned by {@link #getRules()} could\n be concatenated to combine multiple \u003ccode\u003eRuleBasedCollator\u003c/code\u003es.\n\n \u003cp\u003e\n The following example demonstrates how to change the order of\n non-spacing accents,\n \u003cblockquote\u003e\n \u003cpre\u003e\n // old rule\n String oldRules \u003d \"\u003d\u0026#92;u0301;\u0026#92;u0300;\u0026#92;u0302;\u0026#92;u0308\"    // main accents\n                 + \";\u0026#92;u0327;\u0026#92;u0303;\u0026#92;u0304;\u0026#92;u0305\"    // main accents\n                 + \";\u0026#92;u0306;\u0026#92;u0307;\u0026#92;u0309;\u0026#92;u030A\"    // main accents\n                 + \";\u0026#92;u030B;\u0026#92;u030C;\u0026#92;u030D;\u0026#92;u030E\"    // main accents\n                 + \";\u0026#92;u030F;\u0026#92;u0310;\u0026#92;u0311;\u0026#92;u0312\"    // main accents\n                 + \"\u0026lt; a , A ; ae, AE ; \u0026#92;u00e6 , \u0026#92;u00c6\"\n                 + \"\u0026lt; b , B \u0026lt; c, C \u0026lt; e, E \u0026amp; C \u0026lt; d, D\";\n // change the order of accent characters\n String addOn \u003d \"\u0026amp; \u0026#92;u0300 ; \u0026#92;u0308 ; \u0026#92;u0302\";\n RuleBasedCollator myCollator \u003d new RuleBasedCollator(oldRules + addOn);\n \u003c/pre\u003e\n \u003c/blockquote\u003e","isClass":true,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":false,"isOrdinaryClass":true,"isPrimitive":false,"simpleName":"RuleBasedCollator","qualifiedName":"java.text.RuleBasedCollator","dimension":"","elementType":{},"package":"java.text","superclass":"java.text.Collator","interfaces":[],"isAbstract":false,"isStatic":false,"innerClasses":[],"isInnerClass":false,"constructors":[{"name":"RuleBasedCollator","comment":"RuleBasedCollator constructor.  This takes the table rules and builds\n a collation table out of them.  Please see RuleBasedCollator class\n description for more details on the collation rule syntax.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":true,"isField":false,"isMethod":false,"isOrdinaryClass":false,"signature":"(java.lang.String)","flatSignature":"(String)","parameters":[{"name":"rules","type":{"isPrimitive":false,"simpleName":"String","qualifiedName":"java.lang.String","dimension":"","elementType":{}}}],"typeParameters":[]}],"fields":[],"methods":[{"name":"getRules","comment":"Gets the table-based rules for the collation object.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":false,"simpleName":"String","qualifiedName":"java.lang.String","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[],"typeParameters":[]},{"name":"getCollationElementIterator","comment":"Returns a CollationElementIterator for the given String.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.lang.String)","flatSignature":"(String)","returnType":{"isPrimitive":false,"simpleName":"CollationElementIterator","qualifiedName":"java.text.CollationElementIterator","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[{"name":"source","type":{"isPrimitive":false,"simpleName":"String","qualifiedName":"java.lang.String","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"getCollationElementIterator","comment":"Returns a CollationElementIterator for the given CharacterIterator.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.text.CharacterIterator)","flatSignature":"(CharacterIterator)","returnType":{"isPrimitive":false,"simpleName":"CollationElementIterator","qualifiedName":"java.text.CollationElementIterator","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[{"name":"source","type":{"isPrimitive":false,"simpleName":"CharacterIterator","qualifiedName":"java.text.CharacterIterator","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"compare","comment":"Compares the character data stored in two different strings based on the\n collation rules.  Returns information about whether a string is less\n than, greater than or equal to another string in a language.\n This can be overriden in a subclass.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.lang.String, java.lang.String)","flatSignature":"(String, String)","returnType":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[{"name":"source","type":{"isPrimitive":false,"simpleName":"String","qualifiedName":"java.lang.String","dimension":"","elementType":{}}},{"name":"target","type":{"isPrimitive":false,"simpleName":"String","qualifiedName":"java.lang.String","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"getCollationKey","comment":"Transforms the string into a series of characters that can be compared\n with CollationKey.compareTo. This overrides java.text.Collator.getCollationKey.\n It can be overriden in a subclass.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.lang.String)","flatSignature":"(String)","returnType":{"isPrimitive":false,"simpleName":"CollationKey","qualifiedName":"java.text.CollationKey","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[{"name":"source","type":{"isPrimitive":false,"simpleName":"String","qualifiedName":"java.lang.String","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"clone","comment":"Standard override; no change in semantics.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":false,"simpleName":"Object","qualifiedName":"java.lang.Object","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[],"typeParameters":[]},{"name":"equals","comment":"Compares the equality of two collation objects.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.lang.Object)","flatSignature":"(Object)","returnType":{"isPrimitive":true,"simpleName":"boolean","qualifiedName":"boolean","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[{"name":"obj","type":{"isPrimitive":false,"simpleName":"Object","qualifiedName":"java.lang.Object","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"hashCode","comment":"Generates the hash code for the table-based collation object","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[],"typeParameters":[]}],"typeParameters":[],"enumConstants":[]}