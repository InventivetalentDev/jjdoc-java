{"name":"DataInput","comment":"The {@code DataInput} interface provides\n for reading bytes from a binary stream and\n reconstructing from them data in any of\n the Java primitive types. There is also\n a\n facility for reconstructing a {@code String}\n from data in\n \u003ca href\u003d\"#modified-utf-8\"\u003emodified UTF-8\u003c/a\u003e\n format.\n \u003cp\u003e\n It is generally true of all the reading\n routines in this interface that if end of\n file is reached before the desired number\n of bytes has been read, an {@code EOFException}\n (which is a kind of {@code IOException})\n is thrown. If any byte cannot be read for\n any reason other than end of file, an {@code IOException}\n other than {@code EOFException} is\n thrown. In particular, an {@code IOException}\n may be thrown if the input stream has been\n closed.\n\n \u003ch3\u003e\u003ca name\u003d\"modified-utf-8\"\u003eModified UTF-8\u003c/a\u003e\u003c/h3\u003e\n \u003cp\u003e\n Implementations of the DataInput and DataOutput interfaces represent\n Unicode strings in a format that is a slight modification of UTF-8.\n (For information regarding the standard UTF-8 format, see section\n \u003ci\u003e3.9 Unicode Encoding Forms\u003c/i\u003e of \u003ci\u003eThe Unicode Standard, Version\n 4.0\u003c/i\u003e).\n Note that in the following table, the most significant bit appears in the\n far left-hand column.\n\n \u003cblockquote\u003e\n   \u003ctable border\u003d\"1\" cellspacing\u003d\"0\" cellpadding\u003d\"8\"\n          summary\u003d\"Bit values and bytes\"\u003e\n     \u003ctr\u003e\n       \u003cth colspan\u003d\"9\"\u003e\u003cspan style\u003d\"font-weight:normal\"\u003e\n         All characters in the range {@code \u0027\\u0001\u0027} to\n         {@code \u0027\\u007F\u0027} are represented by a single byte:\u003c/span\u003e\u003c/th\u003e\n     \u003c/tr\u003e\n     \u003ctr\u003e\n       \u003ctd\u003e\u003c/td\u003e\n       \u003cth colspan\u003d\"8\" id\u003d\"bit_a\"\u003eBit Values\u003c/th\u003e\n     \u003c/tr\u003e\n     \u003ctr\u003e\n       \u003cth id\u003d\"byte1_a\"\u003eByte 1\u003c/th\u003e\n       \u003ctd\u003e\u003ccenter\u003e0\u003c/center\u003e\n       \u003ctd colspan\u003d\"7\"\u003e\u003ccenter\u003ebits 6-0\u003c/center\u003e\n     \u003c/tr\u003e\n     \u003ctr\u003e\n       \u003cth colspan\u003d\"9\"\u003e\u003cspan style\u003d\"font-weight:normal\"\u003e\n         The null character {@code \u0027\\u0000\u0027} and characters\n         in the range {@code \u0027\\u0080\u0027} to {@code \u0027\\u07FF\u0027} are\n         represented by a pair of bytes:\u003c/span\u003e\u003c/th\u003e\n     \u003c/tr\u003e\n     \u003ctr\u003e\n       \u003ctd\u003e\u003c/td\u003e\n       \u003cth colspan\u003d\"8\" id\u003d\"bit_b\"\u003eBit Values\u003c/th\u003e\n     \u003c/tr\u003e\n     \u003ctr\u003e\n       \u003cth id\u003d\"byte1_b\"\u003eByte 1\u003c/th\u003e\n       \u003ctd\u003e\u003ccenter\u003e1\u003c/center\u003e\n       \u003ctd\u003e\u003ccenter\u003e1\u003c/center\u003e\n       \u003ctd\u003e\u003ccenter\u003e0\u003c/center\u003e\n       \u003ctd colspan\u003d\"5\"\u003e\u003ccenter\u003ebits 10-6\u003c/center\u003e\n     \u003c/tr\u003e\n     \u003ctr\u003e\n       \u003cth id\u003d\"byte2_a\"\u003eByte 2\u003c/th\u003e\n       \u003ctd\u003e\u003ccenter\u003e1\u003c/center\u003e\n       \u003ctd\u003e\u003ccenter\u003e0\u003c/center\u003e\n       \u003ctd colspan\u003d\"6\"\u003e\u003ccenter\u003ebits 5-0\u003c/center\u003e\n     \u003c/tr\u003e\n     \u003ctr\u003e\n       \u003cth colspan\u003d\"9\"\u003e\u003cspan style\u003d\"font-weight:normal\"\u003e\n         {@code char} values in the range {@code \u0027\\u0800\u0027}\n         to {@code \u0027\\uFFFF\u0027} are represented by three bytes:\u003c/span\u003e\u003c/th\u003e\n     \u003c/tr\u003e\n     \u003ctr\u003e\n       \u003ctd\u003e\u003c/td\u003e\n       \u003cth colspan\u003d\"8\"id\u003d\"bit_c\"\u003eBit Values\u003c/th\u003e\n     \u003c/tr\u003e\n     \u003ctr\u003e\n       \u003cth id\u003d\"byte1_c\"\u003eByte 1\u003c/th\u003e\n       \u003ctd\u003e\u003ccenter\u003e1\u003c/center\u003e\n       \u003ctd\u003e\u003ccenter\u003e1\u003c/center\u003e\n       \u003ctd\u003e\u003ccenter\u003e1\u003c/center\u003e\n       \u003ctd\u003e\u003ccenter\u003e0\u003c/center\u003e\n       \u003ctd colspan\u003d\"4\"\u003e\u003ccenter\u003ebits 15-12\u003c/center\u003e\n     \u003c/tr\u003e\n     \u003ctr\u003e\n       \u003cth id\u003d\"byte2_b\"\u003eByte 2\u003c/th\u003e\n       \u003ctd\u003e\u003ccenter\u003e1\u003c/center\u003e\n       \u003ctd\u003e\u003ccenter\u003e0\u003c/center\u003e\n       \u003ctd colspan\u003d\"6\"\u003e\u003ccenter\u003ebits 11-6\u003c/center\u003e\n     \u003c/tr\u003e\n     \u003ctr\u003e\n       \u003cth id\u003d\"byte3\"\u003eByte 3\u003c/th\u003e\n       \u003ctd\u003e\u003ccenter\u003e1\u003c/center\u003e\n       \u003ctd\u003e\u003ccenter\u003e0\u003c/center\u003e\n       \u003ctd colspan\u003d\"6\"\u003e\u003ccenter\u003ebits 5-0\u003c/center\u003e\n     \u003c/tr\u003e\n   \u003c/table\u003e\n \u003c/blockquote\u003e\n \u003cp\u003e\n The differences between this format and the\n standard UTF-8 format are the following:\n \u003cul\u003e\n \u003cli\u003eThe null byte {@code \u0027\\u0000\u0027} is encoded in 2-byte format\n     rather than 1-byte, so that the encoded strings never have\n     embedded nulls.\n \u003cli\u003eOnly the 1-byte, 2-byte, and 3-byte formats are used.\n \u003cli\u003e\u003ca href\u003d\"../lang/Character.html#unicode\"\u003eSupplementary characters\u003c/a\u003e\n     are represented in the form of surrogate pairs.\n \u003c/ul\u003e","isClass":false,"isInterface":true,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":false,"isOrdinaryClass":false,"isPrimitive":false,"simpleName":"DataInput","qualifiedName":"java.io.DataInput","dimension":"","elementType":{},"package":"java.io","interfaces":[],"isAbstract":true,"isStatic":false,"since":"JDK1.0","innerClasses":[],"isInnerClass":false,"constructors":[],"fields":[],"methods":[{"name":"readFully","comment":"Reads some bytes from an input\n stream and stores them into the buffer\n array {@code b}. The number of bytes\n read is equal\n to the length of {@code b}.\n \u003cp\u003e\n This method blocks until one of the\n following conditions occurs:\n \u003cul\u003e\n \u003cli\u003e{@code b.length}\n bytes of input data are available, in which\n case a normal return is made.\n\n \u003cli\u003eEnd of\n file is detected, in which case an {@code EOFException}\n is thrown.\n\n \u003cli\u003eAn I/O error occurs, in\n which case an {@code IOException} other\n than {@code EOFException} is thrown.\n \u003c/ul\u003e\n \u003cp\u003e\n If {@code b} is {@code null},\n a {@code NullPointerException} is thrown.\n If {@code b.length} is zero, then\n no bytes are read. Otherwise, the first\n byte read is stored into element {@code b[0]},\n the next one into {@code b[1]}, and\n so on.\n If an exception is thrown from\n this method, then it may be that some but\n not all bytes of {@code b} have been\n updated with data from the input stream.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(byte[])","flatSignature":"(byte[])","returnType":{"isPrimitive":true,"simpleName":"void","qualifiedName":"void","dimension":"","elementType":{}},"isAbstract":true,"isDefault":false,"isStatic":false,"parameters":[{"name":"b","type":{"isPrimitive":true,"simpleName":"byte","qualifiedName":"byte","dimension":"[]","elementType":{"isPrimitive":true,"simpleName":"byte","qualifiedName":"byte","dimension":"","elementType":{}}}}],"typeParameters":[]},{"name":"readFully","comment":"Reads {@code len}\n bytes from\n an input stream.\n \u003cp\u003e\n This method\n blocks until one of the following conditions\n occurs:\n \u003cul\u003e\n \u003cli\u003e{@code len} bytes\n of input data are available, in which case\n a normal return is made.\n\n \u003cli\u003eEnd of file\n is detected, in which case an {@code EOFException}\n is thrown.\n\n \u003cli\u003eAn I/O error occurs, in\n which case an {@code IOException} other\n than {@code EOFException} is thrown.\n \u003c/ul\u003e\n \u003cp\u003e\n If {@code b} is {@code null},\n a {@code NullPointerException} is thrown.\n If {@code off} is negative, or {@code len}\n is negative, or {@code off+len} is\n greater than the length of the array {@code b},\n then an {@code IndexOutOfBoundsException}\n is thrown.\n If {@code len} is zero,\n then no bytes are read. Otherwise, the first\n byte read is stored into element {@code b[off]},\n the next one into {@code b[off+1]},\n and so on. The number of bytes read is,\n at most, equal to {@code len}.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(byte[], int, int)","flatSignature":"(byte[], int, int)","returnType":{"isPrimitive":true,"simpleName":"void","qualifiedName":"void","dimension":"","elementType":{}},"isAbstract":true,"isDefault":false,"isStatic":false,"parameters":[{"name":"b","type":{"isPrimitive":true,"simpleName":"byte","qualifiedName":"byte","dimension":"[]","elementType":{"isPrimitive":true,"simpleName":"byte","qualifiedName":"byte","dimension":"","elementType":{}}}},{"name":"off","type":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}}},{"name":"len","type":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"skipBytes","comment":"Makes an attempt to skip over\n {@code n} bytes\n of data from the input\n stream, discarding the skipped bytes. However,\n it may skip\n over some smaller number of\n bytes, possibly zero. This may result from\n any of a\n number of conditions; reaching\n end of file before {@code n} bytes\n have been skipped is\n only one possibility.\n This method never throws an {@code EOFException}.\n The actual\n number of bytes skipped is returned.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(int)","flatSignature":"(int)","returnType":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}},"isAbstract":true,"isDefault":false,"isStatic":false,"parameters":[{"name":"n","type":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"readBoolean","comment":"Reads one input byte and returns\n {@code true} if that byte is nonzero,\n {@code false} if that byte is zero.\n This method is suitable for reading\n the byte written by the {@code writeBoolean}\n method of interface {@code DataOutput}.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":true,"simpleName":"boolean","qualifiedName":"boolean","dimension":"","elementType":{}},"isAbstract":true,"isDefault":false,"isStatic":false,"parameters":[],"typeParameters":[]},{"name":"readByte","comment":"Reads and returns one input byte.\n The byte is treated as a signed value in\n the range {@code -128} through {@code 127},\n inclusive.\n This method is suitable for\n reading the byte written by the {@code writeByte}\n method of interface {@code DataOutput}.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":true,"simpleName":"byte","qualifiedName":"byte","dimension":"","elementType":{}},"isAbstract":true,"isDefault":false,"isStatic":false,"parameters":[],"typeParameters":[]},{"name":"readUnsignedByte","comment":"Reads one input byte, zero-extends\n it to type {@code int}, and returns\n the result, which is therefore in the range\n {@code 0}\n through {@code 255}.\n This method is suitable for reading\n the byte written by the {@code writeByte}\n method of interface {@code DataOutput}\n if the argument to {@code writeByte}\n was intended to be a value in the range\n {@code 0} through {@code 255}.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}},"isAbstract":true,"isDefault":false,"isStatic":false,"parameters":[],"typeParameters":[]},{"name":"readShort","comment":"Reads two input bytes and returns\n a {@code short} value. Let {@code a}\n be the first byte read and {@code b}\n be the second byte. The value\n returned\n is:\n \u003cpre\u003e{@code (short)((a \u003c\u003c 8) | (b \u0026 0xff))\n }\u003c/pre\u003e\n This method\n is suitable for reading the bytes written\n by the {@code writeShort} method of\n interface {@code DataOutput}.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":true,"simpleName":"short","qualifiedName":"short","dimension":"","elementType":{}},"isAbstract":true,"isDefault":false,"isStatic":false,"parameters":[],"typeParameters":[]},{"name":"readUnsignedShort","comment":"Reads two input bytes and returns\n an {@code int} value in the range {@code 0}\n through {@code 65535}. Let {@code a}\n be the first byte read and\n {@code b}\n be the second byte. The value returned is:\n \u003cpre\u003e{@code (((a \u0026 0xff) \u003c\u003c 8) | (b \u0026 0xff))\n }\u003c/pre\u003e\n This method is suitable for reading the bytes\n written by the {@code writeShort} method\n of interface {@code DataOutput}  if\n the argument to {@code writeShort}\n was intended to be a value in the range\n {@code 0} through {@code 65535}.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}},"isAbstract":true,"isDefault":false,"isStatic":false,"parameters":[],"typeParameters":[]},{"name":"readChar","comment":"Reads two input bytes and returns a {@code char} value.\n Let {@code a}\n be the first byte read and {@code b}\n be the second byte. The value\n returned is:\n \u003cpre\u003e{@code (char)((a \u003c\u003c 8) | (b \u0026 0xff))\n }\u003c/pre\u003e\n This method\n is suitable for reading bytes written by\n the {@code writeChar} method of interface\n {@code DataOutput}.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":true,"simpleName":"char","qualifiedName":"char","dimension":"","elementType":{}},"isAbstract":true,"isDefault":false,"isStatic":false,"parameters":[],"typeParameters":[]},{"name":"readInt","comment":"Reads four input bytes and returns an\n {@code int} value. Let {@code a-d}\n be the first through fourth bytes read. The value returned is:\n \u003cpre\u003e{@code\n (((a \u0026 0xff) \u003c\u003c 24) | ((b \u0026 0xff) \u003c\u003c 16) |\n  ((c \u0026 0xff) \u003c\u003c  8) | (d \u0026 0xff))\n }\u003c/pre\u003e\n This method is suitable\n for reading bytes written by the {@code writeInt}\n method of interface {@code DataOutput}.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}},"isAbstract":true,"isDefault":false,"isStatic":false,"parameters":[],"typeParameters":[]},{"name":"readLong","comment":"Reads eight input bytes and returns\n a {@code long} value. Let {@code a-h}\n be the first through eighth bytes read.\n The value returned is:\n \u003cpre\u003e{@code\n (((long)(a \u0026 0xff) \u003c\u003c 56) |\n  ((long)(b \u0026 0xff) \u003c\u003c 48) |\n  ((long)(c \u0026 0xff) \u003c\u003c 40) |\n  ((long)(d \u0026 0xff) \u003c\u003c 32) |\n  ((long)(e \u0026 0xff) \u003c\u003c 24) |\n  ((long)(f \u0026 0xff) \u003c\u003c 16) |\n  ((long)(g \u0026 0xff) \u003c\u003c  8) |\n  ((long)(h \u0026 0xff)))\n }\u003c/pre\u003e\n \u003cp\u003e\n This method is suitable\n for reading bytes written by the {@code writeLong}\n method of interface {@code DataOutput}.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":true,"simpleName":"long","qualifiedName":"long","dimension":"","elementType":{}},"isAbstract":true,"isDefault":false,"isStatic":false,"parameters":[],"typeParameters":[]},{"name":"readFloat","comment":"Reads four input bytes and returns\n a {@code float} value. It does this\n by first constructing an {@code int}\n value in exactly the manner\n of the {@code readInt}\n method, then converting this {@code int}\n value to a {@code float} in\n exactly the manner of the method {@code Float.intBitsToFloat}.\n This method is suitable for reading\n bytes written by the {@code writeFloat}\n method of interface {@code DataOutput}.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":true,"simpleName":"float","qualifiedName":"float","dimension":"","elementType":{}},"isAbstract":true,"isDefault":false,"isStatic":false,"parameters":[],"typeParameters":[]},{"name":"readDouble","comment":"Reads eight input bytes and returns\n a {@code double} value. It does this\n by first constructing a {@code long}\n value in exactly the manner\n of the {@code readLong}\n method, then converting this {@code long}\n value to a {@code double} in exactly\n the manner of the method {@code Double.longBitsToDouble}.\n This method is suitable for reading\n bytes written by the {@code writeDouble}\n method of interface {@code DataOutput}.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":true,"simpleName":"double","qualifiedName":"double","dimension":"","elementType":{}},"isAbstract":true,"isDefault":false,"isStatic":false,"parameters":[],"typeParameters":[]},{"name":"readLine","comment":"Reads the next line of text from the input stream.\n It reads successive bytes, converting\n each byte separately into a character,\n until it encounters a line terminator or\n end of\n file; the characters read are then\n returned as a {@code String}. Note\n that because this\n method processes bytes,\n it does not support input of the full Unicode\n character set.\n \u003cp\u003e\n If end of file is encountered\n before even one byte can be read, then {@code null}\n is returned. Otherwise, each byte that is\n read is converted to type {@code char}\n by zero-extension. If the character {@code \u0027\\n\u0027}\n is encountered, it is discarded and reading\n ceases. If the character {@code \u0027\\r\u0027}\n is encountered, it is discarded and, if\n the following byte converts \u0026#32;to the\n character {@code \u0027\\n\u0027}, then that is\n discarded also; reading then ceases. If\n end of file is encountered before either\n of the characters {@code \u0027\\n\u0027} and\n {@code \u0027\\r\u0027} is encountered, reading\n ceases. Once reading has ceased, a {@code String}\n is returned that contains all the characters\n read and not discarded, taken in order.\n Note that every character in this string\n will have a value less than {@code \\u0100},\n that is, {@code (char)256}.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":false,"simpleName":"String","qualifiedName":"java.lang.String","dimension":"","elementType":{}},"isAbstract":true,"isDefault":false,"isStatic":false,"parameters":[],"typeParameters":[]},{"name":"readUTF","comment":"Reads in a string that has been encoded using a\n \u003ca href\u003d\"#modified-utf-8\"\u003emodified UTF-8\u003c/a\u003e\n format.\n The general contract of {@code readUTF}\n is that it reads a representation of a Unicode\n character string encoded in modified\n UTF-8 format; this string of characters\n is then returned as a {@code String}.\n \u003cp\u003e\n First, two bytes are read and used to\n construct an unsigned 16-bit integer in\n exactly the manner of the {@code readUnsignedShort}\n method . This integer value is called the\n \u003ci\u003eUTF length\u003c/i\u003e and specifies the number\n of additional bytes to be read. These bytes\n are then converted to characters by considering\n them in groups. The length of each group\n is computed from the value of the first\n byte of the group. The byte following a\n group, if any, is the first byte of the\n next group.\n \u003cp\u003e\n If the first byte of a group\n matches the bit pattern {@code 0xxxxxxx}\n (where {@code x} means \"may be {@code 0}\n or {@code 1}\"), then the group consists\n of just that byte. The byte is zero-extended\n to form a character.\n \u003cp\u003e\n If the first byte\n of a group matches the bit pattern {@code 110xxxxx},\n then the group consists of that byte {@code a}\n and a second byte {@code b}. If there\n is no byte {@code b} (because byte\n {@code a} was the last of the bytes\n to be read), or if byte {@code b} does\n not match the bit pattern {@code 10xxxxxx},\n then a {@code UTFDataFormatException}\n is thrown. Otherwise, the group is converted\n to the character:\n \u003cpre\u003e{@code (char)(((a \u0026 0x1F) \u003c\u003c 6) | (b \u0026 0x3F))\n }\u003c/pre\u003e\n If the first byte of a group\n matches the bit pattern {@code 1110xxxx},\n then the group consists of that byte {@code a}\n and two more bytes {@code b} and {@code c}.\n If there is no byte {@code c} (because\n byte {@code a} was one of the last\n two of the bytes to be read), or either\n byte {@code b} or byte {@code c}\n does not match the bit pattern {@code 10xxxxxx},\n then a {@code UTFDataFormatException}\n is thrown. Otherwise, the group is converted\n to the character:\n \u003cpre\u003e{@code\n (char)(((a \u0026 0x0F) \u003c\u003c 12) | ((b \u0026 0x3F) \u003c\u003c 6) | (c \u0026 0x3F))\n }\u003c/pre\u003e\n If the first byte of a group matches the\n pattern {@code 1111xxxx} or the pattern\n {@code 10xxxxxx}, then a {@code UTFDataFormatException}\n is thrown.\n \u003cp\u003e\n If end of file is encountered\n at any time during this entire process,\n then an {@code EOFException} is thrown.\n \u003cp\u003e\n After every group has been converted to\n a character by this process, the characters\n are gathered, in the same order in which\n their corresponding groups were read from\n the input stream, to form a {@code String},\n which is returned.\n \u003cp\u003e\n The {@code writeUTF}\n method of interface {@code DataOutput}\n may be used to write data that is suitable\n for reading by this method.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":false,"simpleName":"String","qualifiedName":"java.lang.String","dimension":"","elementType":{}},"isAbstract":true,"isDefault":false,"isStatic":false,"parameters":[],"typeParameters":[]}],"typeParameters":[],"subInterfaces":["java.io.RandomAccessFile","java.io.ObjectInput","java.io.DataInputStream"],"enumConstants":[]}