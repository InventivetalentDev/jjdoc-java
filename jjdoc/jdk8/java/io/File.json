{"name":"File","comment":"An abstract representation of file and directory pathnames.\n\n \u003cp\u003e User interfaces and operating systems use system-dependent \u003cem\u003epathname\n strings\u003c/em\u003e to name files and directories.  This class presents an\n abstract, system-independent view of hierarchical pathnames.  An\n \u003cem\u003eabstract pathname\u003c/em\u003e has two components:\n\n \u003col\u003e\n \u003cli\u003e An optional system-dependent \u003cem\u003eprefix\u003c/em\u003e string,\n      such as a disk-drive specifier, \u003ccode\u003e\"/\"\u003c/code\u003e\u0026nbsp;for the UNIX root\n      directory, or \u003ccode\u003e\"\\\\\\\\\"\u003c/code\u003e\u0026nbsp;for a Microsoft Windows UNC pathname, and\n \u003cli\u003e A sequence of zero or more string \u003cem\u003enames\u003c/em\u003e.\n \u003c/ol\u003e\n\n The first name in an abstract pathname may be a directory name or, in the\n case of Microsoft Windows UNC pathnames, a hostname.  Each subsequent name\n in an abstract pathname denotes a directory; the last name may denote\n either a directory or a file.  The \u003cem\u003eempty\u003c/em\u003e abstract pathname has no\n prefix and an empty name sequence.\n\n \u003cp\u003e The conversion of a pathname string to or from an abstract pathname is\n inherently system-dependent.  When an abstract pathname is converted into a\n pathname string, each name is separated from the next by a single copy of\n the default \u003cem\u003eseparator character\u003c/em\u003e.  The default name-separator\n character is defined by the system property \u003ccode\u003efile.separator\u003c/code\u003e, and\n is made available in the public static fields \u003ccode\u003e{@link\n #separator}\u003c/code\u003e and \u003ccode\u003e{@link #separatorChar}\u003c/code\u003e of this class.\n When a pathname string is converted into an abstract pathname, the names\n within it may be separated by the default name-separator character or by any\n other name-separator character that is supported by the underlying system.\n\n \u003cp\u003e A pathname, whether abstract or in string form, may be either\n \u003cem\u003eabsolute\u003c/em\u003e or \u003cem\u003erelative\u003c/em\u003e.  An absolute pathname is complete in\n that no other information is required in order to locate the file that it\n denotes.  A relative pathname, in contrast, must be interpreted in terms of\n information taken from some other pathname.  By default the classes in the\n \u003ccode\u003ejava.io\u003c/code\u003e package always resolve relative pathnames against the\n current user directory.  This directory is named by the system property\n \u003ccode\u003euser.dir\u003c/code\u003e, and is typically the directory in which the Java\n virtual machine was invoked.\n\n \u003cp\u003e The \u003cem\u003eparent\u003c/em\u003e of an abstract pathname may be obtained by invoking\n the {@link #getParent} method of this class and consists of the pathname\u0027s\n prefix and each name in the pathname\u0027s name sequence except for the last.\n Each directory\u0027s absolute pathname is an ancestor of any \u003ctt\u003eFile\u003c/tt\u003e\n object with an absolute abstract pathname which begins with the directory\u0027s\n absolute pathname.  For example, the directory denoted by the abstract\n pathname \u003ctt\u003e\"/usr\"\u003c/tt\u003e is an ancestor of the directory denoted by the\n pathname \u003ctt\u003e\"/usr/local/bin\"\u003c/tt\u003e.\n\n \u003cp\u003e The prefix concept is used to handle root directories on UNIX platforms,\n and drive specifiers, root directories and UNC pathnames on Microsoft Windows platforms,\n as follows:\n\n \u003cul\u003e\n\n \u003cli\u003e For UNIX platforms, the prefix of an absolute pathname is always\n \u003ccode\u003e\"/\"\u003c/code\u003e.  Relative pathnames have no prefix.  The abstract pathname\n denoting the root directory has the prefix \u003ccode\u003e\"/\"\u003c/code\u003e and an empty\n name sequence.\n\n \u003cli\u003e For Microsoft Windows platforms, the prefix of a pathname that contains a drive\n specifier consists of the drive letter followed by \u003ccode\u003e\":\"\u003c/code\u003e and\n possibly followed by \u003ccode\u003e\"\\\\\"\u003c/code\u003e if the pathname is absolute.  The\n prefix of a UNC pathname is \u003ccode\u003e\"\\\\\\\\\"\u003c/code\u003e; the hostname and the share\n name are the first two names in the name sequence.  A relative pathname that\n does not specify a drive has no prefix.\n\n \u003c/ul\u003e\n\n \u003cp\u003e Instances of this class may or may not denote an actual file-system\n object such as a file or a directory.  If it does denote such an object\n then that object resides in a \u003ci\u003epartition\u003c/i\u003e.  A partition is an\n operating system-specific portion of storage for a file system.  A single\n storage device (e.g. a physical disk-drive, flash memory, CD-ROM) may\n contain multiple partitions.  The object, if any, will reside on the\n partition \u003ca name\u003d\"partName\"\u003enamed\u003c/a\u003e by some ancestor of the absolute\n form of this pathname.\n\n \u003cp\u003e A file system may implement restrictions to certain operations on the\n actual file-system object, such as reading, writing, and executing.  These\n restrictions are collectively known as \u003ci\u003eaccess permissions\u003c/i\u003e.  The file\n system may have multiple sets of access permissions on a single object.\n For example, one set may apply to the object\u0027s \u003ci\u003eowner\u003c/i\u003e, and another\n may apply to all other users.  The access permissions on an object may\n cause some methods in this class to fail.\n\n \u003cp\u003e Instances of the \u003ccode\u003eFile\u003c/code\u003e class are immutable; that is, once\n created, the abstract pathname represented by a \u003ccode\u003eFile\u003c/code\u003e object\n will never change.\n\n \u003ch3\u003eInteroperability with {@code java.nio.file} package\u003c/h3\u003e\n\n \u003cp\u003e The \u003ca href\u003d\"../../java/nio/file/package-summary.html\"\u003e{@code java.nio.file}\u003c/a\u003e\n package defines interfaces and classes for the Java virtual machine to access\n files, file attributes, and file systems. This API may be used to overcome\n many of the limitations of the {@code java.io.File} class.\n The {@link #toPath toPath} method may be used to obtain a {@link\n Path} that uses the abstract path represented by a {@code File} object to\n locate a file. The resulting {@code Path} may be used with the {@link\n java.nio.file.Files} class to provide more efficient and extensive access to\n additional file operations, file attributes, and I/O exceptions to help\n diagnose errors when an operation on a file fails.","isClass":true,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":false,"isOrdinaryClass":true,"isPrimitive":false,"simpleName":"File","qualifiedName":"java.io.File","dimension":"","elementType":{},"package":"java.io","superclass":"java.lang.Object","interfaces":["java.io.Serializable","java.lang.Comparable"],"isAbstract":false,"isStatic":false,"since":"JDK1.0","innerClasses":[],"isInnerClass":false,"constructors":[{"name":"File","comment":"Creates a new \u003ccode\u003eFile\u003c/code\u003e instance by converting the given\n pathname string into an abstract pathname.  If the given string is\n the empty string, then the result is the empty abstract pathname.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":true,"isField":false,"isMethod":false,"isOrdinaryClass":false,"signature":"(java.lang.String)","flatSignature":"(String)","parameters":[{"name":"pathname","type":{"isPrimitive":false,"simpleName":"String","qualifiedName":"java.lang.String","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"File","comment":"Creates a new \u003ccode\u003eFile\u003c/code\u003e instance from a parent pathname string\n and a child pathname string.\n\n \u003cp\u003e If \u003ccode\u003eparent\u003c/code\u003e is \u003ccode\u003enull\u003c/code\u003e then the new\n \u003ccode\u003eFile\u003c/code\u003e instance is created as if by invoking the\n single-argument \u003ccode\u003eFile\u003c/code\u003e constructor on the given\n \u003ccode\u003echild\u003c/code\u003e pathname string.\n\n \u003cp\u003e Otherwise the \u003ccode\u003eparent\u003c/code\u003e pathname string is taken to denote\n a directory, and the \u003ccode\u003echild\u003c/code\u003e pathname string is taken to\n denote either a directory or a file.  If the \u003ccode\u003echild\u003c/code\u003e pathname\n string is absolute then it is converted into a relative pathname in a\n system-dependent way.  If \u003ccode\u003eparent\u003c/code\u003e is the empty string then\n the new \u003ccode\u003eFile\u003c/code\u003e instance is created by converting\n \u003ccode\u003echild\u003c/code\u003e into an abstract pathname and resolving the result\n against a system-dependent default directory.  Otherwise each pathname\n string is converted into an abstract pathname and the child abstract\n pathname is resolved against the parent.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":true,"isField":false,"isMethod":false,"isOrdinaryClass":false,"signature":"(java.lang.String, java.lang.String)","flatSignature":"(String, String)","parameters":[{"name":"parent","type":{"isPrimitive":false,"simpleName":"String","qualifiedName":"java.lang.String","dimension":"","elementType":{}}},{"name":"child","type":{"isPrimitive":false,"simpleName":"String","qualifiedName":"java.lang.String","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"File","comment":"Creates a new \u003ccode\u003eFile\u003c/code\u003e instance from a parent abstract\n pathname and a child pathname string.\n\n \u003cp\u003e If \u003ccode\u003eparent\u003c/code\u003e is \u003ccode\u003enull\u003c/code\u003e then the new\n \u003ccode\u003eFile\u003c/code\u003e instance is created as if by invoking the\n single-argument \u003ccode\u003eFile\u003c/code\u003e constructor on the given\n \u003ccode\u003echild\u003c/code\u003e pathname string.\n\n \u003cp\u003e Otherwise the \u003ccode\u003eparent\u003c/code\u003e abstract pathname is taken to\n denote a directory, and the \u003ccode\u003echild\u003c/code\u003e pathname string is taken\n to denote either a directory or a file.  If the \u003ccode\u003echild\u003c/code\u003e\n pathname string is absolute then it is converted into a relative\n pathname in a system-dependent way.  If \u003ccode\u003eparent\u003c/code\u003e is the empty\n abstract pathname then the new \u003ccode\u003eFile\u003c/code\u003e instance is created by\n converting \u003ccode\u003echild\u003c/code\u003e into an abstract pathname and resolving\n the result against a system-dependent default directory.  Otherwise each\n pathname string is converted into an abstract pathname and the child\n abstract pathname is resolved against the parent.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":true,"isField":false,"isMethod":false,"isOrdinaryClass":false,"signature":"(java.io.File, java.lang.String)","flatSignature":"(File, String)","parameters":[{"name":"parent","type":{"isPrimitive":false,"simpleName":"File","qualifiedName":"java.io.File","dimension":"","elementType":{}}},{"name":"child","type":{"isPrimitive":false,"simpleName":"String","qualifiedName":"java.lang.String","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"File","comment":"Creates a new \u003ctt\u003eFile\u003c/tt\u003e instance by converting the given\n \u003ctt\u003efile:\u003c/tt\u003e URI into an abstract pathname.\n\n \u003cp\u003e The exact form of a \u003ctt\u003efile:\u003c/tt\u003e URI is system-dependent, hence\n the transformation performed by this constructor is also\n system-dependent.\n\n \u003cp\u003e For a given abstract pathname \u003ci\u003ef\u003c/i\u003e it is guaranteed that\n\n \u003cblockquote\u003e\u003ctt\u003e\n new File(\u003c/tt\u003e\u003ci\u003e\u0026nbsp;f\u003c/i\u003e\u003ctt\u003e.{@link #toURI() toURI}()).equals(\u003c/tt\u003e\u003ci\u003e\u0026nbsp;f\u003c/i\u003e\u003ctt\u003e.{@link #getAbsoluteFile() getAbsoluteFile}())\n \u003c/tt\u003e\u003c/blockquote\u003e\n\n so long as the original abstract pathname, the URI, and the new abstract\n pathname are all created in (possibly different invocations of) the same\n Java virtual machine.  This relationship typically does not hold,\n however, when a \u003ctt\u003efile:\u003c/tt\u003e URI that is created in a virtual machine\n on one operating system is converted into an abstract pathname in a\n virtual machine on a different operating system.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":true,"isField":false,"isMethod":false,"isOrdinaryClass":false,"signature":"(java.net.URI)","flatSignature":"(URI)","parameters":[{"name":"uri","type":{"isPrimitive":false,"simpleName":"URI","qualifiedName":"java.net.URI","dimension":"","elementType":{}}}],"typeParameters":[]}],"fields":[{"name":"separatorChar","comment":"The system-dependent default name-separator character.  This field is\n initialized to contain the first character of the value of the system\n property \u003ccode\u003efile.separator\u003c/code\u003e.  On UNIX systems the value of this\n field is \u003ccode\u003e\u0027/\u0027\u003c/code\u003e; on Microsoft Windows systems it is \u003ccode\u003e\u0027\\\\\u0027\u003c/code\u003e.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":true,"isMethod":false,"isOrdinaryClass":false,"type":{"isPrimitive":true,"simpleName":"char","qualifiedName":"char","dimension":"","elementType":{}},"isStatic":true},{"name":"separator","comment":"The system-dependent default name-separator character, represented as a\n string for convenience.  This string contains a single character, namely\n \u003ccode\u003e{@link #separatorChar}\u003c/code\u003e.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":true,"isMethod":false,"isOrdinaryClass":false,"type":{"isPrimitive":false,"simpleName":"String","qualifiedName":"java.lang.String","dimension":"","elementType":{}},"isStatic":true},{"name":"pathSeparatorChar","comment":"The system-dependent path-separator character.  This field is\n initialized to contain the first character of the value of the system\n property \u003ccode\u003epath.separator\u003c/code\u003e.  This character is used to\n separate filenames in a sequence of files given as a \u003cem\u003epath list\u003c/em\u003e.\n On UNIX systems, this character is \u003ccode\u003e\u0027:\u0027\u003c/code\u003e; on Microsoft Windows systems it\n is \u003ccode\u003e\u0027;\u0027\u003c/code\u003e.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":true,"isMethod":false,"isOrdinaryClass":false,"type":{"isPrimitive":true,"simpleName":"char","qualifiedName":"char","dimension":"","elementType":{}},"isStatic":true},{"name":"pathSeparator","comment":"The system-dependent path-separator character, represented as a string\n for convenience.  This string contains a single character, namely\n \u003ccode\u003e{@link #pathSeparatorChar}\u003c/code\u003e.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":true,"isMethod":false,"isOrdinaryClass":false,"type":{"isPrimitive":false,"simpleName":"String","qualifiedName":"java.lang.String","dimension":"","elementType":{}},"isStatic":true}],"methods":[{"name":"getName","comment":"Returns the name of the file or directory denoted by this abstract\n pathname.  This is just the last name in the pathname\u0027s name\n sequence.  If the pathname\u0027s name sequence is empty, then the empty\n string is returned.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":false,"simpleName":"String","qualifiedName":"java.lang.String","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[],"typeParameters":[]},{"name":"getParent","comment":"Returns the pathname string of this abstract pathname\u0027s parent, or\n \u003ccode\u003enull\u003c/code\u003e if this pathname does not name a parent directory.\n\n \u003cp\u003e The \u003cem\u003eparent\u003c/em\u003e of an abstract pathname consists of the\n pathname\u0027s prefix, if any, and each name in the pathname\u0027s name\n sequence except for the last.  If the name sequence is empty then\n the pathname does not name a parent directory.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":false,"simpleName":"String","qualifiedName":"java.lang.String","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[],"typeParameters":[]},{"name":"getParentFile","comment":"Returns the abstract pathname of this abstract pathname\u0027s parent,\n or \u003ccode\u003enull\u003c/code\u003e if this pathname does not name a parent\n directory.\n\n \u003cp\u003e The \u003cem\u003eparent\u003c/em\u003e of an abstract pathname consists of the\n pathname\u0027s prefix, if any, and each name in the pathname\u0027s name\n sequence except for the last.  If the name sequence is empty then\n the pathname does not name a parent directory.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":false,"simpleName":"File","qualifiedName":"java.io.File","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[],"typeParameters":[]},{"name":"getPath","comment":"Converts this abstract pathname into a pathname string.  The resulting\n string uses the {@link #separator default name-separator character} to\n separate the names in the name sequence.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":false,"simpleName":"String","qualifiedName":"java.lang.String","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[],"typeParameters":[]},{"name":"isAbsolute","comment":"Tests whether this abstract pathname is absolute.  The definition of\n absolute pathname is system dependent.  On UNIX systems, a pathname is\n absolute if its prefix is \u003ccode\u003e\"/\"\u003c/code\u003e.  On Microsoft Windows systems, a\n pathname is absolute if its prefix is a drive specifier followed by\n \u003ccode\u003e\"\\\\\"\u003c/code\u003e, or if its prefix is \u003ccode\u003e\"\\\\\\\\\"\u003c/code\u003e.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":true,"simpleName":"boolean","qualifiedName":"boolean","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[],"typeParameters":[]},{"name":"getAbsolutePath","comment":"Returns the absolute pathname string of this abstract pathname.\n\n \u003cp\u003e If this abstract pathname is already absolute, then the pathname\n string is simply returned as if by the \u003ccode\u003e{@link #getPath}\u003c/code\u003e\n method.  If this abstract pathname is the empty abstract pathname then\n the pathname string of the current user directory, which is named by the\n system property \u003ccode\u003euser.dir\u003c/code\u003e, is returned.  Otherwise this\n pathname is resolved in a system-dependent way.  On UNIX systems, a\n relative pathname is made absolute by resolving it against the current\n user directory.  On Microsoft Windows systems, a relative pathname is made absolute\n by resolving it against the current directory of the drive named by the\n pathname, if any; if not, it is resolved against the current user\n directory.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":false,"simpleName":"String","qualifiedName":"java.lang.String","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[],"typeParameters":[]},{"name":"getAbsoluteFile","comment":"Returns the absolute form of this abstract pathname.  Equivalent to\n \u003ccode\u003enew\u0026nbsp;File(this.{@link #getAbsolutePath})\u003c/code\u003e.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":false,"simpleName":"File","qualifiedName":"java.io.File","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[],"typeParameters":[]},{"name":"getCanonicalPath","comment":"Returns the canonical pathname string of this abstract pathname.\n\n \u003cp\u003e A canonical pathname is both absolute and unique.  The precise\n definition of canonical form is system-dependent.  This method first\n converts this pathname to absolute form if necessary, as if by invoking the\n {@link #getAbsolutePath} method, and then maps it to its unique form in a\n system-dependent way.  This typically involves removing redundant names\n such as \u003ctt\u003e\".\"\u003c/tt\u003e and \u003ctt\u003e\"..\"\u003c/tt\u003e from the pathname, resolving\n symbolic links (on UNIX platforms), and converting drive letters to a\n standard case (on Microsoft Windows platforms).\n\n \u003cp\u003e Every pathname that denotes an existing file or directory has a\n unique canonical form.  Every pathname that denotes a nonexistent file\n or directory also has a unique canonical form.  The canonical form of\n the pathname of a nonexistent file or directory may be different from\n the canonical form of the same pathname after the file or directory is\n created.  Similarly, the canonical form of the pathname of an existing\n file or directory may be different from the canonical form of the same\n pathname after the file or directory is deleted.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":false,"simpleName":"String","qualifiedName":"java.lang.String","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[],"typeParameters":[]},{"name":"getCanonicalFile","comment":"Returns the canonical form of this abstract pathname.  Equivalent to\n \u003ccode\u003enew\u0026nbsp;File(this.{@link #getCanonicalPath})\u003c/code\u003e.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":false,"simpleName":"File","qualifiedName":"java.io.File","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[],"typeParameters":[]},{"name":"toURL","comment":"Converts this abstract pathname into a \u003ccode\u003efile:\u003c/code\u003e URL.  The\n exact form of the URL is system-dependent.  If it can be determined that\n the file denoted by this abstract pathname is a directory, then the\n resulting URL will end with a slash.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":false,"simpleName":"URL","qualifiedName":"java.net.URL","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[],"typeParameters":[]},{"name":"toURI","comment":"Constructs a \u003ctt\u003efile:\u003c/tt\u003e URI that represents this abstract pathname.\n\n \u003cp\u003e The exact form of the URI is system-dependent.  If it can be\n determined that the file denoted by this abstract pathname is a\n directory, then the resulting URI will end with a slash.\n\n \u003cp\u003e For a given abstract pathname \u003ci\u003ef\u003c/i\u003e, it is guaranteed that\n\n \u003cblockquote\u003e\u003ctt\u003e\n new {@link #File(java.net.URI) File}(\u003c/tt\u003e\u003ci\u003e\u0026nbsp;f\u003c/i\u003e\u003ctt\u003e.toURI()).equals(\u003c/tt\u003e\u003ci\u003e\u0026nbsp;f\u003c/i\u003e\u003ctt\u003e.{@link #getAbsoluteFile() getAbsoluteFile}())\n \u003c/tt\u003e\u003c/blockquote\u003e\n\n so long as the original abstract pathname, the URI, and the new abstract\n pathname are all created in (possibly different invocations of) the same\n Java virtual machine.  Due to the system-dependent nature of abstract\n pathnames, however, this relationship typically does not hold when a\n \u003ctt\u003efile:\u003c/tt\u003e URI that is created in a virtual machine on one operating\n system is converted into an abstract pathname in a virtual machine on a\n different operating system.\n\n \u003cp\u003e Note that when this abstract pathname represents a UNC pathname then\n all components of the UNC (including the server name component) are encoded\n in the {@code URI} path. The authority component is undefined, meaning\n that it is represented as {@code null}. The {@link Path} class defines the\n {@link Path#toUri toUri} method to encode the server name in the authority\n component of the resulting {@code URI}. The {@link #toPath toPath} method\n may be used to obtain a {@code Path} representing this abstract pathname.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":false,"simpleName":"URI","qualifiedName":"java.net.URI","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[],"typeParameters":[]},{"name":"canRead","comment":"Tests whether the application can read the file denoted by this\n abstract pathname. On some platforms it may be possible to start the\n Java virtual machine with special privileges that allow it to read\n files that are marked as unreadable. Consequently this method may return\n {@code true} even though the file does not have read permissions.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":true,"simpleName":"boolean","qualifiedName":"boolean","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[],"typeParameters":[]},{"name":"canWrite","comment":"Tests whether the application can modify the file denoted by this\n abstract pathname. On some platforms it may be possible to start the\n Java virtual machine with special privileges that allow it to modify\n files that are marked read-only. Consequently this method may return\n {@code true} even though the file is marked read-only.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":true,"simpleName":"boolean","qualifiedName":"boolean","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[],"typeParameters":[]},{"name":"exists","comment":"Tests whether the file or directory denoted by this abstract pathname\n exists.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":true,"simpleName":"boolean","qualifiedName":"boolean","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[],"typeParameters":[]},{"name":"isDirectory","comment":"Tests whether the file denoted by this abstract pathname is a\n directory.\n\n \u003cp\u003e Where it is required to distinguish an I/O exception from the case\n that the file is not a directory, or where several attributes of the\n same file are required at the same time, then the {@link\n java.nio.file.Files#readAttributes(Path,Class,LinkOption[])\n Files.readAttributes} method may be used.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":true,"simpleName":"boolean","qualifiedName":"boolean","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[],"typeParameters":[]},{"name":"isFile","comment":"Tests whether the file denoted by this abstract pathname is a normal\n file.  A file is \u003cem\u003enormal\u003c/em\u003e if it is not a directory and, in\n addition, satisfies other system-dependent criteria.  Any non-directory\n file created by a Java application is guaranteed to be a normal file.\n\n \u003cp\u003e Where it is required to distinguish an I/O exception from the case\n that the file is not a normal file, or where several attributes of the\n same file are required at the same time, then the {@link\n java.nio.file.Files#readAttributes(Path,Class,LinkOption[])\n Files.readAttributes} method may be used.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":true,"simpleName":"boolean","qualifiedName":"boolean","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[],"typeParameters":[]},{"name":"isHidden","comment":"Tests whether the file named by this abstract pathname is a hidden\n file.  The exact definition of \u003cem\u003ehidden\u003c/em\u003e is system-dependent.  On\n UNIX systems, a file is considered to be hidden if its name begins with\n a period character (\u003ccode\u003e\u0027.\u0027\u003c/code\u003e).  On Microsoft Windows systems, a file is\n considered to be hidden if it has been marked as such in the filesystem.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":true,"simpleName":"boolean","qualifiedName":"boolean","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[],"typeParameters":[]},{"name":"lastModified","comment":"Returns the time that the file denoted by this abstract pathname was\n last modified.\n\n \u003cp\u003e Where it is required to distinguish an I/O exception from the case\n where {@code 0L} is returned, or where several attributes of the\n same file are required at the same time, or where the time of last\n access or the creation time are required, then the {@link\n java.nio.file.Files#readAttributes(Path,Class,LinkOption[])\n Files.readAttributes} method may be used.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":true,"simpleName":"long","qualifiedName":"long","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[],"typeParameters":[]},{"name":"length","comment":"Returns the length of the file denoted by this abstract pathname.\n The return value is unspecified if this pathname denotes a directory.\n\n \u003cp\u003e Where it is required to distinguish an I/O exception from the case\n that {@code 0L} is returned, or where several attributes of the same file\n are required at the same time, then the {@link\n java.nio.file.Files#readAttributes(Path,Class,LinkOption[])\n Files.readAttributes} method may be used.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":true,"simpleName":"long","qualifiedName":"long","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[],"typeParameters":[]},{"name":"createNewFile","comment":"Atomically creates a new, empty file named by this abstract pathname if\n and only if a file with this name does not yet exist.  The check for the\n existence of the file and the creation of the file if it does not exist\n are a single operation that is atomic with respect to all other\n filesystem activities that might affect the file.\n \u003cP\u003e\n Note: this method should \u003ci\u003enot\u003c/i\u003e be used for file-locking, as\n the resulting protocol cannot be made to work reliably. The\n {@link java.nio.channels.FileLock FileLock}\n facility should be used instead.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":true,"simpleName":"boolean","qualifiedName":"boolean","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[],"typeParameters":[]},{"name":"delete","comment":"Deletes the file or directory denoted by this abstract pathname.  If\n this pathname denotes a directory, then the directory must be empty in\n order to be deleted.\n\n \u003cp\u003e Note that the {@link java.nio.file.Files} class defines the {@link\n java.nio.file.Files#delete(Path) delete} method to throw an {@link IOException}\n when a file cannot be deleted. This is useful for error reporting and to\n diagnose why a file cannot be deleted.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":true,"simpleName":"boolean","qualifiedName":"boolean","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[],"typeParameters":[]},{"name":"deleteOnExit","comment":"Requests that the file or directory denoted by this abstract\n pathname be deleted when the virtual machine terminates.\n Files (or directories) are deleted in the reverse order that\n they are registered. Invoking this method to delete a file or\n directory that is already registered for deletion has no effect.\n Deletion will be attempted only for normal termination of the\n virtual machine, as defined by the Java Language Specification.\n\n \u003cp\u003e Once deletion has been requested, it is not possible to cancel the\n request.  This method should therefore be used with care.\n\n \u003cP\u003e\n Note: this method should \u003ci\u003enot\u003c/i\u003e be used for file-locking, as\n the resulting protocol cannot be made to work reliably. The\n {@link java.nio.channels.FileLock FileLock}\n facility should be used instead.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":true,"simpleName":"void","qualifiedName":"void","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[],"typeParameters":[]},{"name":"list","comment":"Returns an array of strings naming the files and directories in the\n directory denoted by this abstract pathname.\n\n \u003cp\u003e If this abstract pathname does not denote a directory, then this\n method returns {@code null}.  Otherwise an array of strings is\n returned, one for each file or directory in the directory.  Names\n denoting the directory itself and the directory\u0027s parent directory are\n not included in the result.  Each string is a file name rather than a\n complete path.\n\n \u003cp\u003e There is no guarantee that the name strings in the resulting array\n will appear in any specific order; they are not, in particular,\n guaranteed to appear in alphabetical order.\n\n \u003cp\u003e Note that the {@link java.nio.file.Files} class defines the {@link\n java.nio.file.Files#newDirectoryStream(Path) newDirectoryStream} method to\n open a directory and iterate over the names of the files in the directory.\n This may use less resources when working with very large directories, and\n may be more responsive when working with remote directories.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":false,"simpleName":"String","qualifiedName":"java.lang.String","dimension":"[]","elementType":{"isPrimitive":false,"simpleName":"String","qualifiedName":"java.lang.String","dimension":"","elementType":{}}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[],"typeParameters":[]},{"name":"list","comment":"Returns an array of strings naming the files and directories in the\n directory denoted by this abstract pathname that satisfy the specified\n filter.  The behavior of this method is the same as that of the\n {@link #list()} method, except that the strings in the returned array\n must satisfy the filter.  If the given {@code filter} is {@code null}\n then all names are accepted.  Otherwise, a name satisfies the filter if\n and only if the value {@code true} results when the {@link\n FilenameFilter#accept FilenameFilter.accept(File,\u0026nbsp;String)} method\n of the filter is invoked on this abstract pathname and the name of a\n file or directory in the directory that it denotes.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.io.FilenameFilter)","flatSignature":"(FilenameFilter)","returnType":{"isPrimitive":false,"simpleName":"String","qualifiedName":"java.lang.String","dimension":"[]","elementType":{"isPrimitive":false,"simpleName":"String","qualifiedName":"java.lang.String","dimension":"","elementType":{}}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[{"name":"filter","type":{"isPrimitive":false,"simpleName":"FilenameFilter","qualifiedName":"java.io.FilenameFilter","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"listFiles","comment":"Returns an array of abstract pathnames denoting the files in the\n directory denoted by this abstract pathname.\n\n \u003cp\u003e If this abstract pathname does not denote a directory, then this\n method returns {@code null}.  Otherwise an array of {@code File} objects\n is returned, one for each file or directory in the directory.  Pathnames\n denoting the directory itself and the directory\u0027s parent directory are\n not included in the result.  Each resulting abstract pathname is\n constructed from this abstract pathname using the {@link #File(File,\n String) File(File,\u0026nbsp;String)} constructor.  Therefore if this\n pathname is absolute then each resulting pathname is absolute; if this\n pathname is relative then each resulting pathname will be relative to\n the same directory.\n\n \u003cp\u003e There is no guarantee that the name strings in the resulting array\n will appear in any specific order; they are not, in particular,\n guaranteed to appear in alphabetical order.\n\n \u003cp\u003e Note that the {@link java.nio.file.Files} class defines the {@link\n java.nio.file.Files#newDirectoryStream(Path) newDirectoryStream} method\n to open a directory and iterate over the names of the files in the\n directory. This may use less resources when working with very large\n directories.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":false,"simpleName":"File","qualifiedName":"java.io.File","dimension":"[]","elementType":{"isPrimitive":false,"simpleName":"File","qualifiedName":"java.io.File","dimension":"","elementType":{}}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[],"typeParameters":[]},{"name":"listFiles","comment":"Returns an array of abstract pathnames denoting the files and\n directories in the directory denoted by this abstract pathname that\n satisfy the specified filter.  The behavior of this method is the same\n as that of the {@link #listFiles()} method, except that the pathnames in\n the returned array must satisfy the filter.  If the given {@code filter}\n is {@code null} then all pathnames are accepted.  Otherwise, a pathname\n satisfies the filter if and only if the value {@code true} results when\n the {@link FilenameFilter#accept\n FilenameFilter.accept(File,\u0026nbsp;String)} method of the filter is\n invoked on this abstract pathname and the name of a file or directory in\n the directory that it denotes.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.io.FilenameFilter)","flatSignature":"(FilenameFilter)","returnType":{"isPrimitive":false,"simpleName":"File","qualifiedName":"java.io.File","dimension":"[]","elementType":{"isPrimitive":false,"simpleName":"File","qualifiedName":"java.io.File","dimension":"","elementType":{}}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[{"name":"filter","type":{"isPrimitive":false,"simpleName":"FilenameFilter","qualifiedName":"java.io.FilenameFilter","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"listFiles","comment":"Returns an array of abstract pathnames denoting the files and\n directories in the directory denoted by this abstract pathname that\n satisfy the specified filter.  The behavior of this method is the same\n as that of the {@link #listFiles()} method, except that the pathnames in\n the returned array must satisfy the filter.  If the given {@code filter}\n is {@code null} then all pathnames are accepted.  Otherwise, a pathname\n satisfies the filter if and only if the value {@code true} results when\n the {@link FileFilter#accept FileFilter.accept(File)} method of the\n filter is invoked on the pathname.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.io.FileFilter)","flatSignature":"(FileFilter)","returnType":{"isPrimitive":false,"simpleName":"File","qualifiedName":"java.io.File","dimension":"[]","elementType":{"isPrimitive":false,"simpleName":"File","qualifiedName":"java.io.File","dimension":"","elementType":{}}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[{"name":"filter","type":{"isPrimitive":false,"simpleName":"FileFilter","qualifiedName":"java.io.FileFilter","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"mkdir","comment":"Creates the directory named by this abstract pathname.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":true,"simpleName":"boolean","qualifiedName":"boolean","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[],"typeParameters":[]},{"name":"mkdirs","comment":"Creates the directory named by this abstract pathname, including any\n necessary but nonexistent parent directories.  Note that if this\n operation fails it may have succeeded in creating some of the necessary\n parent directories.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":true,"simpleName":"boolean","qualifiedName":"boolean","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[],"typeParameters":[]},{"name":"renameTo","comment":"Renames the file denoted by this abstract pathname.\n\n \u003cp\u003e Many aspects of the behavior of this method are inherently\n platform-dependent: The rename operation might not be able to move a\n file from one filesystem to another, it might not be atomic, and it\n might not succeed if a file with the destination abstract pathname\n already exists.  The return value should always be checked to make sure\n that the rename operation was successful.\n\n \u003cp\u003e Note that the {@link java.nio.file.Files} class defines the {@link\n java.nio.file.Files#move move} method to move or rename a file in a\n platform independent manner.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.io.File)","flatSignature":"(File)","returnType":{"isPrimitive":true,"simpleName":"boolean","qualifiedName":"boolean","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[{"name":"dest","type":{"isPrimitive":false,"simpleName":"File","qualifiedName":"java.io.File","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"setLastModified","comment":"Sets the last-modified time of the file or directory named by this\n abstract pathname.\n\n \u003cp\u003e All platforms support file-modification times to the nearest second,\n but some provide more precision.  The argument will be truncated to fit\n the supported precision.  If the operation succeeds and no intervening\n operations on the file take place, then the next invocation of the\n \u003ccode\u003e{@link #lastModified}\u003c/code\u003e method will return the (possibly\n truncated) \u003ccode\u003etime\u003c/code\u003e argument that was passed to this method.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(long)","flatSignature":"(long)","returnType":{"isPrimitive":true,"simpleName":"boolean","qualifiedName":"boolean","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[{"name":"time","type":{"isPrimitive":true,"simpleName":"long","qualifiedName":"long","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"setReadOnly","comment":"Marks the file or directory named by this abstract pathname so that\n only read operations are allowed. After invoking this method the file\n or directory will not change until it is either deleted or marked\n to allow write access. On some platforms it may be possible to start the\n Java virtual machine with special privileges that allow it to modify\n files that are marked read-only. Whether or not a read-only file or\n directory may be deleted depends upon the underlying system.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":true,"simpleName":"boolean","qualifiedName":"boolean","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[],"typeParameters":[]},{"name":"setWritable","comment":"Sets the owner\u0027s or everybody\u0027s write permission for this abstract\n pathname. On some platforms it may be possible to start the Java virtual\n machine with special privileges that allow it to modify files that\n disallow write operations.\n\n \u003cp\u003e The {@link java.nio.file.Files} class defines methods that operate on\n file attributes including file permissions. This may be used when finer\n manipulation of file permissions is required.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(boolean, boolean)","flatSignature":"(boolean, boolean)","returnType":{"isPrimitive":true,"simpleName":"boolean","qualifiedName":"boolean","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[{"name":"writable","type":{"isPrimitive":true,"simpleName":"boolean","qualifiedName":"boolean","dimension":"","elementType":{}}},{"name":"ownerOnly","type":{"isPrimitive":true,"simpleName":"boolean","qualifiedName":"boolean","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"setWritable","comment":"A convenience method to set the owner\u0027s write permission for this abstract\n pathname. On some platforms it may be possible to start the Java virtual\n machine with special privileges that allow it to modify files that\n disallow write operations.\n\n \u003cp\u003e An invocation of this method of the form \u003ctt\u003efile.setWritable(arg)\u003c/tt\u003e\n behaves in exactly the same way as the invocation\n\n \u003cpre\u003e\n     file.setWritable(arg, true) \u003c/pre\u003e","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(boolean)","flatSignature":"(boolean)","returnType":{"isPrimitive":true,"simpleName":"boolean","qualifiedName":"boolean","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[{"name":"writable","type":{"isPrimitive":true,"simpleName":"boolean","qualifiedName":"boolean","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"setReadable","comment":"Sets the owner\u0027s or everybody\u0027s read permission for this abstract\n pathname. On some platforms it may be possible to start the Java virtual\n machine with special privileges that allow it to read files that are\n marked as unreadable.\n\n \u003cp\u003e The {@link java.nio.file.Files} class defines methods that operate on\n file attributes including file permissions. This may be used when finer\n manipulation of file permissions is required.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(boolean, boolean)","flatSignature":"(boolean, boolean)","returnType":{"isPrimitive":true,"simpleName":"boolean","qualifiedName":"boolean","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[{"name":"readable","type":{"isPrimitive":true,"simpleName":"boolean","qualifiedName":"boolean","dimension":"","elementType":{}}},{"name":"ownerOnly","type":{"isPrimitive":true,"simpleName":"boolean","qualifiedName":"boolean","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"setReadable","comment":"A convenience method to set the owner\u0027s read permission for this abstract\n pathname. On some platforms it may be possible to start the Java virtual\n machine with special privileges that allow it to read files that that are\n marked as unreadable.\n\n \u003cp\u003eAn invocation of this method of the form \u003ctt\u003efile.setReadable(arg)\u003c/tt\u003e\n behaves in exactly the same way as the invocation\n\n \u003cpre\u003e\n     file.setReadable(arg, true) \u003c/pre\u003e","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(boolean)","flatSignature":"(boolean)","returnType":{"isPrimitive":true,"simpleName":"boolean","qualifiedName":"boolean","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[{"name":"readable","type":{"isPrimitive":true,"simpleName":"boolean","qualifiedName":"boolean","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"setExecutable","comment":"Sets the owner\u0027s or everybody\u0027s execute permission for this abstract\n pathname. On some platforms it may be possible to start the Java virtual\n machine with special privileges that allow it to execute files that are\n not marked executable.\n\n \u003cp\u003e The {@link java.nio.file.Files} class defines methods that operate on\n file attributes including file permissions. This may be used when finer\n manipulation of file permissions is required.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(boolean, boolean)","flatSignature":"(boolean, boolean)","returnType":{"isPrimitive":true,"simpleName":"boolean","qualifiedName":"boolean","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[{"name":"executable","type":{"isPrimitive":true,"simpleName":"boolean","qualifiedName":"boolean","dimension":"","elementType":{}}},{"name":"ownerOnly","type":{"isPrimitive":true,"simpleName":"boolean","qualifiedName":"boolean","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"setExecutable","comment":"A convenience method to set the owner\u0027s execute permission for this\n abstract pathname. On some platforms it may be possible to start the Java\n virtual machine with special privileges that allow it to execute files\n that are not marked executable.\n\n \u003cp\u003eAn invocation of this method of the form \u003ctt\u003efile.setExcutable(arg)\u003c/tt\u003e\n behaves in exactly the same way as the invocation\n\n \u003cpre\u003e\n     file.setExecutable(arg, true) \u003c/pre\u003e","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(boolean)","flatSignature":"(boolean)","returnType":{"isPrimitive":true,"simpleName":"boolean","qualifiedName":"boolean","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[{"name":"executable","type":{"isPrimitive":true,"simpleName":"boolean","qualifiedName":"boolean","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"canExecute","comment":"Tests whether the application can execute the file denoted by this\n abstract pathname. On some platforms it may be possible to start the\n Java virtual machine with special privileges that allow it to execute\n files that are not marked executable. Consequently this method may return\n {@code true} even though the file does not have execute permissions.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":true,"simpleName":"boolean","qualifiedName":"boolean","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[],"typeParameters":[]},{"name":"listRoots","comment":"List the available filesystem roots.\n\n \u003cp\u003e A particular Java platform may support zero or more\n hierarchically-organized file systems.  Each file system has a\n {@code root} directory from which all other files in that file system\n can be reached.  Windows platforms, for example, have a root directory\n for each active drive; UNIX platforms have a single root directory,\n namely {@code \"/\"}.  The set of available filesystem roots is affected\n by various system-level operations such as the insertion or ejection of\n removable media and the disconnecting or unmounting of physical or\n virtual disk drives.\n\n \u003cp\u003e This method returns an array of {@code File} objects that denote the\n root directories of the available filesystem roots.  It is guaranteed\n that the canonical pathname of any file physically present on the local\n machine will begin with one of the roots returned by this method.\n\n \u003cp\u003e The canonical pathname of a file that resides on some other machine\n and is accessed via a remote-filesystem protocol such as SMB or NFS may\n or may not begin with one of the roots returned by this method.  If the\n pathname of a remote file is syntactically indistinguishable from the\n pathname of a local file then it will begin with one of the roots\n returned by this method.  Thus, for example, {@code File} objects\n denoting the root directories of the mapped network drives of a Windows\n platform will be returned by this method, while {@code File} objects\n containing UNC pathnames will not be returned by this method.\n\n \u003cp\u003e Unlike most methods in this class, this method does not throw\n security exceptions.  If a security manager exists and its {@link\n SecurityManager#checkRead(String)} method denies read access to a\n particular root directory, then that directory will not appear in the\n result.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":false,"simpleName":"File","qualifiedName":"java.io.File","dimension":"[]","elementType":{"isPrimitive":false,"simpleName":"File","qualifiedName":"java.io.File","dimension":"","elementType":{}}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[],"typeParameters":[]},{"name":"getTotalSpace","comment":"Returns the size of the partition \u003ca href\u003d\"#partName\"\u003enamed\u003c/a\u003e by this\n abstract pathname.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":true,"simpleName":"long","qualifiedName":"long","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[],"typeParameters":[]},{"name":"getFreeSpace","comment":"Returns the number of unallocated bytes in the partition \u003ca\n href\u003d\"#partName\"\u003enamed\u003c/a\u003e by this abstract path name.\n\n \u003cp\u003e The returned number of unallocated bytes is a hint, but not\n a guarantee, that it is possible to use most or any of these\n bytes.  The number of unallocated bytes is most likely to be\n accurate immediately after this call.  It is likely to be made\n inaccurate by any external I/O operations including those made\n on the system outside of this virtual machine.  This method\n makes no guarantee that write operations to this file system\n will succeed.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":true,"simpleName":"long","qualifiedName":"long","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[],"typeParameters":[]},{"name":"getUsableSpace","comment":"Returns the number of bytes available to this virtual machine on the\n partition \u003ca href\u003d\"#partName\"\u003enamed\u003c/a\u003e by this abstract pathname.  When\n possible, this method checks for write permissions and other operating\n system restrictions and will therefore usually provide a more accurate\n estimate of how much new data can actually be written than {@link\n #getFreeSpace}.\n\n \u003cp\u003e The returned number of available bytes is a hint, but not a\n guarantee, that it is possible to use most or any of these bytes.  The\n number of unallocated bytes is most likely to be accurate immediately\n after this call.  It is likely to be made inaccurate by any external\n I/O operations including those made on the system outside of this\n virtual machine.  This method makes no guarantee that write operations\n to this file system will succeed.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":true,"simpleName":"long","qualifiedName":"long","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[],"typeParameters":[]},{"name":"createTempFile","comment":"\u003cp\u003e Creates a new empty file in the specified directory, using the\n given prefix and suffix strings to generate its name.  If this method\n returns successfully then it is guaranteed that:\n\n \u003col\u003e\n \u003cli\u003e The file denoted by the returned abstract pathname did not exist\n      before this method was invoked, and\n \u003cli\u003e Neither this method nor any of its variants will return the same\n      abstract pathname again in the current invocation of the virtual\n      machine.\n \u003c/ol\u003e\n\n This method provides only part of a temporary-file facility.  To arrange\n for a file created by this method to be deleted automatically, use the\n \u003ccode\u003e{@link #deleteOnExit}\u003c/code\u003e method.\n\n \u003cp\u003e The \u003ccode\u003eprefix\u003c/code\u003e argument must be at least three characters\n long.  It is recommended that the prefix be a short, meaningful string\n such as \u003ccode\u003e\"hjb\"\u003c/code\u003e or \u003ccode\u003e\"mail\"\u003c/code\u003e.  The\n \u003ccode\u003esuffix\u003c/code\u003e argument may be \u003ccode\u003enull\u003c/code\u003e, in which case the\n suffix \u003ccode\u003e\".tmp\"\u003c/code\u003e will be used.\n\n \u003cp\u003e To create the new file, the prefix and the suffix may first be\n adjusted to fit the limitations of the underlying platform.  If the\n prefix is too long then it will be truncated, but its first three\n characters will always be preserved.  If the suffix is too long then it\n too will be truncated, but if it begins with a period character\n (\u003ccode\u003e\u0027.\u0027\u003c/code\u003e) then the period and the first three characters\n following it will always be preserved.  Once these adjustments have been\n made the name of the new file will be generated by concatenating the\n prefix, five or more internally-generated characters, and the suffix.\n\n \u003cp\u003e If the \u003ccode\u003edirectory\u003c/code\u003e argument is \u003ccode\u003enull\u003c/code\u003e then the\n system-dependent default temporary-file directory will be used.  The\n default temporary-file directory is specified by the system property\n \u003ccode\u003ejava.io.tmpdir\u003c/code\u003e.  On UNIX systems the default value of this\n property is typically \u003ccode\u003e\"/tmp\"\u003c/code\u003e or \u003ccode\u003e\"/var/tmp\"\u003c/code\u003e; on\n Microsoft Windows systems it is typically \u003ccode\u003e\"C:\\\\WINNT\\\\TEMP\"\u003c/code\u003e.  A different\n value may be given to this system property when the Java virtual machine\n is invoked, but programmatic changes to this property are not guaranteed\n to have any effect upon the temporary directory used by this method.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.lang.String, java.lang.String, java.io.File)","flatSignature":"(String, String, File)","returnType":{"isPrimitive":false,"simpleName":"File","qualifiedName":"java.io.File","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"prefix","type":{"isPrimitive":false,"simpleName":"String","qualifiedName":"java.lang.String","dimension":"","elementType":{}}},{"name":"suffix","type":{"isPrimitive":false,"simpleName":"String","qualifiedName":"java.lang.String","dimension":"","elementType":{}}},{"name":"directory","type":{"isPrimitive":false,"simpleName":"File","qualifiedName":"java.io.File","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"createTempFile","comment":"Creates an empty file in the default temporary-file directory, using\n the given prefix and suffix to generate its name. Invoking this method\n is equivalent to invoking \u003ccode\u003e{@link #createTempFile(java.lang.String,\n java.lang.String, java.io.File)\n createTempFile(prefix,\u0026nbsp;suffix,\u0026nbsp;null)}\u003c/code\u003e.\n\n \u003cp\u003e The {@link\n java.nio.file.Files#createTempFile(String,String,java.nio.file.attribute.FileAttribute[])\n Files.createTempFile} method provides an alternative method to create an\n empty file in the temporary-file directory. Files created by that method\n may have more restrictive access permissions to files created by this\n method and so may be more suited to security-sensitive applications.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.lang.String, java.lang.String)","flatSignature":"(String, String)","returnType":{"isPrimitive":false,"simpleName":"File","qualifiedName":"java.io.File","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[{"name":"prefix","type":{"isPrimitive":false,"simpleName":"String","qualifiedName":"java.lang.String","dimension":"","elementType":{}}},{"name":"suffix","type":{"isPrimitive":false,"simpleName":"String","qualifiedName":"java.lang.String","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"compareTo","comment":"Compares two abstract pathnames lexicographically.  The ordering\n defined by this method depends upon the underlying system.  On UNIX\n systems, alphabetic case is significant in comparing pathnames; on Microsoft Windows\n systems it is not.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.io.File)","flatSignature":"(File)","returnType":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[{"name":"pathname","type":{"isPrimitive":false,"simpleName":"File","qualifiedName":"java.io.File","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"equals","comment":"Tests this abstract pathname for equality with the given object.\n Returns \u003ccode\u003etrue\u003c/code\u003e if and only if the argument is not\n \u003ccode\u003enull\u003c/code\u003e and is an abstract pathname that denotes the same file\n or directory as this abstract pathname.  Whether or not two abstract\n pathnames are equal depends upon the underlying system.  On UNIX\n systems, alphabetic case is significant in comparing pathnames; on Microsoft Windows\n systems it is not.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"(java.lang.Object)","flatSignature":"(Object)","returnType":{"isPrimitive":true,"simpleName":"boolean","qualifiedName":"boolean","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[{"name":"obj","type":{"isPrimitive":false,"simpleName":"Object","qualifiedName":"java.lang.Object","dimension":"","elementType":{}}}],"typeParameters":[]},{"name":"hashCode","comment":"Computes a hash code for this abstract pathname.  Because equality of\n abstract pathnames is inherently system-dependent, so is the computation\n of their hash codes.  On UNIX systems, the hash code of an abstract\n pathname is equal to the exclusive \u003cem\u003eor\u003c/em\u003e of the hash code\n of its pathname string and the decimal value\n \u003ccode\u003e1234321\u003c/code\u003e.  On Microsoft Windows systems, the hash\n code is equal to the exclusive \u003cem\u003eor\u003c/em\u003e of the hash code of\n its pathname string converted to lower case and the decimal\n value \u003ccode\u003e1234321\u003c/code\u003e.  Locale is not taken into account on\n lowercasing the pathname string.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":true,"simpleName":"int","qualifiedName":"int","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[],"typeParameters":[]},{"name":"toString","comment":"Returns the pathname string of this abstract pathname.  This is just the\n string returned by the \u003ccode\u003e{@link #getPath}\u003c/code\u003e method.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":false,"simpleName":"String","qualifiedName":"java.lang.String","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[],"typeParameters":[]},{"name":"toPath","comment":"Returns a {@link Path java.nio.file.Path} object constructed from the\n this abstract path. The resulting {@code Path} is associated with the\n {@link java.nio.file.FileSystems#getDefault default-filesystem}.\n\n \u003cp\u003e The first invocation of this method works as if invoking it were\n equivalent to evaluating the expression:\n \u003cblockquote\u003e\u003cpre\u003e\n {@link java.nio.file.FileSystems#getDefault FileSystems.getDefault}().{@link\n java.nio.file.FileSystem#getPath getPath}(this.{@link #getPath getPath}());\n \u003c/pre\u003e\u003c/blockquote\u003e\n Subsequent invocations of this method return the same {@code Path}.\n\n \u003cp\u003e If this abstract pathname is the empty abstract pathname then this\n method returns a {@code Path} that may be used to access the current\n user directory.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":false,"simpleName":"Path","qualifiedName":"java.nio.file.Path","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":false,"parameters":[],"typeParameters":[]}],"typeParameters":[],"enumConstants":[]}