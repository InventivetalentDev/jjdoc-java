{"name":"TemporalQueries","comment":"Common implementations of {@code TemporalQuery}.\n \u003cp\u003e\n This class provides common implementations of {@link TemporalQuery}.\n These are defined here as they must be constants, and the definition\n of lambdas does not guarantee that. By assigning them once here,\n they become \u0027normal\u0027 Java constants.\n \u003cp\u003e\n Queries are a key tool for extracting information from temporal objects.\n They exist to externalize the process of querying, permitting different\n approaches, as per the strategy design pattern.\n Examples might be a query that checks if the date is the day before February 29th\n in a leap year, or calculates the number of days to your next birthday.\n \u003cp\u003e\n The {@link TemporalField} interface provides another mechanism for querying\n temporal objects. That interface is limited to returning a {@code long}.\n By contrast, queries can return any type.\n \u003cp\u003e\n There are two equivalent ways of using a {@code TemporalQuery}.\n The first is to invoke the method on this interface directly.\n The second is to use {@link TemporalAccessor#query(TemporalQuery)}:\n \u003cpre\u003e\n   // these two lines are equivalent, but the second approach is recommended\n   temporal \u003d thisQuery.queryFrom(temporal);\n   temporal \u003d temporal.query(thisQuery);\n \u003c/pre\u003e\n It is recommended to use the second approach, {@code query(TemporalQuery)},\n as it is a lot clearer to read in code.\n \u003cp\u003e\n The most common implementations are method references, such as\n {@code LocalDate::from} and {@code ZoneId::from}.\n Additional common queries are provided to return:\n \u003cul\u003e\n \u003cli\u003e a Chronology,\n \u003cli\u003e a LocalDate,\n \u003cli\u003e a LocalTime,\n \u003cli\u003e a ZoneOffset,\n \u003cli\u003e a precision,\n \u003cli\u003e a zone, or\n \u003cli\u003e a zoneId.\n \u003c/ul\u003e","isClass":true,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":false,"isOrdinaryClass":true,"isPrimitive":false,"simpleName":"TemporalQueries","qualifiedName":"java.time.temporal.TemporalQueries","dimension":"","elementType":{},"package":"java.time.temporal","superclass":"java.lang.Object","interfaces":[],"isAbstract":false,"isStatic":false,"since":"1.8","innerClasses":[],"isInnerClass":false,"constructors":[],"fields":[],"methods":[{"name":"zoneId","comment":"A strict query for the {@code ZoneId}.\n \u003cp\u003e\n This queries a {@code TemporalAccessor} for the zone.\n The zone is only returned if the date-time conceptually contains a {@code ZoneId}.\n It will not be returned if the date-time only conceptually has an {@code ZoneOffset}.\n Thus a {@link java.time.ZonedDateTime} will return the result of {@code getZone()},\n but an {@link java.time.OffsetDateTime} will return null.\n \u003cp\u003e\n In most cases, applications should use {@link #zone()} as this query is too strict.\n \u003cp\u003e\n The result from JDK classes implementing {@code TemporalAccessor} is as follows:\u003cbr\u003e\n {@code LocalDate} returns null\u003cbr\u003e\n {@code LocalTime} returns null\u003cbr\u003e\n {@code LocalDateTime} returns null\u003cbr\u003e\n {@code ZonedDateTime} returns the associated zone\u003cbr\u003e\n {@code OffsetTime} returns null\u003cbr\u003e\n {@code OffsetDateTime} returns null\u003cbr\u003e\n {@code ChronoLocalDate} returns null\u003cbr\u003e\n {@code ChronoLocalDateTime} returns null\u003cbr\u003e\n {@code ChronoZonedDateTime} returns the associated zone\u003cbr\u003e\n {@code Era} returns null\u003cbr\u003e\n {@code DayOfWeek} returns null\u003cbr\u003e\n {@code Month} returns null\u003cbr\u003e\n {@code Year} returns null\u003cbr\u003e\n {@code YearMonth} returns null\u003cbr\u003e\n {@code MonthDay} returns null\u003cbr\u003e\n {@code ZoneOffset} returns null\u003cbr\u003e\n {@code Instant} returns null\u003cbr\u003e","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":false,"simpleName":"TemporalQuery","qualifiedName":"java.time.temporal.TemporalQuery","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[],"typeParameters":[]},{"name":"chronology","comment":"A query for the {@code Chronology}.\n \u003cp\u003e\n This queries a {@code TemporalAccessor} for the chronology.\n If the target {@code TemporalAccessor} represents a date, or part of a date,\n then it should return the chronology that the date is expressed in.\n As a result of this definition, objects only representing time, such as\n {@code LocalTime}, will return null.\n \u003cp\u003e\n The result from JDK classes implementing {@code TemporalAccessor} is as follows:\u003cbr\u003e\n {@code LocalDate} returns {@code IsoChronology.INSTANCE}\u003cbr\u003e\n {@code LocalTime} returns null (does not represent a date)\u003cbr\u003e\n {@code LocalDateTime} returns {@code IsoChronology.INSTANCE}\u003cbr\u003e\n {@code ZonedDateTime} returns {@code IsoChronology.INSTANCE}\u003cbr\u003e\n {@code OffsetTime} returns null (does not represent a date)\u003cbr\u003e\n {@code OffsetDateTime} returns {@code IsoChronology.INSTANCE}\u003cbr\u003e\n {@code ChronoLocalDate} returns the associated chronology\u003cbr\u003e\n {@code ChronoLocalDateTime} returns the associated chronology\u003cbr\u003e\n {@code ChronoZonedDateTime} returns the associated chronology\u003cbr\u003e\n {@code Era} returns the associated chronology\u003cbr\u003e\n {@code DayOfWeek} returns null (shared across chronologies)\u003cbr\u003e\n {@code Month} returns {@code IsoChronology.INSTANCE}\u003cbr\u003e\n {@code Year} returns {@code IsoChronology.INSTANCE}\u003cbr\u003e\n {@code YearMonth} returns {@code IsoChronology.INSTANCE}\u003cbr\u003e\n {@code MonthDay} returns null {@code IsoChronology.INSTANCE}\u003cbr\u003e\n {@code ZoneOffset} returns null (does not represent a date)\u003cbr\u003e\n {@code Instant} returns null (does not represent a date)\u003cbr\u003e\n \u003cp\u003e\n The method {@link java.time.chrono.Chronology#from(TemporalAccessor)} can be used as a\n {@code TemporalQuery} via a method reference, {@code Chronology::from}.\n That method is equivalent to this query, except that it throws an\n exception if a chronology cannot be obtained.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":false,"simpleName":"TemporalQuery","qualifiedName":"java.time.temporal.TemporalQuery","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[],"typeParameters":[]},{"name":"precision","comment":"A query for the smallest supported unit.\n \u003cp\u003e\n This queries a {@code TemporalAccessor} for the time precision.\n If the target {@code TemporalAccessor} represents a consistent or complete date-time,\n date or time then this must return the smallest precision actually supported.\n Note that fields such as {@code NANO_OF_DAY} and {@code NANO_OF_SECOND}\n are defined to always return ignoring the precision, thus this is the only\n way to find the actual smallest supported unit.\n For example, were {@code GregorianCalendar} to implement {@code TemporalAccessor}\n it would return a precision of {@code MILLIS}.\n \u003cp\u003e\n The result from JDK classes implementing {@code TemporalAccessor} is as follows:\u003cbr\u003e\n {@code LocalDate} returns {@code DAYS}\u003cbr\u003e\n {@code LocalTime} returns {@code NANOS}\u003cbr\u003e\n {@code LocalDateTime} returns {@code NANOS}\u003cbr\u003e\n {@code ZonedDateTime} returns {@code NANOS}\u003cbr\u003e\n {@code OffsetTime} returns {@code NANOS}\u003cbr\u003e\n {@code OffsetDateTime} returns {@code NANOS}\u003cbr\u003e\n {@code ChronoLocalDate} returns {@code DAYS}\u003cbr\u003e\n {@code ChronoLocalDateTime} returns {@code NANOS}\u003cbr\u003e\n {@code ChronoZonedDateTime} returns {@code NANOS}\u003cbr\u003e\n {@code Era} returns {@code ERAS}\u003cbr\u003e\n {@code DayOfWeek} returns {@code DAYS}\u003cbr\u003e\n {@code Month} returns {@code MONTHS}\u003cbr\u003e\n {@code Year} returns {@code YEARS}\u003cbr\u003e\n {@code YearMonth} returns {@code MONTHS}\u003cbr\u003e\n {@code MonthDay} returns null (does not represent a complete date or time)\u003cbr\u003e\n {@code ZoneOffset} returns null (does not represent a date or time)\u003cbr\u003e\n {@code Instant} returns {@code NANOS}\u003cbr\u003e","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":false,"simpleName":"TemporalQuery","qualifiedName":"java.time.temporal.TemporalQuery","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[],"typeParameters":[]},{"name":"zone","comment":"A lenient query for the {@code ZoneId}, falling back to the {@code ZoneOffset}.\n \u003cp\u003e\n This queries a {@code TemporalAccessor} for the zone.\n It first tries to obtain the zone, using {@link #zoneId()}.\n If that is not found it tries to obtain the {@link #offset()}.\n Thus a {@link java.time.ZonedDateTime} will return the result of {@code getZone()},\n while an {@link java.time.OffsetDateTime} will return the result of {@code getOffset()}.\n \u003cp\u003e\n In most cases, applications should use this query rather than {@code #zoneId()}.\n \u003cp\u003e\n The method {@link ZoneId#from(TemporalAccessor)} can be used as a\n {@code TemporalQuery} via a method reference, {@code ZoneId::from}.\n That method is equivalent to this query, except that it throws an\n exception if a zone cannot be obtained.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":false,"simpleName":"TemporalQuery","qualifiedName":"java.time.temporal.TemporalQuery","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[],"typeParameters":[]},{"name":"offset","comment":"A query for {@code ZoneOffset} returning null if not found.\n \u003cp\u003e\n This returns a {@code TemporalQuery} that can be used to query a temporal\n object for the offset. The query will return null if the temporal\n object cannot supply an offset.\n \u003cp\u003e\n The query implementation examines the {@link ChronoField#OFFSET_SECONDS OFFSET_SECONDS}\n field and uses it to create a {@code ZoneOffset}.\n \u003cp\u003e\n The method {@link java.time.ZoneOffset#from(TemporalAccessor)} can be used as a\n {@code TemporalQuery} via a method reference, {@code ZoneOffset::from}.\n This query and {@code ZoneOffset::from} will return the same result if the\n temporal object contains an offset. If the temporal object does not contain\n an offset, then the method reference will throw an exception, whereas this\n query will return null.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":false,"simpleName":"TemporalQuery","qualifiedName":"java.time.temporal.TemporalQuery","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[],"typeParameters":[]},{"name":"localDate","comment":"A query for {@code LocalDate} returning null if not found.\n \u003cp\u003e\n This returns a {@code TemporalQuery} that can be used to query a temporal\n object for the local date. The query will return null if the temporal\n object cannot supply a local date.\n \u003cp\u003e\n The query implementation examines the {@link ChronoField#EPOCH_DAY EPOCH_DAY}\n field and uses it to create a {@code LocalDate}.\n \u003cp\u003e\n The method {@link ZoneOffset#from(TemporalAccessor)} can be used as a\n {@code TemporalQuery} via a method reference, {@code LocalDate::from}.\n This query and {@code LocalDate::from} will return the same result if the\n temporal object contains a date. If the temporal object does not contain\n a date, then the method reference will throw an exception, whereas this\n query will return null.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":false,"simpleName":"TemporalQuery","qualifiedName":"java.time.temporal.TemporalQuery","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[],"typeParameters":[]},{"name":"localTime","comment":"A query for {@code LocalTime} returning null if not found.\n \u003cp\u003e\n This returns a {@code TemporalQuery} that can be used to query a temporal\n object for the local time. The query will return null if the temporal\n object cannot supply a local time.\n \u003cp\u003e\n The query implementation examines the {@link ChronoField#NANO_OF_DAY NANO_OF_DAY}\n field and uses it to create a {@code LocalTime}.\n \u003cp\u003e\n The method {@link ZoneOffset#from(TemporalAccessor)} can be used as a\n {@code TemporalQuery} via a method reference, {@code LocalTime::from}.\n This query and {@code LocalTime::from} will return the same result if the\n temporal object contains a time. If the temporal object does not contain\n a time, then the method reference will throw an exception, whereas this\n query will return null.","isClass":false,"isInterface":false,"isEnum":false,"isEnumConstant":false,"isConstructor":false,"isField":false,"isMethod":true,"isOrdinaryClass":false,"signature":"()","flatSignature":"()","returnType":{"isPrimitive":false,"simpleName":"TemporalQuery","qualifiedName":"java.time.temporal.TemporalQuery","dimension":"","elementType":{}},"isAbstract":false,"isDefault":false,"isStatic":true,"parameters":[],"typeParameters":[]}],"typeParameters":[],"enumConstants":[]}